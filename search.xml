<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[常用函数的封装]]></title>
    <url>%2Funcategorized%2F%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E7%9A%84%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[常用函数的封装常用函数的封装： 字符串操作常用函数 大小写转换函数 分割字符串函数 字符串转换函数 字符串替换函数 时间操作常用函数 帮助类定义字符串操作封装1234567891011121314151617181920212223242526272829303132333435class YR_Common&#123;public: //去掉头部及尾部的字符或者字符串 //bool为true 去除s中的每个字符，为false去除s字符串 static string trim(const string&amp; sStr, const string&amp; s=" \r\n\t", bool bChar=true); //去掉左边的字符或者字符串 static string trimleft(const string &amp;sStr, const string &amp;s = " \r\n\t", bool bChar = true); //去掉右边的字符或者字符串 static string trimright(const string &amp;sStr, const string &amp;s = " \r\n\t", bool bChar = true); //字符串转换成小写 static string lower(const string &amp;sString); //字符串转换成大写 static string upper(const string &amp;sString); //字符串是否都是数字 static bool isdigit(const string &amp;sInput); //字符串转换成时间结构 static int strTotm(const string &amp;sString, const string &amp;sFormat, struct tm &amp;stTm); //时间转换为字符串,默认格式为sFormat格式 static string tmTostr(const struct tm &amp;stTm, const string &amp;sFormat = "%Y%m%d%H%M%S"); static string tmTostr(const time_t &amp;t, const string &amp;sFormat = "%Y%m%d%H%M%S"); //当前时间转换为字符串 static string nowTostr(const string &amp;sFormat = "%Y%m%d%H%M%S"); //获取当前时间的毫秒数 static int64_t nowToms(); //获取当前时间的微秒数 static int64_t nowTous(); //字符串转换函数 template&lt;typename T&gt; static T strto(const string &amp;sStr); template&lt;typename T&gt; static T strto(const string &amp;sStr, const string &amp;sDefault); &#125;; 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140string YR_Common::trim(const string &amp;sStr, const string &amp;s, bool bChar)&#123; if(sStr.empty()) return sStr; if(!bChar) //当bChar为false，则去除s字符串 //先去掉字符串左边的字符串，再去掉右边的字符串 return trimright(trimleft(sStr, s, false), s, false); return trimright(trimleft(sStr, s, true), s, true);&#125;string YR_Common::trimleft(const string &amp;sStr, const string &amp;s, bool bChar)&#123; if(sStr.empty()) return sStr; //如果bChar为false，则去除s字符串 if(!bChar) &#123; if(sStr.length() &lt; s.length()) return sStr; if(sStr.compare(0, s.length(), s) == 0) &#123; return sStr.substr(s.length()); &#125; return sStr; &#125; /** * 去掉sStr左边的 字符串s中的字符 */ return sStr.substr(sStr.find_first_not_of(s));&#125;string YR_Common::trimright(const string &amp;sStr, const string &amp;s, bool bChar)&#123; if(sStr.empty()) return sStr; /** * 去掉sStr右边的字符串s */ if(!bChar) &#123; if(sStr.length() &lt; s.length()) &#123; return sStr; &#125; if(sStr.compare(sStr.length() - s.length(), s.length(), s) == 0) &#123; return sStr.substr(0, sStr.length() - s.length()); &#125; return sStr; &#125; /** * 去掉sStr右边的 字符串s中的字符 */ return sStr.substr(0, sStr.find_first_not_of(s));&#125;//toupper和tolower原型：//int toupper(int c);//int tolower(int c);string YR_Common::lower(const string &amp;s)&#123; string sStr = s; for(int i=0;i&lt;sStr.length();i++) sStr[i] = tolower(sStr[i]); return sStr;&#125;string YR_Common::upper(const string &amp;s)&#123; string sStr = s; for(int i=0;i&lt;sStr.length();i++) sStr[i] = toupper(sStr[i]); return sStr;&#125;bool YR_Common::isdigit(const string &amp;sInput)&#123; return std::count_if(sInput.begin(),sInput.end(),[](char c)&#123; return ::isdigit(c); &#125;) == static_cast&lt;int32_t&gt;(sInput.length());&#125;//strptime和strftime原型：// #include &lt;time.h&gt;//char *strptime(const char *s, const char *format, struct tm *tm);//std::size_t strftime( char* str, std::size_t count, const char* format, const std::tm* time );//struct tm &#123;// int tm_sec; /* Seconds (0-60) */// int tm_min; /* Minutes (0-59) */// int tm_hour; /* Hours (0-23) */// int tm_mday; /* Day of the month (1-31) */// int tm_mon; /* Month (0-11) */// int tm_year; /* Year - 1900 */// int tm_wday; /* Day of the week (0-6, Sunday = 0) */// int tm_yday; /* Day in the year (0-365, 1 Jan = 0) */// int tm_isdst; /* Daylight saving time *///&#125;;int YR_Common::strTotm(const string &amp;sString, const string &amp;sFormat, struct tm &amp;stTm)&#123; char *p = strptime(sString.c_str(), sFormat.c_str(), &amp;stTm); return (p != NULL) ? 0 : -1;&#125;string YR_Common::tmTostr(const struct tm &amp;stTm, const string &amp;sFormat)&#123; char sTimeString[255] = "\0"; strftime(sTimeString, sizeof(sTimeString), sFormat.c_str(), &amp;stTm); return string(sTimeString);&#125;string YR_Common::tmTostr(const time_t &amp;t, const string &amp;sFormat)&#123; struct tm tt; localtime_r(&amp;t, &amp;tt); return tmTostr(tt, sFormat);&#125;string YR_Common::nowTostr(const string &amp;sFormat)&#123; time_t t = time(NULL); return tmTostr(t, sFormat.c_str());&#125;//原型：// #include &lt;sys/time.h&gt;//int gettimeofday(struct timeval *tv, struct timezone *tz);//int settimeofday(const struct timeval *tv, const struct timezone *tz);//struct timeval &#123;// time_t tv_sec; /* seconds */// suseconds_t tv_usec; /* microseconds *///&#125;;int64_t YR_Common::nowToms()&#123; struct timeval tv; gettimeofday(&amp;tv, 0); return tv.tv_sec * (int64_t)1000 + tv.tv_usec/1000;&#125;int64_t YR_Common::nowTous()&#123; struct timeval tv; gettimeofday(&amp;tv, 0); return tv.tv_sec * (int64_t)1000000 + tv.tv_usec;&#125; 未完待续~]]></content>
      <tags>
        <tag>-C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程池的设计]]></title>
    <url>%2Funcategorized%2F%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[线程池的设计线程池，顾名思义就是一个存放了已经创建好的线程资源的池子，当有任务提交给线程池的时候，池中的某一个线程就会执行该任务，执行完毕之后就会回到池子中等待下次执行任务。 从上图中我们可以看到，实现一个线程池应该具备下列要素： 线程队列：提交的任务缓冲在这里 线程数量管理功能 任务拒绝策略 队列长度 线程安全队列的封装线程安全队列的封装 线程池的定义12345678910111213141516171819202122232425262728293031323334353637383940414243444546class YR_ThreadPool : public YR_ThreadLock &#123;public: YR_ThreadPool(); virtual ~YR_ThreadPool(); //线程池的初始化 void init(int num); //启动所有线程 void start(); //终止线程池 void terminate(); //获取线程数量 size_t getThreadNum() const; //获取线程池的任务数量 size_t getThreadJobNum() const; //添加任务 bool Execute(std::function&lt;void()&gt; tf); //清除线程池 void clear(); //通知等待在任务队列的线程醒来 void notifyT(); //等待所有工作全部结束 //millsecond表示等待的时间 bool waitForAllDone(int millsecond = -1);public: //线程中的工作线程 class YR_ThreadWorker : public YR_Thread &#123; public: YR_ThreadWorker(YR_ThreadPool *pool); ~YR_ThreadWorker(); virtual void run(); //实现逻辑 void terminate(); //线程终止 private: YR_ThreadPool* _tpool; bool _bTerminate; //是否结束线程 &#125;;private: YR_ThreadQueue&lt;std::function&lt;void()&gt;&gt; _jobqueue; //任务队列 YR_ThreadLock _tmutex; //任务队列的锁 std::vector&lt;YR_ThreadWorker*&gt; _jobthread; //工作队列 std::set&lt;YR_ThreadWorker*&gt; _busthread; //繁忙线程 bool _bAllDone; //是否所有任务执行完毕&#125;; 线程池的实现构造与析构12345678YR_ThreadPool::YR_ThreadPool() :bAllDone(true)&#123;&#125;YR_ThreadPool::~YR_ThreadPool()&#123; terminate(); clear();&#125; 线程池的初始化12345678910void YR_ThreadPool::init(size_t num)&#123; terminate(); Lock sync(*this); clear(); for(size_t i=0; i&lt;num; i++) &#123; _jobthread.push_back(new ThreadWorker(this)); &#125;&#125; 启动所有线程1234567891011void YR_ThreadPool::start()&#123; Lock sync(*this); auto it = _jobthread.begin(); while(it != _jobthread.end()) &#123; (*it)-&gt;start(); ++it; &#125; _bAllDone = false;&#125; 终止线程池1234567891011121314void YR_ThreadPool::terminate()&#123; Lock sync(*this); auto it = _jobthread.begin(); while(it != _jobthread.end()) &#123; if((*it)-&gt;isAlive()) &#123; (*it)-&gt;terminate(); (*it)-&gt;getThreadControl.join(); //线程回收 &#125; ++it; &#125;&#125; 获取线程数数量12345size_t YR_ThreadPool::getThreadNum()&#123; Lock sync(*this); return _jobthread.size();&#125; 获取线程池的任务数量1234size_t YR_ThreadPool::getThreadJobNum()&#123; return _jobqueue.size();&#125; 添加任务1234void YR_ThreadPool::Execute(std::function&lt;void()&gt; tf)&#123; _jobqueue.push_back(std::move(tf));&#125; 清除线程池1234567891011void YR_ThreadPool::clear()&#123; auto it = _jobthread.begin(); while(it != _jobthread.end()) &#123; delete(*it); ++it; &#125; _jobthread.clear(); _busthread.clear();&#125; 通知等待在工作队列的线程醒来1234void YR_ThreadPool::notifyT()&#123; _jobqueue.notifyT();&#125; 线程运行逻辑123456789101112131415161718192021222324252627282930313233void YR_ThreadPool::ThreadWorker::run()&#123; //调用初始化部分 auto pst = _tpool-&gt;get(); if(pst) &#123; try &#123; pst(); &#125; catch ( ... ) &#123; &#125; &#125; //调用处理部分 while (!_bTerminate) &#123; auto pfw = _tpool-&gt;get(this); if(pfw) &#123; try &#123; pfw(); &#125; catch ( ... ) &#123; &#125; _tpool-&gt;idle(this); &#125; &#125; //结束 _tpool-&gt;exit();&#125; 工作线程终止12345void YR_ThreadPool::ThreadWorker::terminate()&#123; _bTerminate = true; _tpool-&gt;notifyT();&#125; 等待所有工作全部结束123456789101112131415161718192021222324252627282930313233bool YR_ThreadPool::waitForAllDone(int millsecond)&#123; Lock sync(_tmutex);start1: //任务队列和繁忙线程都是空的 if (finish()) &#123; return true; &#125; //永远等待 if(millsecond &lt; 0) &#123; _tmutex.timedWait(1000); goto start1; &#125; int64_t iNow= YR_Common::nowToms(); int m = millsecond;start2: bool b = _tmutex.timedWait(millsecond); //完成处理了 if(finish()) &#123; return true; &#125; if(!b) &#123; return false; &#125; millsecond = max((int64_t)0, m - (YR_Common::nowToms() - iNow)); goto start2; return false;&#125; 线程存储“防止任务在共享资源上发生冲突的第二种方式是根除对变量的共享”。线程局部存储为每一个访问此变量的线程提供一个此变量独立的副本，线程可以修改此变量，而不会影响到其他线程。 线程私有数据的封装123456789class ThreadData&#123;public: ThreadData()&#123;&#125; virtual ThreadData()&#123;&#125; template&lt;class T&gt; static T* makeThreadData()&#123; return new T;&#125;&#125;; YR_ThreadPool类中添加pthread_key_t g_key属性。 YR_ThreadPool类中添加static void destructor(void *p);方法，用来销毁线程数据。 线程池中添加线程私有数据的操作方法线程存储的操作方法 1234567891011121314#include &lt;pthread.h&gt;// Returns 0 on success, or a positive error number on errorint pthread_key_create (pthread_key_t *key, void (*destructor)(void *));// Returns 0 on success, or a positive error number on errorint pthread_key_delete (pthread_key_t key);// Returns 0 on success, or a positive error number on errorint pthread_setspecific (pthread_key_t key, const void *value);//该函数将value的值（不是内容）与key相关联。用pthread_setspecific为一个键指定新的线程数据时，线程必须先释放原有的线程数据用以回收空间。// Returns pointer, or NULL if no thread-specific data is associated with keyvoid *pthread_getspecific (pthread_key_t key); 原理参考：linux线程私有数据详解 1234567891011121314151617181920212223242526272829303132333435363738394041static void setThreadData(ThreadData *p)&#123; //释放原有的线程数据 YR_ThreadPool::ThreadData *pOld = getThreadData(); if(pOld != NULL &amp;&amp; pOld != p) delete pOld; int ret = pthread_setspecific(g_key, (void*)p); if(ret != 0) &#123; throw YR_ThreadPool_Exception("[YR_ThreadPool::setThreadData] pthread_setspecific error",ret); &#125;&#125;static void setThreadData(pthread_key_t pkey, ThreadData *p)&#123; //释放原有的线程数据 YR_ThreadPool::ThreadData *pOld = getThreadData(pkey); if(pOld != NULL &amp;&amp; pOld != p) delete pOld; int ret = pthread_setspecific(pkey, (void *)p); if(ret != 0) &#123; throw YR_ThreadPool_Exception("[YR_ThreadPool::setThreadData] pthread_setspecific error", ret); &#125;&#125;static ThreadData* getThreadData()&#123; return (ThreadData*)pthread_getspecific(g_key);&#125;static ThreadData* getThreadData(pthread_key_t pkey)&#123; return (ThreadData*)pthread_getspecific(pkey);&#125;//析构函数static void destructor(void *p)&#123; ThreadData* ttd = (ThreadData*)p; delete ttd;&#125; key的初始化12345678910111213141516171819class KeyInitialize&#123;public: //初始化key KeyInitialize() &#123; int ret = pthread_key_create(&amp;YR_ThreadPool::g_key, YR_ThreadPool::destructor); if(ret != 0) &#123; throw YR_ThreadPool_Exception("[YR_ThreadPool::KeyInitialize] pthread_key_create error", ret); &#125; &#125; //释放key ~KeyInitialize() &#123; pthread_key_delete(YR_ThreadPool::g_key); &#125;&#125;; YR_ThreadPool添加static KeyInitialize g_key_initialize属性。]]></content>
      <tags>
        <tag>-C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程队列的封装]]></title>
    <url>%2Funcategorized%2F%E7%BA%BF%E7%A8%8B%E9%98%9F%E5%88%97%E7%9A%84%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[线程队列的封装C++中虽然有std::queue、std::deque这些队列容器，但是不是线程安全的，因此我们需要封装一个线程安全的线程队列。 定义12345678910111213141516171819202122232425template &lt;class T, class Container = std::queue&lt;T&gt;&gt;class YR_Thread_Queue : protected YR_ThreadLock&#123;public: typedef Container queue_type; YR_Thread_Queue() : _size(0)&#123; &#125;public: void push_front(const T&amp; t); void push_front(const queue_type&amp; qt); void push_back(const T&amp; t); void push_back(const queue_type&amp; qt); //从头部获取数据，没有数据则等待 //millsecond为阻塞等待时间,0为不阻塞，-1为永久等待 bool pop_front(T&amp; t, int millsecond = 0); size_t size() const &#123; Lock lock(*this); return _size;&#125; void clear() &#123; Lock lock(*this); _queue.clear();_size=0;&#125; bool empty() &#123; Lock lock(*this); return _queue.empty();&#125;private: //队列 queue_type _queue; //队列长度 size_t _size;&#125;; 实现push_back1234567891011121314151617181920212223242526template &lt;class T, class Container&gt;void YR_Thread_Queue&lt;T,Container&gt;::push_back(const T&amp; t)&#123; //在queue的push_back函数前加锁保证线程安全 //构造加锁，析构解锁 Lock lock(*this); notify(); _queue.push_back(t); ++_size;&#125;template&lt;class T, class Container&gt;void YR_Thread_Queue&lt;T,Container&gt;::push_back(const queue_type&amp; qt)&#123; Lock lock(*this); auto it = qt.begin(); auto end = qt.end(); while(it != end) &#123; notify(); _queue.push_back(*it); ++it; ++_size; &#125;&#125; push_front123456789101112131415161718192021222324template&lt;typename T, typename Container&gt;void YR_ThreadQueue&lt;T, Container&gt;::push_front(const T&amp; t)&#123; Lock lock(*this); notify(); _queue.push_front(t); ++_size;&#125;template&lt;class T, class Container&gt;void YR_Thread_Queue&lt;T,Container&gt;::push_front(const queue_type&amp; qt)&#123; Lock lock(*this); auto it = qt.begin(); auto end = qt.end(); while(it != end) &#123; notify(); _queue.push_front(*it); ++it; ++_size; &#125;&#125; 获取数据12345678910111213141516171819202122232425template&lt;class T, class Container&gt;bool YR_Thread_Queue&lt;T,Container&gt;::pop_front(T&amp; t, int millsecond)&#123; Lock lock(*this); if(_queue.empty()) &#123; if(millsecond == 0) return false; if(millsecond == (size_t)-1) wait(); else &#123; if(!timeWait(millsecond)) return false; &#125; &#125; if(_queue.empty()) return false; t= _queue.front(); _queue.pop_front(); assert(_size &gt; 0); --_size(); return true;&#125;]]></content>
      <tags>
        <tag>-C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程控制类的封装]]></title>
    <url>%2Funcategorized%2F%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[线程控制类的封装线程常用方法12345int pthread_join(pthread_t thread, void **retval);int pthread_detach(pthread_t thread);pthread_t pthread_self(void);int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg); 定义1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * @brief 线程控制异常类 */struct YR_ThreadThreadControl_Exception : public YR_Exception&#123; YR_ThreadThreadControl_Exception(const string &amp;buffer) : YR_Exception(buffer)&#123;&#125;; YR_ThreadThreadControl_Exception(const string &amp;buffer, int err) : YR_Exception(buffer, err)&#123;&#125;; ~YR_ThreadThreadControl_Exception() throw() &#123;&#125;;&#125;;/** * @brief 线程控制类 */class YR_ThreadControl&#123;public: /** * @brief 构造, 表示当前运行的线程， * join和detach在不能在该对象上调用 */ YR_ThreadControl(); /** * @return explicit */ explicit YR_ThreadControl(pthread_t); /** * @brief 等待当前线程结束, 不能在当前线程上调用 */ void join(); /** * @brief detach, 不能在当前线程上调用 */ void detach(); /** * @brief 获取当前线程id. * * @return pthread_t当前线程id */ pthread_t id() const; /** * @brief 休息ms时间. * * @param millsecond 休息的时间，具体ms数字 */ static void sleep(long millsecond); /** * @brief 交出当前线程控制权 */ static void yield();private: pthread_t _thread;&#125;; 实现构造和析构123456YR_ThreadControl::YR_ThreadControl(pthread_t thread) : _thread(thread)&#123;&#125;YR_ThreadControl::YR_ThreadControl() : _thread(pthread_self())&#123;&#125; 控制方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546void YR_ThreadControl::join()&#123; if(pthread_self() == _thread) &#123; throw YR_ThreadThreadControl_Exception("[YR_ThreadControl::join] can't be called in the same thread"); &#125; void* ignore = 0; int rc = pthread_join(_thread, &amp;ignore); if(rc != 0) &#123; throw YR_ThreadThreadControl_Exception("[YR_ThreadControl::join] pthread_join error ", rc); &#125;&#125;void YR_ThreadControl::detach()&#123; if(pthread_self() == _thread) &#123; throw YR_ThreadThreadControl_Exception("[YR_ThreadControl::join] can't be called in the same thread"); &#125; int rc = pthread_detach(_thread); if(rc != 0) &#123; throw YR_ThreadThreadControl_Exception("[YR_ThreadControl::join] pthread_join error", rc); &#125;&#125;pthread_t YR_ThreadControl::id() const&#123; return _thread;&#125;void YR_ThreadControl::sleep(long millsecond)&#123; struct timespec ts; ts.tv_sec = millsecond / 1000; ts.tv_nsec = (millsecond % 1000)*1000000; nanosleep(&amp;ts, 0);&#125;void YR_ThreadControl::yield()&#123; sched_yield();&#125; 线程基类的定义123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class YR_Runable&#123;public: virtual ~YR_Runable()&#123;&#125;; virtual void run() = 0;&#125;;/** * @brief 线程基类. * 线程基类，所有自定义线程继承于该类，同时实现run接口即可, * * 可以通过YR_ThreadContorl管理线程。 */class YR_Thread : public YR_Runable&#123;public: YR_Thread(); virtual ~YR_Thread()&#123;&#125;; /** * @brief 线程运行 */ YR_ThreadControl start(); /** * @brief 获取线程控制类. * * @return ThreadControl */ YR_ThreadControl getThreadControl() const; /** * @brief 线程是否存活. * * @return bool 存活返回true，否则返回false */ bool isAlive() const; /** * @brief 获取线程id. * * @return pthread_t 线程id */ pthread_t id() &#123; return _tid; &#125;protected: /** * @brief 静态函数, 线程入口. * * @param pThread 线程对象 */ static void threadEntry(YR_Thread *pThread); /** * @brief 运行 */ virtual void run() = 0;protected: /** * 是否在运行 */ bool _running; /** * 线程ID */ pthread_t _tid; /** * 普通线程锁 */ YR_ThreadLock _lock;&#125;; 实现构造123YR_Thread::YR_Thread() : _running(false),_tid(-1)&#123;&#125; 线程入口1234567891011121314151617181920212223void YR_Thread::threadEntry(YR_Thread *pThread)&#123; pThread-&gt;_running = true; &#123; //YR_ThreadLock::Lock -&gt; // YR_Monitor&lt;YR_ThreadMutex, YR_ThreadCond&gt;::YR_LockT&lt;YR_Monitor&lt;YR_ThreadMutex, // YR_ThreadCond&gt;&gt; //构造时加锁，析构时解锁 YR_ThreadLock::Lock sync(pThread-&gt;_lock); pThread-&gt;_lock.notifyAll(); &#125; try &#123; pThread-&gt;run(); &#125; catch(...) &#123; pThread-&gt;_running = false; throw; &#125; pThread-&gt;_running = false;&#125; 线程启动123456789101112131415161718192021222324YR_ThreadControl YR_Thread::start()&#123; //构造时加锁，析构时解锁 YR_ThreadLock::Lock sync(_lock); if(_running) &#123; throw YR_ThreadThreadControl_Exception("[YR_Thread::start] thread has start"); &#125; int ret = pthread_create(&amp;_tid, 0, (void *(*)(void *))&amp;threadEntry, (void *)this); if(ret != 0) &#123; throw YR_ThreadThreadControl_Exception("[YR_Thread::start] thread start error", ret); &#125; _lock.wait(); return YR_ThreadControl(_tid);&#125; 其他函数实现12345678910YR_ThreadControl YR_Thread::getThreadControl() const&#123; return YR_ThreadControl(_tid);&#125;bool YR_Thread::isAlive() const&#123; return _running;&#125;]]></content>
      <tags>
        <tag>-C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程信号类的封装]]></title>
    <url>%2Funcategorized%2F%E7%BA%BF%E7%A8%8B%E6%9D%A1%E4%BB%B6%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[线程条件类的封装线程条件的基本操作1234567891011121314151617#include &lt;pthread.h&gt;//条件的销毁和初始化int pthread_cond_destroy(pthread_cond_t *cond);int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);pthread_cond_t cond = PTHREAD_COND_INITIALIZER;//线程条件等待int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);//带有超时等待的函数int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime);//线程唤醒int pthread_cond_signal(pthread_cond_t *cond);int pthread_cond_broadcast(pthread_cond_t *cond); 线程条件类的定义123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//线程信号异常类struct YR_ThreadCond_Exception : public YR_Exception&#123; YR_ThreadCond_Exception(const string &amp;buffer) : YR_Exception(buffer)&#123;&#125;; YR_ThreadCond_Exception(const string &amp;buffer, int err) : YR_Exception(buffer, err)&#123;&#125;; ~YR_ThreadCond_Exception() throw() &#123;&#125;;&#125;;//线程信号类，所有锁在上面等待信号发生class YR_ThreadCond&#123;public: YR_ThreadCond(); ~YR_ThreadCond(); /** * @brief 发送信号, 等待在该条件上的一个线程会醒 */ void signal(); /** * @brief 等待在该条件的所有线程都会醒 */ void broadcast(); /** * @brief 获取绝对等待时间 */ timespec abstime(int millsecond) const; /** * @brief 无限制等待. * * @param M */ template&lt;typename Mutex&gt; void wait(const Mutex&amp; mutex) const &#123; int c = mutex.count(); int rc = pthread_cond_wait(&amp;_cond, &amp;mutex._mutex); mutex.count(c); if(rc != 0) &#123; throw YR_ThreadCond_Exception("[YR_ThreadCond::wait] pthread_cond_wait error", errno); &#125; &#125; /** * @brief 等待时间. * * @param M * @return bool, false表示超时, true:表示有事件来了 */ template&lt;typename Mutex&gt; bool timedWait(const Mutex&amp; mutex, int millsecond) const &#123; int c = mutex.count(); timespec ts = abstime(millsecond); int rc = pthread_cond_timedwait(&amp;_cond, &amp;mutex._mutex, &amp;ts); mutex.count(c); if(rc != 0) &#123; if(rc != ETIMEDOUT) //如果超时 &#123; throw YR_ThreadCond_Exception("[YR_ThreadCond::timedWait] pthread_cond_timedwait error", errno); &#125; return false; &#125; return true; &#125;protected: YR_ThreadCond(const YR_ThreadCond&amp;); YR_ThreadCond&amp; operator=(const YR_ThreadCond&amp;);private: /** * 线程条件 */ mutable pthread_cond_t _cond;&#125;; 实现构造与析构1234567891011121314151617181920212223242526272829303132YR_ThreadCond::YR_ThreadCond()&#123; int rc; pthread_condattr_t attr; //定义条件属性对象 rc = pthread_condattr_init(&amp;attr); //1. 初始化条件属性对象 if(rc != 0) &#123; throw YR_ThreadCond_Exception("[YR_ThreadCond::YR_ThreadCond] pthread_condattr_init error", errno); &#125; rc = pthread_cond_init(&amp;_cond, &amp;attr); //2. 初始化条件 if(rc != 0) &#123; throw YR_ThreadCond_Exception("[YR_ThreadCond::YR_ThreadCond] pthread_cond_init error", errno); &#125; rc = pthread_condattr_destroy(&amp;attr); //3. 销毁条件属性对象 if(rc != 0) &#123; throw YR_ThreadCond_Exception("[YR_ThreadCond::YR_ThreadCond] pthread_condattr_destroy error", errno); &#125;&#125;YR_ThreadCond::~YR_ThreadCond()&#123; int rc = 0; rc = pthread_cond_destroy(&amp;_cond); if(rc != 0) &#123; cerr &lt;&lt; "[YR_ThreadCond::~YR_ThreadCond] pthread_cond_destroy error:" &lt;&lt; string(strerror(rc)) &lt;&lt; endl; &#125;&#125; 唤醒线程1234567891011121314151617void YR_ThreadCond::signal()&#123; int rc = pthread_cond_signal(&amp;_cond); if(rc != 0) &#123; throw YR_ThreadCond_Exception("[YR_ThreadCond::signal] pthread_cond_signal error", errno); &#125;&#125;void YR_ThreadCond::broadcast()&#123; int rc = pthread_cond_broadcast(&amp;_cond); if(rc != 0) &#123; throw YR_ThreadCond_Exception("[YR_ThreadCond::broadcast] pthread_cond_broadcast error", errno); &#125;&#125; 获取绝对等待时间（精度为纳秒）12345678910111213141516171819202122232425timespec YR_ThreadCond::abstime( int millsecond) const&#123; struct timeval tv; gettimeofday(&amp;tv, 0); //时间操作将会被封装，如下注释 //TC_TimeProvider::getInstance()-&gt;getNow(&amp;tv); //it 精度为微秒 int64_t it = tv.tv_sec * (int64_t)1000000 + tv.tv_usec + (int64_t)millsecond * 1000; tv.tv_sec = it / (int64_t)1000000; tv.tv_usec = it % (int64_t)1000000; timespec ts; ts.tv_sec = tv.tv_sec; ts.tv_nsec = tv.tv_usec * 1000; return ts; &#125;//注：timeval的最高精度为微秒，timespec的最高精度为纳秒// timeval由gettimeofday()获取系统时间// timespec由clock_gettime(clockid_t, struct timespec *)获取特定时间// CLOCK_REALTIME 统当前时间，从1970年1.1日算起// CLOCK_MONOTONIC 系统的启动时间，不能被设置// CLOCK_PROCESS_CPUTIME_ID 本进程运行时间// CLOCK_THREAD_CPUTIME_ID 本线程运行时间]]></content>
      <tags>
        <tag>-C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程控制类的封装]]></title>
    <url>%2Funcategorized%2F%E7%BA%BF%E7%A8%8B%E9%94%81%E7%9B%91%E6%8E%A7%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[线程锁监控类的封装互斥锁一个明显的缺点是它只有两种状态：锁定和非锁定。而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，它常和互斥锁一起配合使用。使用时，条件变量被用来阻塞一个线程，当条件不满足时，线程往往解开相应的互斥锁并等待条件发生变化。一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。这些线程将重新锁定互斥锁并重新测试条件是否满足。一般说来，条件变量被用来进行线程间的同步。 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176/* 通常线程锁，都通过该类来使用，而不是直接用YR_ThreadMutex、YR_ThreadRecMutex * * 该类将YR_ThreadMutex/YR_ThreadRecMutex 与YR_ThreadCond结合起来； */template &lt;class T, class P&gt; //T为线程锁类型，P为线程条件类型class YR_Monitor&#123;public: /** * @brief 定义锁控制对象 */ typedef YR_LockT&lt;TC_Monitor&lt;T, P&gt; &gt; Lock; //typedef YR_TryLockT&lt;TC_Monitor&lt;T, P&gt; &gt; TryLock; /** * @brief 构造函数 */ YR_Monitor() : _nnotify(0) &#123; &#125; /** * @brief 析够 */ virtual ~YR_Monitor() &#123; &#125; /** * @brief 锁 */ void lock() const &#123; _mutex.lock(); _nnotify = 0; &#125; /** * @brief 解锁, 根据上锁的次数通知 */ void unlock() const &#123; notifyImpl(_nnotify); _mutex.unlock(); &#125; /** * @brief 尝试锁. * * @return bool */ bool tryLock() const &#123; bool result = _mutex.tryLock(); if(result) &#123; _nnotify = 0; &#125; return result; &#125; /** * @brief 等待,当前调用线程在锁上等待，直到事件通知， */ void wait() const &#123; notifyImpl(_nnotify); try &#123; _cond.wait(_mutex); &#125; catch(...) &#123; _nnotify = 0; throw; &#125; _nnotify = 0; &#125; /** * @brief 等待时间,当前调用线程在锁上等待，直到超时或有事件通知 * * @param millsecond 等待时间 * @return false:超时了, ture:有事件来了 */ bool timedWait(int millsecond) const &#123; notifyImpl(_nnotify); bool rc; try &#123; rc = _cond.timedWait(_mutex, millsecond); &#125; catch(...) &#123; _nnotify = 0; throw; &#125; _nnotify = 0; return rc; &#125; /** * @brief 通知某一个线程醒来 * * 通知等待在该锁上某一个线程醒过来 ,调用该函数之前必须加锁, * * 在解锁的时候才真正通知 */ void notify() &#123; if(_nnotify != -1) &#123; ++_nnotify; &#125; &#125; /** * @brief 通知等待在该锁上的所有线程醒过来， * 注意调用该函数时必须已经获得锁. * * 该函数调用前之必须加锁, 在解锁的时候才真正通知 */ void notifyAll() &#123; _nnotify = -1; &#125;protected: /** * @brief 通知实现. * * @param nnotify 上锁的次数 */ void notifyImpl(int nnotify) const &#123; if(nnotify != 0) &#123; if(nnotify == -1) &#123; _cond.broadcast(); return; &#125; else &#123; while(nnotify &gt; 0) &#123; _cond.signal(); --nnotify; &#125; &#125; &#125; &#125;private: YR_Monitor(const YR_Monitor&amp;); void operator=(const YR_Monitor&amp;);protected: mutable int _nnotify; //上锁的次数 mutable P _cond; T _mutex;&#125;;//普通线程锁typedef YR_Monitor&lt;YR_ThreadMutex, YR_ThreadCond&gt; YR_ThreadLock;//循环锁(一个线程可以加多次锁)typedef YR_Monitor&lt;YR_ThreadRecMutex, YR_ThreadCond&gt; YR_ThreadRecLock;&#125; 这里互斥锁和条件变量的配合使用是下面的模式： 1234pthread_mutex_lock...pthread_cond_signalpthread_mutex_unlock 原因：详见参考 参考浅谈互斥锁为什么还要和条件变量配合使用]]></content>
      <tags>
        <tag>-C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程锁的封装]]></title>
    <url>%2Funcategorized%2F%E7%BA%BF%E7%A8%8B%E9%94%81%E7%9A%84%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[线程锁的封装线程锁的基本操作：1234561. 创建锁 int pthread_mutex_init(pthread_mutex_t*mutex, const pthread_mutexattr_t * attr); attr：创建锁的属性。一般默认为NULL，分为以下几个属性： * PTHREAD_MUTEX_TIMED_NP，这是缺省值，也就是普通锁。当一个线程加锁以后，其余请求锁的线程将形成一个等待队列，并在解锁后按优先级获得锁。这种锁策略保证了资源分配的公平性； * PTHREAD_MUTEX_RECURSIVE_NP，嵌套锁，允许同一个线程对同一个锁成功获得多次，并通过多次unlock解锁。如果是不同线程请求，则在加锁线程解锁时重新竞争； * PTHREAD_MUTEX_ERRORCHECK_NP，检错锁，如果同一个线程请求同一个锁，则返回EDEADLK，否则与PTHREAD_MUTEX_TIMED_NP类型动作相同。这样就保证当不允许多次加锁时不会出现最简单情况下的死锁； * PTHREAD_MUTEX_ADAPTIVE_NP，适应锁，动作最简单的锁类型，仅等待解锁后重新竞争； 12. 加锁 int pthread_mutex_lock(pthread_mutex_t*mutex); 13. 解锁 int pthread_mutex_unlock(pthread_mutex_t *mutex); 14. 尝试锁 int pthread_mutex_trylock(pthread_mutex_t *mutex); //锁被占用返回EBUSY，而非等待 15. 锁销毁 int pthread_mutexattr_destroy (pthread_mutex_t *mutex); 线程锁的封装线程锁异常123456struct YR_ThreadMutex_Exception : public YR_Lock_Exception&#123; YR_ThreadMutex_Exception(const string &amp;buffer) : YR_Lock_Exception(buffer)&#123;&#125;; YR_ThreadMutex_Exception(const string &amp;buffer, int err) : YR_Lock_Exception(buffer, err)&#123;&#125;; ~YR_ThreadMutex_Exception() throw() &#123;&#125;;&#125;; 线程锁的定义1234567891011121314class YR_ThreadMutex&#123;public: YR_ThreadMutex(); virtual ~YR_ThreadMutex(); //加锁 void lock() const; //解锁 void unlock() const; //尝试锁 bool tryLock() const;protected: mutable pthread_mutex_t _mutex; //创建线程锁&#125;; 实现锁的初始化可以放在构造函数里，这里分为四步来初始化线程锁_mutex： 12345678910111213141516171819202122232425YR_ThreadMutex::YR_ThreadMutex()&#123; int rc; pthread_mutexattr_t attr; //1. 创建线程锁属性对象 rc = pthread_mutexattr_init(&amp;attr); //初始化锁属性对象 assert(rc == 0); //2. 将锁属性中的锁类型设为检错锁 rc = pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_ERRORCHECK); assert(rc == 0); //3. 初始化锁对象 rc = pthread_mutex_init(&amp;_mutex, &amp;attr); assert(rc == 0); //4. 销毁锁属性对象 rc = pthread_mutexattr_destroy(&amp;attr); assert(rc == 0); //如果操作不成功，则抛出异常 if(rc != 0) &#123; throw TC_ThreadMutex_Exception("[TC_ThreadMutex::TC_ThreadMutex] pthread_mutexattr_init error", rc); &#125;&#125; 线程锁在析构函数中销毁： 123456789YR_ThreadMutex::~YR_ThreadMutex()&#123; int rc = 0; rc = pthread_mutex_destroy(&amp;_mutex); if(rc != 0) &#123; cerr &lt;&lt; "[YR_ThreadMutex::~YR_ThreadMutex] pthread_mutex_destroy error:" &lt;&lt; string(strerror(rc)) &lt;&lt; endl; &#125;&#125; 加锁123456789101112131415void YR_ThreadMutex::lock() const&#123; int rc = pthread_mutex_lock(&amp;_mutex); if(rc != 0) &#123; if(rc == EDEADLK) //如果当前线程已经拥有线程锁 &#123; throw YR_ThreadMutex_Exception("[YR_ThreadMutex::lock] pthread_mutex_lock dead lock error", rc); &#125; else &#123; throw YR_ThreadMutex_Exception("[YR_ThreadMutex::lock] pthread_mutex_lock error", rc); &#125; &#125;&#125; 解锁12345678void YR_ThreadMutex::unlock() const&#123; int rc = pthread_mutex_unlock(&amp;_mutex); if(rc != 0) &#123; throw YR_ThreadMutex_Exception("[YR_ThreadMutex::unlock] pthread_mutex_unlock error", rc); &#125;&#125; 尝试锁12345678910111213141516bool YR_ThreadMutex::tryLock() const&#123; int rc = pthread_mutex_trylock(&amp;_mutex); if(rc != 0 &amp;&amp; rc != EBUSY) //如果所占用则返回EBUSY &#123; if(rc == EDEADLK) //如果当前线程已经拥有线程锁 &#123; throw YR_ThreadMutex_Exception("[YR_ThreadMutex::tryLock] pthread_mutex_trylock dead lock error", rc); &#125; else &#123; throw YR_ThreadMutex_Exception("[YR_ThreadMutex::tryLock] pthread_mutex_trylock error", rc); &#125; &#125; return (rc == 0);&#125; 嵌套锁的封装嵌套锁的定义12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class YR_ThreadRecMutex&#123;public: /** * @brief 构造函数 */ YR_ThreadRecMutex(); /** * @brief 析够函数 */ virtual ~YR_ThreadRecMutex(); /** * @brief 锁, 调用pthread_mutex_lock. * * return : 返回pthread_mutex_lock的返回值 */ int lock() const; /** * @brief 解锁, pthread_mutex_unlock. * * return : 返回pthread_mutex_lock的返回值 */ int unlock() const; /** * @brief 尝试锁, 失败抛出异常. * * return : true, 成功锁; false 其他线程已经锁了 */ bool tryLock() const; /** * @brief 加锁后调用unlock是否会解锁, 给TC_Monitor使用的 * * @return bool */ bool willUnlock() const;protected: /** * @brief 友元类 */ friend class TC_ThreadCond; /** * @brief 计数 */ int count() const; /** * @brief 计数 */ void count(int c) const;private: /** 锁对象 */ mutable pthread_mutex_t _mutex; mutable int _count;&#125;; 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748YR_ThreadRecMutex::YR_ThreadRecMutex(): _count(0)&#123; int rc; pthread_mutexattr_t attr; //1. 线程属性的初始化 rc = pthread_mutexattr_init(&amp;attr); if(rc != 0) &#123; throw YR_ThreadMutex_Exception("[YR_ThreadRecMutex::YR_ThreadRecMutex] pthread_mutexattr_init error", rc); &#125; //2. 设置线程锁类型，PTHREAD_MUTEX_RECURSIVE为嵌套锁 rc = pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE); if(rc != 0) &#123; throw YR_ThreadMutex_Exception("[YR_ThreadRecMutex::YR_ThreadRecMutex] pthread_mutexattr_settype error", rc); &#125; //3. 初始化线程 rc = pthread_mutex_init(&amp;_mutex, &amp;attr); if(rc != 0) &#123; throw YR_ThreadMutex_Exception("[YR_ThreadRecMutex::YR_ThreadRecMutex] pthread_mutex_init error", rc); &#125; //4. 销毁线程属性对象 rc = pthread_mutexattr_destroy(&amp;attr); if(rc != 0) &#123; throw YR_ThreadMutex_Exception("[YR_ThreadRecMutex::YR_ThreadRecMutex] pthread_mutexattr_destroy error", rc); &#125;&#125;YR_ThreadRecMutex::~YR_ThreadRecMutex()&#123; while (_count) &#123; unlock(); &#125; int rc = 0; rc = pthread_mutex_destroy(&amp;_mutex); //销毁线程 if(rc != 0) &#123; cerr &lt;&lt; "[YR_ThreadRecMutex::~YR_ThreadRecMutex] pthread_mutex_destroy error:" &lt;&lt; string(strerror(rc)) &lt;&lt; endl; &#125;&#125; 加锁1234567891011121314151617int YR_ThreadRecMutex::lock() const&#123; int rc = pthread_mutex_lock(&amp;_mutex); if(rc != 0) &#123; //嵌套锁不用判断EDEADLK throw YR_ThreadMutex_Exception("[YR_ThreadRecMutex::lock] pthread_mutex_lock error",rc); &#125; //只是计数加1，pthread_mutex_unlock避免锁叠加 if(++_count &gt; 1) &#123; rc = pthread_mutex_unlock(&amp;_mutex); assert(rc == 0); &#125; return rc;&#125; 解锁1234567891011int YR_ThreadRecMutex::unlock() const&#123; //当计数只有1的时候进行解锁操作，大于1的情况只是计数减一即可 if(--_count == 0) &#123; int rc = 0; rc = pthread_mutex_unlock(&amp;_mutex); return rc; &#125; return 0;&#125; 尝试锁1234567891011121314151617181920bool YR_ThreadRecMutex::tryLock() const&#123; int rc = pthread_mutex_trylock(&amp;_mutex); if(rc != 0 ) &#123; if(rc != EBUSY) &#123; throw YR_ThreadMutex_Exception("[YR_ThreadRecMutex::tryLock] pthread_mutex_trylock error", rc); &#125; &#125; else if(++_count &gt; 1) &#123; rc = pthread_mutex_unlock(&amp;_mutex); if(rc != 0) &#123; throw YR_ThreadMutex_Exception("[YR_ThreadRecMutex::tryLock] pthread_mutex_unlock error", rc); &#125; &#125; return (rc == 0);&#125; 计数1234567891011int YR_ThreadRecMutex::count() const&#123; int c = _count; _count = 0; return c;&#125;void YR_ThreadRecMutex::count(int c) const&#123; _count = c;&#125; unlock()之后是否会解锁1234bool YR_ThreadRecMutex::willUnlock() const&#123; return _count == 1;&#125;]]></content>
      <tags>
        <tag>-C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[锁的封装]]></title>
    <url>%2FC-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F%E9%94%81%E7%9A%84%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[锁异常的封装，继承与自定义的异常类即可。 123456struct YR_Lock_Exception : public YR_Exception&#123; YR_Lock_Exception(const string&amp; buffer) : YR_Exception(buffer)&#123;&#125; YR_Lock_Exception(const string&amp; buffer, int err) : YR_Exception(buffer,err)&#123;&#125; ~YR_Lock_Exception() throw() &#123;&#125;&#125;; Linux下有各种锁机制，比如互斥锁、读写锁、自旋锁等，我们可以使用模板类实现对锁的封装。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061template &lt;class T&gt; //T为锁的类型class YR_LockT &#123;public: //构造函数，构造时加锁 YR_LockT(const T&amp; mutex) : _mutex(mutex) &#123; _mutex.lock(); _acquired = true; &#125; //析构函数，析构时解锁 ~YR_LockT() &#123; if(_acquired) _mutex.unlock(); &#125; //上锁，如果已经上锁，则抛出异常 void acquire() const &#123; if(_acquired) throw YR_Lock_Exception("thread has locked!"); _mutex.lock(); _acquired = true; &#125; //尝试上锁 bool tryAcquire() const &#123; _acquired = _mutex.tryLock(); return _acquired; &#125; //释放锁，如果没有上锁，抛出异常 void release() const &#123; if (!_acquired) &#123; throw YR_Lock_Exception("thread hasn't been locked!"); &#125; _mutex.unlock(); _acquired = false; &#125; //是否已经上锁 bool acquired() const &#123; return _acquired; &#125;protected: //构造函数，用于锁尝试操作 TC_LockT(const T&amp; mutex, bool) : _mutex(mutex) &#123; _acquired = _mutex.tryLock(); &#125; private: TC_LockT(const TC_LockT&amp;); TC_LockT&amp; operator=(const TC_LockT&amp;);protected: //锁对象 const T&amp; _mutex; //是否已经上锁 mutable bool _acquired;&#125;; 尝试上锁类： 12345678template &lt;typename T&gt;class YR_TryLockT : public YR_LockT&lt;T&gt;&#123;public: YR_TryLockT(const T&amp; mutex) : YR_LockT&lt;T&gt;(mutex, true) &#123; &#125;&#125;; 空锁，不做任何锁动作 12345678910111213141516171819202122class YR_EmptyMutex&#123;public: /** * @brief 写锁. * * @return int, 0 正确 */ int lock() const &#123;return 0;&#125; /** * @brief 解写锁 */ int unlock() const &#123;return 0;&#125; /** * @brief 尝试解锁. * * @return int, 0 正确 */ bool trylock() const &#123;return true;&#125;&#125;; 读写锁读锁模板类 123456789101112131415161718192021222324252627282930313233343536373839template &lt;typename T&gt;class YR_RW_RLockT&#123;public: /** * @brief 构造函数，构造时加锁 * * @param lock 锁对象 */ YR_RW_RLockT(T&amp; lock) : _rwLock(lock),_acquired(false) &#123; _rwLock.ReadLock(); _acquired = true; &#125; /** * @brief 析构时解锁 */ ~YR_RW_RLockT() &#123; if (_acquired) &#123; _rwLock.Unlock(); &#125; &#125;private: /** *锁对象 */ const T&amp; _rwLock; /** * 是否已经上锁 */ mutable bool _acquired; YR_RW_RLockT(const YR_RW_RLockT&amp;); YR_RW_RLockT&amp; operator=(const YR_RW_RLockT&amp;);&#125;; 读写锁写锁模板类： 123456789101112131415161718192021222324252627282930313233343536373839template &lt;typename T&gt;class YR_RW_WLockT&#123;public: /** * @brief 构造函数，构造时枷锁 * * @param lock 锁对象 */ YR_RW_WLockT(T&amp; lock) : _rwLock(lock),_acquired(false) &#123; _rwLock.WriteLock(); _acquired = true; &#125; /** * @brief 析构时解锁 */ ~YR_RW_WLockT() &#123; if(_acquired) &#123; _rwLock.Unlock(); &#125; &#125;private: /** *锁对象 */ const T&amp; _rwLock; /** * 是否已经上锁 */ mutable bool _acquired; YR_RW_WLockT(const YR_RW_WLockT&amp;); YR_RW_WLockT&amp; operator=(const YR_RW_WLockT&amp;);&#125;;&#125;;]]></content>
      <categories>
        <category>C++学习笔记</category>
      </categories>
      <tags>
        <tag>-C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异常的封装]]></title>
    <url>%2Funcategorized%2F%E5%BC%82%E5%B8%B8%E7%9A%84%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[异常的封装这里展示的是自定义异常类，继承与exception类。 12345678910111213141516171819202122#include &lt;stdexcept&gt;namespace youren &#123;////////////////////////////////////////////////class YR_Exception : public exception&#123;public: YR_Exception(const string&amp; buffer); YR_Exception(const string&amp; buffer, int err); ~YR_Exception() throw(); //错误信息 virtual const char* what() const throw(); //获取错误码 int getErrCode()&#123; return _code;&#125;private: void getBacktrace();private: string _buffer; int _code;&#125;;&#125; 其实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include "util/YR_Exception.h"#include &lt;execinfo.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;cerrno&gt;namespace youren&#123;YR_Exception::YR_Exception(const string &amp;buffer):_buffer(buffer), _code(0)&#123;&#125;YR_Exception::YR_Exception(const string &amp;buffer, int err)&#123; _buffer = buffer + " :" + strerror(err); _code = err;&#125;YR_Exception::~YR_Exception() throw()&#123;&#125;const char* YR_Exception::what() const throw()&#123; return _buffer.c_str();&#125;void YR_Exception::getBacktrace()&#123; void * array[64]; int nSize = backtrace(array, 64); char ** symbols = backtrace_symbols(array, nSize); for (int i = 0; i &lt; nSize; i++) &#123; _buffer += symbols[i]; _buffer += "\n"; &#125; free(symbols);&#125;&#125;]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++新特性之完美转发]]></title>
    <url>%2FC-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2FC-%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%2F</url>
    <content type="text"><![CDATA[在上一篇文章中，我们了解了什么是右值引用。 这篇文章则是了解C++11如何解决右值引用的一个实际问题：转发问题。 问题描述我们考虑一个例子：1234567891011121314void process_func(MySTring t)&#123;&#125;template &lt;class T&gt;void forward_func(T&amp;&amp; t)&#123; process_func(t);&#125;int main()&#123; //以上篇右值引用实现的MyString类为测试对象 forward_func(MyString(&quot;Hello&quot;)); return 0;&#125; 从代码来看，我们的forward_func函数传入的参数是一个右值引用，那么process_func的参数是不是也是右值引用呢？让我们看一下结果：1234ConstructCopy ConstructDestructDestruct 从结果中，我们可以看到，构造临时变量之后，便执行了拷贝构造函数，也就是说，传进process_func的不是右值，而是左值。这显然不是我们想要的结果，我们希望process_func传入的参数也是右值，该怎么做？我们将需要从一个函数中的一个或者多个实参连同其类型完整的转发给其他函数，称之为“完美转发”。 问题解决我们如果要做到完美转发，该怎么做呢？C++11给出了我们答案：引入一条新语言规则——引用折叠，并结合新的模板推导规则来完成完美转发。 引用折叠： 折叠前 折叠后 注释 A&amp; &amp; A&amp; 指向左值引用的左值引用折叠/崩塌为左值引用 A&amp; &amp;&amp; A&amp; 指向左值引用的右值引用折叠/崩塌为左值引用 A&amp;&amp; &amp; A&amp; 指向右值引用的左值引用折叠/崩塌为左值引用 A&amp;&amp; &amp;&amp; A&amp;&amp; 指向右值引用的右值引用折叠/崩塌为右值引用 从上表可以看出，当forward_func函数传入左值引用的时候，process_func的参数类型被折叠成左值引用，当forward_func函数传入右值引用的时候普，process_func的参数类型被折叠成右值引用。具体我们看下例：1234567891011121314151617181920212223void process_func(MyString&amp;&amp; t)&#123; cout&lt;&lt;&quot; rvalue ref&quot;&lt;&lt;endl;&#125;void process_func(MyString&amp; t)&#123; cout&lt;&lt;&quot;lvalue ref&quot;&lt;&lt;endl;&#125;template &lt;class T&gt;void forward_func(T&amp;&amp; t)&#123; //cout&lt;&lt;typeid(t).name()&lt;&lt;endl; //cout&lt;&lt;&quot;forward_value&quot;&lt;&lt;endl; process_func(forward&lt;T&gt;(t));&#125;int main()&#123; MyString str=&quot;World!&quot;; forward_func(str); //传入左值 forward_func(MyString(&quot;Hello&quot;)); //传入右值 return 0;&#125; 输出结果为：12345678ConstructMove ConstructDestructlvalue ref //MyString str=&quot;World!&quot;; forward_func(str);Constructrvalue ref //forward_func(MyString(&quot;Hello&quot;)); DestructDestruct]]></content>
      <categories>
        <category>C++学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>新特性</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[右值引用和移动构造函数]]></title>
    <url>%2FC-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[在了解右值引用之前，我们先复习什么左值、右值？什么是引用？ 左值、右值在C语言中，左值可以位于赋值语句的左侧，右值则不能。具体可以参考C值类别。 在C++中，每个表达式属于三种基本值之一：纯右值、亡值、左值。具体参考C++值类别。 在C++ Prime中，对左值和右值的区别做了一个简单的归纳： 当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。 左值有持久的状态，而右值要么是字面常量，要么是表达式求值过程中创建的临时对象。 引用引用是为一个已经存在的对象或者函数起一个别名。并不是将这个对象或者函数拷贝给引用。通常用&amp;定义引用。1234int a=123;int &amp;b=a; //它相当于给a起个别名为bb=456; //对引用的操作实在与之绑定的对象上进行的 引用的注意事项1234int &amp;c=1; //错误，引用类型的初始值必须是一个对象const int &amp;d=2; //正确，d为一个常量引用double &amp;e=a; //错误引用类型必须是int类型对象 当我们复习完上面所有知识之后，我们来了解什么是左值引用、右值引用？ 左值引用左值引用用于对已经存在的对象起一个别名。1234567891011121314#include &lt;iostream&gt;#icnldue &lt;string&gt;using namespace std;int main()&#123; string s=&quot;Hello&quot;; string&amp; r1s; const string&amp;r2=s; r1+=&quot; World!&quot;; //可以修改s r2+=&quot; World!&quot;; //不可以修改，r2为常量引用&#125; 也可以用于函数调用实现引用传递：123456789101112131415#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;void print(string&amp; str)&#123; str+=&quot; World!&quot;; cout&lt;&lt;str&lt;&lt;endl;&#125;int main()&#123; string str=&quot;Hello&quot;; print(str);&#125; 函数的返回值是左值引用时，函数调用表达式成为左值表达式。12345678910111213141516#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;char&amp; print_char(string&amp; str,size_t n)&#123; return str.at(n);&#125;int main()&#123; string str=&quot;Hello&quot;; print(str,0)=&apos;C&apos;; //函数调用是左值，可以被赋值 cout&lt;&lt;str&lt;&lt;endl; //输出Cello&#125;//在C++中，我们常见的左值返回还有赋值、下标、解引用、和前置递增/递减运算符，他们的返回值都是可以被修改的。 但是，对于一些要求转换的表达式、字面常量或是返回右值的表达式，左值引用就无能为力了。123string &amp; print(string &amp; str)&#123; return str+&quot; world!&quot;; //编译器报错，非常量引用的初始值必须为左值&#125; 我们知道str+&quot; world!&quot;为右值，我们将返回类型改为常量类型，就不会报错。123const string &amp; print(string &amp; str)&#123; return str+&quot; world!&quot;; &#125; 我们调用一下，试试看：12const string&amp; str2=print(str);cout&lt;&lt;str2&lt;&lt;endl; 此时，我们发现，输出的结果是乱码，调试发现，str2中根本没有值。这是因为函数调用产生一个临时对象，引用则将绑定这个临时对象，当函数调用完毕将临时对象销毁，引用将失效，所以返回乱码。 那么问题该怎么解决呢？就函数来看，毕竟返回引用类型要比返回值类型要高效，不用将临时对象的值拷贝给新的对象，而是“偷了”临时对象的值。 C++11为我们则引入了一种新的类型————右值引用。 右值引用新标准中用&amp;&amp;来定义右值引用，右值引用指向的是临时对象，因此延长了临时对象的生存期。这种“偷”走临时变量的行为，被称为“移动语义”。123456789101112#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string s1=&quot;Hello&quot;; string &amp;&amp; r=s1+s1; //s1+s1创建一个临时对象 r+=&quot; World!&quot;; cout&lt;&lt;r&lt;&lt;endl; //输出Hello Hello World!&#125; 在新标准中，我们还可以显式的将一个左值转换为对应的右值引用类型——move函数。123int i=10; int &amp;&amp; k=std::move(i);cout&lt;&lt;&amp;i&lt;&lt;&quot; &quot;&lt;&lt;&amp;k&lt;&lt;endl; //i和k的地址相同 既然我们可以延长临时对象的生存期，并减少对象的拷贝操作，我们在自己的类中如果也支持移动操作，那么也提高不少效率。 移动构造函数我们需要定义移动构造函数和移动赋值运算符。这两个成员类似于对应的拷贝操作，但它们是从给定的对象“窃取”资源而不是拷贝资源。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;string&gt;using namespace std;class MyString &#123;private: char* data; size_t len;public: MyString():data(nullptr),len(0)&#123;&#125; MyString(const char* p):data(new char[strlen(p)+1]),len(strlen(p))&#123; strcpy(data, p); cout &lt;&lt; &quot;Construct: &quot; &lt;&lt; ++cstr &lt;&lt; endl; &#125; //构造函数 MyString(const MyString&amp; str) :data(new char[strlen(str.data) + 1]), len(strlen(str.data)) &#123; strcpy(this-&gt;data, str.data); cout &lt;&lt; &quot;Copy Construct: &quot; &lt;&lt; ++cptr &lt;&lt; endl; &#125; //拷贝构造函数 ~MyString() &#123; delete data; cout &lt;&lt; &quot;Destruct: &quot; &lt;&lt; ++dstr &lt;&lt; endl; &#125;public: static int cstr; //构造函数调用次数 static int dstr; //析构函数调用次数 static int cptr; //拷贝构造函数调用次数 //static int mvtr; //移动构造函数调用次数&#125;;int MyString::cstr = 0;int MyString::dstr = 0;int MyString::cptr = 0;//int MyString::mvtr = 0;MyString GetStr() &#123; return MyString(&quot;Hello&quot;); &#125;int main()&#123; MyString str=MyStriung(&quot;Hello&quot;);&#125; 上面中的静态变量用来输出各种函数调用的次数。1234567891011121314在g++上的运行结果为：Construct: 1Copy Construct: 1Destruct: 1Copy Construct: 2Destruct: 2Destruct: 3在vs上的结果为：Construct: 1Copy Construct: 1Destruct: 1 vs将其优化了，用g++的-fno-elide-constructors参数就不会被优化。 可以看出，拷贝构造函数被调用了两次，一次是将构造的变量拷贝构造给临时值，用来做GetStr的返回值，另一次是由临时值构造出main函数中的变量str。 如果字符串的数据很大的话，那么花在拷贝上的时间比较大了，效率就会大大降低。如果我们将临时对象的值“偷”过来，那效率会有什么变化呢？123456789//我们在上述类中添加移动构造函数MyString(MyString &amp;&amp;str)&#123; len=str.len; this-&gt;data=str.data; str.len=0; str.data=nullptr;&#125;MyString GetStr()&#123; MyString str="Hello"; return str;&#125; 1234567运行结果为：Construct: 1Move Construct: 1Destruct: 1Move Construct: 2Destruct: 2Destruct: 3 从结果可以看到，没有执行拷贝构造函数，而是执行的是移动构造函数。虽然在此没有将临时值和mian函数中str的成员变量地址输出出来，但是他们的地址是相同的。这就省去了再申请内存和拷贝的时间，效率也提高了。]]></content>
      <categories>
        <category>C++学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>新特性</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Haskell初步]]></title>
    <url>%2FHaskell%E5%AD%A6%E4%B9%A0%2FHaskell%E5%88%9D%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[函数的定义和调用123456789//函数名 参数1 参数2 ... = 函数体doubleMe x=x+xdoubleUs x y= x*2 + y*2//可在其他函数中调用你编写的函数doubleUs x y = doubleMe x + doubleMe y//很符合我们数学中公式的组合f(x)=g(x)+h(x)+... Haskell中函数没有顺序，无论先声明doubleMe还是doubleUs都是一样的。 List123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//定义，所有元素必须相同类型let lostNumber=[1,2,3,4]//两个list合并let lostNumber2=[5,6,7,8]lostNumber ++ lostNumber2//索引 !!lostNumber !!2 //2为下标//比较大小lostNumber &gt; lostNumber2 //返回False[2.1,3.1,4.1] &gt; [2,3,4] //返回TruelostNumber == lostNumber2 //返回False//常用搭配函数：head lostNumber //返回list的第一个元素last lostNumber //返回list的最后一个元素tail lostNumber //返回除去第一个元素之后的部分init lostNumber //返回除去最后一个元素之前的部分length lostNumber //返回list的长度null lostNumber //检查list是否为空，空则返回Truereverse lostNumber //将list反转take 3 lostNumber //返回list的前几个元素，3指定返回前3个元素drop 3 lostNumber //删除list前几个元素maximum lostNumber //返回list中最大的元素minimum lostNumber //返回list中最小的元素sum lostNumber //返回list所有元素之和profuct lostNumber //返回list中所有元素之积4 `elem` lostNumber //判断一个元素是否在一个list中[1..20] //定义一个从1到20的list[20,19..1] //[20..1]是不可以的//也可以是字符[&apos;a&apos;..&apos;z&apos;] //返回&quot;abcdefghijklmnopqrstuvwxyz&quot;[&apos;A&apos;..&apos;z&apos;] //返回&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz&quot;//设置步长[2,4..20] //返回[2,4,6,8,10,12,14,16,18,20]//不标明上限take 24 [13,26..] //用多少取多少[13.26..] //不停输出repeat接受一个值作为参数，返回一个仅包含该值的无限Listcycle则是接受一个list，并无限输出replicate 3 10 //得到包含3个元素相同的list 我们也可以表达数学中的集合：1S=&#123;2*x | x\in N,x\leq10&#125; 12[x*2 | x&lt;-[1..10]] //返回[2,4,6,8,10,12,14,16,18,20][x*2 | x&lt;-[1..10], x*2 &gt;= 12] //返回[12,14,16,18,20] Tuple123456fst (8,11) //返回一个序对的首项snd (8,11) //返回一个序对的尾项//不能用于三元组或四元组以上zip [1,2,3,4] [7,8,9] //zip用来生成一组序对的list//返回[(1,7),(2,8),(3,9)] 解决一个问题：如何取得所有三边长度皆为整数且小于等于10，周长为24的直角三角形？1let rightTriangles = [ (a,b,c) | c&lt;-[1..10], b&lt;-[1..c], a&lt;-[1..b], a^2 + b^2 == c^2,a+b+c==24]]]></content>
      <categories>
        <category>Haskell学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>Haskell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++新特性之Variadic Template]]></title>
    <url>%2FC-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2FC-%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BVariadic-Template%EF%BC%88%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF%EF%BC%89%2F</url>
    <content type="text"><![CDATA[可变参数模板的定义可变参数模板是至少有一个参数宝的模板，参数包则是可以接受零个或者更多模板实参的模板形参，其格式如下：123template &lt;class ...T&gt; class classname;template &lt;class ...T&gt; void func(T ...args); 其中T为模板参数包，args为函数参数包。 可变参数模板可以用任意数量的模板参数实例化：1234567template &lt;class... T&gt; class Myclass&#123;&#125;;Myclass&lt;&gt; t0; //T 不包含实参Myclass&lt;int&gt; t1; //T 包含一个实参，类型为intMyclass&lt;int,float&gt; t2; //T 包含两个实参，类型为int和float//模板参数包必须是模板参数列表中的最后一个形参。template &lt;typename... T,typename U&gt; struct Invalid; //错误 可变参数函数模板可以用任意数量的函数实参调用：12345678910template &lt;class... T&gt; void func(T... args);func(); //args不包含实参func(1); //包含一个实参，类型为intfunc(1,2.1); //包含两个实参，类型为int和double//与类模板不同，函数模板参数包不必是模板参数列表中的最后一个，它可以在列表早于所有能从函数实参推导的参数出现template &lt;class... T,class U&gt;void valid(U,T...); //正确valid(1.0,2,3,4); //推导U为double，T为&#123;int，int，int&#125; 包展开包展开的场所不同，产生的逗号分隔列表种类不同： 函数实参列表 12345func(&amp;args...); //展开成func(&amp;E1,&amp;E2,&amp;E3)func(++args...,n); //展开成func(++E1,++E2,++E3,n)func(n,++args); //展开成func(n,++E1,++E2,++E3)func(const_cast&lt;const Args*&gt;(&amp;args)...); // func(const_cast&lt;const E1*&gt;(&amp;X1), const_cast&lt;const E2*&gt;(&amp;X2), const_cast&lt;const E3*&gt;(&amp;X3))func(h(args...) + args...); // 展开成 func(h(E1,E2,E3) + E1, h(E1,E2,E3) + E2, h(E1,E2,E3) + E3) 有括号初始化器 12Class c1(&amp;args...); // 调用 Class::Class(&amp;E1, &amp;E2, &amp;E3)Class c2 = Class(n, ++args...); // 调用 Class::Class(n, ++E1, ++E2, ++E3); 花括号环绕的初始化器 12345template &lt;class... T&gt; void func(T... args)&#123; const int size=sizeof...(args); int res[size]=&#123;args...&#125;;&#125; 模板实参列表 1234567//包展开可以用于模板形参列表的任何位置，前提是模板拥有匹配展开的形参。template &lt;class A,class B,class... C&gt; void func(A arg1,B arg2,C... arg3)&#123; container&lt;A,B,C...&gt; t1; // 展开成 container&lt;A,B,E1,E2,E3&gt; container&lt;C...,A,B&gt; t2; // 展开成 container&lt;E1,E2,E3,A,B&gt; container&lt;A,C...,B&gt; t3; // 展开成 container&lt;A,E1,E2,E3,B&gt; &#125; 函数形参列表 123template&lt;typename ...Ts&gt; void f(Ts...) &#123;&#125;f(&apos;a&apos;, 1); // Ts... 展开成 void f(char, int)f(0.1); // Ts... 展开成 void f(double) 模板形参列表 1234template &lt;class ...T&gt; class Myclass&#123; template&lt;T... Values&gt; // 展开成无类型模板参数列表，例如 &lt;int, char, int(&amp;)[5]&gt;&#125;; Lambda捕获 12345template &lt;class ...T&gt;void func(T... args)&#123; auto g=[&amp;,args...]&#123;return h(args...);&#125; g();&#125; sizeof…运算符 基类指定符和成员初始化列表12345template&lt;class... Mixins&gt;class X : public Mixins... &#123; public: X(const Mixins&amp;... mixins) : Mixins(mixins)... &#123; &#125;&#125;; 实例1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;void print()&#123; cout&lt;&lt;endl;&#125;template &lt;class T&gt; void print(const T&amp; t)&#123; cout&lt;&lt; t &lt;&lt;endl;&#125;template &lt;class First,class... Rest&gt;void print(const First&amp; first,const Rest&amp;... rest)&#123; cout&lt;&lt;first&lt;&lt;&quot;,&quot;; print(rest);&#125;int main()&#123; print(); print(1); print(10,20); print(100,200,300); print(&quot;first&quot;,2,&quot;third&quot;,3.14159);&#125; 实现C语言中的printf函数：12345678910111213141516171819202122232425#include &lt;iostream&gt; void tprintf(const char* format) // 基函数&#123; std::cout &lt;&lt; format;&#125; template&lt;typename T, typename... Targs&gt;void tprintf(const char* format, T value, Targs... Fargs) // 递归变参数函数&#123; for ( ; *format != &apos;\0&apos;; format++ ) &#123; if ( *format == &apos;%&apos; ) &#123; std::cout &lt;&lt; value; tprintf(format+1, Fargs...); // 递归调用 return; &#125; std::cout &lt;&lt; *format; &#125;&#125; int main()&#123; tprintf(&quot;% world% %\n&quot;,&quot;Hello&quot;,&apos;!&apos;,123); return 0;&#125;]]></content>
      <categories>
        <category>C++学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>新特性</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++新特性之Type Alias、Template Alias、noexcept、override、final]]></title>
    <url>%2FC-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2FC-%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BType-Alias%E3%80%81Template-Alias%E3%80%81noexcept%E3%80%81override%E3%80%81final%2F</url>
    <content type="text"><![CDATA[1. Type Alias（类型别名）and Template Alias（模板别名）在C++11中，我们不仅可以为类型定义别名，还可以对模板进行定义别名。 别名声明的语法12341. using identifier = type-id //identifier为引入的类型名，type-id为抽象声明器或者任何合法的type-id2. template &lt;template-parameter-list&gt; using identifier =type type-id 类型别名声明和typedef的声明没有差别。 举例1234567891011121314151617181920212223242526272829303132333435363738#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;type_traits&gt;class Base&#123; &#125;;//类型别名using A = Base;//等同于 typedef Base A;A *a = new A(4);using func=void (*)(int,int);//等同于typedef void (*func)(int,int);void example(int,int)&#123;&#125;func b=example;//别名模板template&lt;class T&gt;using point = T*;point&lt;const char&gt; str="I Love C++";//point&lt;const char&gt;为指向const char的指针//用于隐藏模板形参的别名模板template&lt;class CharT&gt;using mystring = std::basic_string&lt;CharT, std::char_traits&lt;CharT&gt;&gt;;mystring&lt;char&gt; str;能引入成员typedef名的别名模板template&lt;class T&gt;struct D&#123; using value_type=T;&#125;;template&lt;class D&gt;void g(const D&amp; c)&#123; typename D::value_type n; &#125;const D&lt;int&gt; d;g(d); //通过typeid(n).name()可以获取n的类型为int 2. noexcept在C++11中，我们可以通过noexcept来指定某个函数不会抛出异常。 在C++11之前，通常使用如下方式实现不抛出异常：12void func() throw();//throw()的()中通常用来放置函数可以抛出异常的类型，如果为空，则不抛出任何异常。 C++11将throw()用noexcept替换，如下：1void func() noexcept; 事实上，noexcept指定符的用法不仅仅是替代throw()。 语法12noexcept(expression)//如果没有expression,expression默认为true,即不抛出任何异常。 举例12345678910111213141516171819202122指向不抛出函数的指针可赋值给指向潜在抛出函数的指针，反之不可。void f(); //潜在抛出void (*fn)() noexcept =ft; //错误//若虚函数为不抛出，则所有声明，包括整个覆写的定义都必须是不抛出，除非覆写定义被删除。struct B&#123; virtual void f() noexcept; virtual void g(); virtual void h noexcept = delete;&#125;;struct D:B&#123; void f(); //错误，D::f为潜在抛出，B::f为不抛出 void g() noexcept; //正确 void h() = delete; //正确&#125;;//不抛出函数允许调用潜在抛出函数void func1(); //潜在抛出void func2() noexcept&#123; f(); //合法 throw 10; //合法，最终调用std::abort()终止程序&#125; 3. override我们在学习C++虚函数的时候，要求派生类的虚函数要覆盖掉基类中对应的虚函数（函数参数、返回类型必须相同）,。比如：123456789101112131415class Base&#123; public: Base()&#123;&#125; ~Base()&#123;&#125; virtual void print(const char *str);&#125;;class A::public Base&#123; public: A()&#123;&#125; ~A()&#123;&#125; void print(const char* str);&#125;; 但是上面的代码有一个缺点：如果派生类中想要重新定义的函数却不小心写错了，基类的函数没有被覆盖，但是编译器没有报错，使得调试的时候很难发现。 在C++11中提供的override关键字可以解决这一问题，它标记派生类中的虚函数，如果基类中的虚函数没有被覆盖，编译器则报错。 4. final假若一个函数被指定为final，则说明该函数不可被覆盖。 12345678910111213141516class A::public Base&#123; public: A()&#123;&#125; ~A()&#123;&#125; void print(const char* str) final;&#125;;class B:public A&#123; public: A()&#123;&#125; ~A()&#123;&#125; void print(const char* str); //编译器报错，print无法被重写&#125;;]]></content>
      <categories>
        <category>C++学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>新特性</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++新特性之Lambda表达式]]></title>
    <url>%2FC-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2FC-%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是lambda表达式？一个lambda表达式表示以一个可以调用的代码单元。或者理解为一个匿名的内联函数。与任何函数类似，一个lambda具有返回类型、一个参数列表和一个函数体。与函数不同，lambda可能定义在函数内部。 为什么要有lambda表达式？我们知道，在STL所提供的算法中，往往有两个版本。其中一个版本表现最直观的的某种运算，第二个版本则表现出最泛化的演算流程，允许用户“以template参数来指定所要采取的策略”。以sort()为例，第一版本是默认从小到大排序（operator&lt;），第二个版本则是允许你指定某种“操作”，使得排序后的两个相邻元素都能令该操作结果为true。事实上，第二版本允许我们想算法传递任何类别的可调用对象。这个“可调用对象”为第二个版本的第三个参数，被称为“谓词”。 可调用对象C++的可调用对象有5类： 函数 函数指针 重载了函数调用运算符的类 bind创建的对象 lambda表达式 而在标准算法中将“谓词”分为两类：一元谓词（只接受一个参数）、二元谓词（接受两个参数）。 但是我们在使用一个算法中，要使用更多的参数，超出了谓词的限制，或者调用的函数有时候只用一次，重用性太差，那我们就要解决这些问题。 C++11就引入了lambda表达式来解决这些问题。 lambda表达式怎么用？语法1231. [captures](params) -&gt; return type &#123; function body &#125;2. [captures](params) &#123; function body &#125;3. [captures] &#123; function body &#125; captures为捕获列表，为lambda中定义的局部变量的列表。 params表示参数列表。 return type表示返回类型，为尾随返回类型。 function body为函数体。 上面三种用法中，我们可以看出来，参数列表和返回类型可以忽略，但是必须包含捕获列表和函数体。 lambda 捕获123456[]：lambda不能使用所在函数的变量。[=]：值捕获，lambda表达式可以以拷贝的方式访问函数中的变量的值。[&amp;]：引用捕获，lambda表达式中以引用的方式访问函数中的变量的值。[=,&amp;]：值捕获和引用捕获混合使用。[var]：指定捕获或拷贝。[this]：捕获this指针。 举例12345678910111213141516171819202122232425262728293031#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;int main()&#123; std::vector&lt;int&gt; a=&#123;1,2,3,4,5&#125;; std::for_each(a.begin(),a.end(),[](int i)&#123; std::cout&lt;&lt;i&lt;&lt;&quot; &quot;&#125;); //C++14 lambda可以拥有自身的默认参数 auto func=[](inr i=6)&#123;return i+4;&#125;; std::cout&lt;&lt;func()&lt;&lt;std::endl; //值捕获和引用捕获 int b=1024,c=2048; auto func2=[b,&amp;c]&#123; std::cout&lt;&lt;i&lt;&lt;std::endl; std::cout&lt;&lt;&amp;j&lt;&lt;std::endl; &#125;; func2(); //与stl算法结合，找出a中大于3的一个元素 int x=3; auto d=find_if(a.begin(),a.end(), [x](int num) &#123;return num&gt;x;&#125;); return 0;&#125;]]></content>
      <categories>
        <category>C++学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>新特性</tag>
        <tag>编程</tag>
      </tags>
  </entry>
</search>
