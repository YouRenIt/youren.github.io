<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2018%2F09%2F15%2Ftest%2F</url>
    <content type="text"><![CDATA[testtitle: testdate: 2018-09-15 22:54:56tags:categories: copyright:]]></content>
  </entry>
  <entry>
    <title><![CDATA[C++新特性之Lambda表达式]]></title>
    <url>%2F2018%2F09%2F14%2FC-%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是lambda表达式？一个lambda表达式表示以一个可以调用的代码单元。或者理解为一个匿名的内联函数。与任何函数类似，一个lambda具有返回类型、一个参数列表和一个函数体。与函数不同，lambda可能定义在函数内部。 为什么要有lambda表达式？我们知道，在STL所提供的算法中，往往有两个版本。其中一个版本表现最直观的的某种运算，第二个版本则表现出最泛化的演算流程，允许用户“以template参数来指定所要采取的策略”。以sort()为例，第一版本是默认从小到大排序（operator&lt;），第二个版本则是允许你指定某种“操作”，使得排序后的两个相邻元素都能令该操作结果为true。事实上，第二版本允许我们想算法传递任何类别的可调用对象。这个“可调用对象”为第二个版本的第三个参数，被称为“谓词”。 可调用对象C++的可调用对象有5类： 函数 函数指针 重载了函数调用运算符的类 bind创建的对象 lambda表达式 而在标准算法中将“谓词”分为两类：一元谓词（只接受一个参数）、二元谓词（接受两个参数）。 但是我们在使用一个算法中，要使用更多的参数，超出了谓词的限制，或者调用的函数有时候只用一次，重用性太差，那我们就要解决这些问题。 C++11就引入了lambda表达式来解决这些问题。 lambda表达式怎么用？语法1231. [captures](params) -&gt; return type &#123; function body &#125;2. [captures](params) &#123; function body &#125;3. [captures] &#123; function body &#125; captures为捕获列表，为lambda中定义的局部变量的列表。 params表示参数列表。 return type表示返回类型，为尾随返回类型。 function body为函数体。 上面三种用法中，我们可以看出来，参数列表和返回类型可以忽略，但是必须包含捕获列表和函数体。 lambda 捕获123456[]：lambda不能使用所在函数的变量。[=]：值捕获，lambda表达式可以以拷贝的方式访问函数中的变量的值。[&amp;]：引用捕获，lambda表达式中以引用的方式访问函数中的变量的值。[=,&amp;]：值捕获和引用捕获混合使用。[var]：指定捕获或拷贝。[this]：捕获this指针。 举例12345678910111213141516171819202122232425262728293031#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;int main()&#123; std::vector&lt;int&gt; a=&#123;1,2,3,4,5&#125;; std::for_each(a.begin(),a.end(),[](int i)&#123; std::cout&lt;&lt;i&lt;&lt;&quot; &quot;&#125;); //C++14 lambda可以拥有自身的默认参数 auto func=[](inr i=6)&#123;return i+4;&#125;; std::cout&lt;&lt;func()&lt;&lt;std::endl; //值捕获和引用捕获 int b=1024,c=2048; auto func2=[b,&amp;c]&#123; std::cout&lt;&lt;i&lt;&lt;std::endl; std::cout&lt;&lt;&amp;j&lt;&lt;std::endl; &#125;; func2(); //与stl算法结合，找出a中大于3的一个元素 int x=3; auto d=find_if(a.begin(),a.end(), [x](int num) &#123;return num&gt;x;&#125;); return 0;&#125;]]></content>
      <categories>
        <category>C++学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>新特性</tag>
        <tag>编程</tag>
      </tags>
  </entry>
</search>
