<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>C++新特性之Type Alias、Template Alias、noexcept、override、final</title>
      <link href="/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BType-Alias%E3%80%81Template-Alias%E3%80%81noexcept%E3%80%81override%E3%80%81final/"/>
      <url>/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BType-Alias%E3%80%81Template-Alias%E3%80%81noexcept%E3%80%81override%E3%80%81final/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Type-Alias（类型别名）and-Template-Alias（模板别名）"><a href="#1-Type-Alias（类型别名）and-Template-Alias（模板别名）" class="headerlink" title="1. Type Alias（类型别名）and Template Alias（模板别名）"></a>1. Type Alias（类型别名）and Template Alias（模板别名）</h3><p>在<code>C++11</code>中，我们不仅可以为类型定义别名，还可以对模板进行定义别名。</p><h4 id="别名声明的语法"><a href="#别名声明的语法" class="headerlink" title="别名声明的语法"></a>别名声明的语法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">using</span> identifier = type-id       <span class="comment">//identifier为引入的类型名，type-id为抽象声明器或者任何合法的type-id</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> <span class="keyword">template</span> &lt;<span class="keyword">template</span>-parameter-<span class="built_in">list</span>&gt;</span><br><span class="line">   <span class="keyword">using</span> identifier =type type-id</span><br></pre></td></tr></table></figure><p>类型别名声明和<code>typedef</code>的声明没有差别。</p><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">using</span> A = Base;</span><br><span class="line"><span class="comment">//等同于 typedef Base A;</span></span><br><span class="line">A *a = <span class="keyword">new</span> A(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> func=<span class="keyword">void</span> (*)(<span class="keyword">int</span>,<span class="keyword">int</span>);</span><br><span class="line"><span class="comment">//等同于typedef void (*func)(int,int);</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">example</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>&#123;&#125;</span><br><span class="line">func b=example;</span><br><span class="line"></span><br><span class="line"><span class="comment">//别名模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">using</span> <span class="title">point</span> = <span class="title">T</span>*;</span></span><br><span class="line">point&lt;<span class="keyword">const</span> <span class="keyword">char</span>&gt; str=<span class="string">"I Love C++"</span>;</span><br><span class="line"><span class="comment">//point&lt;const char&gt;为指向const char的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用于隐藏模板形参的别名模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">CharT</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">using</span> <span class="title">mystring</span> = <span class="title">std</span>:</span>:basic_string&lt;CharT, <span class="built_in">std</span>::char_traits&lt;CharT&gt;&gt;;</span><br><span class="line">mystring&lt;<span class="keyword">char</span>&gt; str;</span><br><span class="line"></span><br><span class="line">能引入成员<span class="keyword">typedef</span>名的别名模板</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">D</span>&#123;</span></span><br><span class="line">    <span class="keyword">using</span> value_type=T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">D</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">g</span>(<span class="title">const</span> <span class="title">D</span>&amp; <span class="title">c</span>)&#123;</span> <span class="keyword">typename</span> D::value_type n; &#125;</span><br><span class="line"><span class="keyword">const</span> D&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">g(d); </span><br><span class="line"><span class="comment">//通过typeid(n).name()可以获取n的类型为int</span></span><br></pre></td></tr></table></figure><h3 id="2-noexcept"><a href="#2-noexcept" class="headerlink" title="2. noexcept"></a>2. noexcept</h3><p>在<code>C++11</code>中，我们可以通过<code>noexcept</code>来指定某个函数不会抛出异常。</p><p>在<code>C++11</code>之前，通常使用如下方式实现不抛出异常：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void func() throw();</span><br><span class="line">//throw()的()中通常用来放置函数可以抛出异常的类型，如果为空，则不抛出任何异常。</span><br></pre></td></tr></table></figure></p><p><code>C++11</code>将<code>throw()</code>用<code>noexcept</code>替换，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void func() noexcept;</span><br></pre></td></tr></table></figure></p><p>事实上，<code>noexcept</code>指定符的用法不仅仅是替代<code>throw()</code>。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">noexcept(expression)</span><br><span class="line">//如果没有expression,expression默认为true,即不抛出任何异常。</span><br></pre></td></tr></table></figure><h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">指向不抛出函数的指针可赋值给指向潜在抛出函数的指针，反之不可。</span><br><span class="line">void f();   //潜在抛出</span><br><span class="line">void (*fn)() noexcept =ft;  //错误</span><br><span class="line"></span><br><span class="line">//若虚函数为不抛出，则所有声明，包括整个覆写的定义都必须是不抛出，除非覆写定义被删除。</span><br><span class="line">struct B&#123;</span><br><span class="line">    virtual void f() noexcept;</span><br><span class="line">    virtual void g();</span><br><span class="line">    virtual void h noexcept = delete;</span><br><span class="line">&#125;;</span><br><span class="line">struct D:B&#123;</span><br><span class="line">    void f();   //错误，D::f为潜在抛出，B::f为不抛出</span><br><span class="line">    void g() noexcept;  //正确</span><br><span class="line">    void h() = delete;  //正确</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//不抛出函数允许调用潜在抛出函数</span><br><span class="line">void func1();   //潜在抛出</span><br><span class="line">void func2() noexcept&#123;</span><br><span class="line">    f();    //合法</span><br><span class="line">    throw 10;   //合法，最终调用std::abort()终止程序</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-override"><a href="#3-override" class="headerlink" title="3. override"></a>3. override</h3><p>我们在学习C++虚函数的时候，要求派生类的虚函数要覆盖掉基类中对应的虚函数（函数参数、返回类型必须相同）,。比如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Base()&#123;&#125;</span><br><span class="line">        ~Base()&#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span>:<span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        A()&#123;&#125;</span><br><span class="line">        ~A()&#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>但是上面的代码有一个缺点：如果派生类中想要重新定义的函数却不小心写错了，基类的函数没有被覆盖，但是编译器没有报错，使得调试的时候很难发现。</p><p>在<code>C++11</code>中提供的<code>override</code>关键字可以解决这一问题，它标记派生类中的虚函数，如果基类中的虚函数没有被覆盖，编译器则报错。</p><h3 id="4-final"><a href="#4-final" class="headerlink" title="4. final"></a>4. final</h3><p>假若一个函数被指定为<code>final</code>，则说明该函数不可被覆盖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class A::public Base&#123;</span><br><span class="line">    public:</span><br><span class="line">        A()&#123;&#125;</span><br><span class="line">        ~A()&#123;&#125;</span><br><span class="line">        </span><br><span class="line">        void print(const char* str) final;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B:public A&#123;</span><br><span class="line">  public:</span><br><span class="line">    A()&#123;&#125;</span><br><span class="line">    ~A()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    void print(const char* str);</span><br><span class="line">    //编译器报错，print无法被重写</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 新特性 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++新特性之Lambda表达式</title>
      <link href="/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是lambda表达式？"><a href="#什么是lambda表达式？" class="headerlink" title="什么是lambda表达式？"></a>什么是lambda表达式？</h3><p>一个<code>lambda</code>表达式表示以一个可以调用的代码单元。或者理解为一个匿名的内联函数。与任何函数类似，一个<code>lambda</code>具有返回类型、一个参数列表和一个函数体。与函数不同，<code>lambda</code>可能定义在函数内部。</p><h3 id="为什么要有lambda表达式？"><a href="#为什么要有lambda表达式？" class="headerlink" title="为什么要有lambda表达式？"></a>为什么要有lambda表达式？</h3><p>我们知道，在<code>STL</code>所提供的算法中，往往有两个版本。其中一个版本表现最直观的的某种运算，第二个版本则表现出最泛化的演算流程，允许用户“以<code>template</code>参数来指定所要采取的策略”。以<code>sort()</code>为例，第一版本是默认<strong>从小到大排序（operator&lt;）</strong>，第二个版本则是允许你指定某种“操作”，使得排序后的两个相邻元素都能令该操作结果为<code>true</code>。事实上，第二版本允许我们想算法传递任何类别的<strong>可调用对象</strong>。这个“可调用对象”为第二个版本的第三个参数，被称为“<strong>谓词</strong>”。</p><h4 id="可调用对象"><a href="#可调用对象" class="headerlink" title="可调用对象"></a>可调用对象</h4><p>C++的可调用对象有5类：</p><ol><li>函数</li><li>函数指针</li><li>重载了函数调用运算符的类</li><li>bind创建的对象</li><li><strong>lambda表达式</strong></li></ol><p>而在标准算法中将“谓词”分为两类：<strong>一元谓词（只接受一个参数）</strong>、<strong>二元谓词（接受两个参数）</strong>。</p><p>但是我们在使用一个算法中，要使用更多的参数，超出了谓词的限制，或者调用的函数有时候只用一次，重用性太差，那我们就要解决这些问题。</p><p><code>C++11</code>就引入了<code>lambda表达式</code>来解决这些问题。</p><h3 id="lambda表达式怎么用？"><a href="#lambda表达式怎么用？" class="headerlink" title="lambda表达式怎么用？"></a>lambda表达式怎么用？</h3><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. [captures](params) -&gt; return type &#123; function body &#125;</span><br><span class="line">2. [captures](params) &#123; function body &#125;</span><br><span class="line">3. [captures] &#123; function body &#125;</span><br></pre></td></tr></table></figure><p><code>captures</code>为捕获列表，为lambda中定义的局部变量的列表。</p><p><code>params</code>表示参数列表。</p><p><code>return type</code>表示返回类型，为尾随返回类型。</p><p><code>function body</code>为函数体。</p><p>上面三种用法中，我们可以看出来，<strong>参数列表</strong>和<strong>返回类型</strong>可以忽略，但是必须包含<strong>捕获列表</strong>和<strong>函数体</strong>。</p><h4 id="lambda-捕获"><a href="#lambda-捕获" class="headerlink" title="lambda 捕获"></a>lambda 捕获</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[]：lambda不能使用所在函数的变量。</span><br><span class="line">[=]：值捕获，lambda表达式可以以拷贝的方式访问函数中的变量的值。</span><br><span class="line">[&amp;]：引用捕获，lambda表达式中以引用的方式访问函数中的变量的值。</span><br><span class="line">[=,&amp;]：值捕获和引用捕获混合使用。</span><br><span class="line">[var]：指定捕获或拷贝。</span><br><span class="line">[this]：捕获this指针。</span><br></pre></td></tr></table></figure><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;int&gt; a=&#123;1,2,3,4,5&#125;;</span><br><span class="line">    std::for_each(a.begin(),a.end(),[](int i)&#123; std::cout&lt;&lt;i&lt;&lt;&quot; &quot;&#125;);</span><br><span class="line">    </span><br><span class="line">    //C++14 lambda可以拥有自身的默认参数</span><br><span class="line">    auto func=[](inr i=6)&#123;return i+4;&#125;;</span><br><span class="line">    std::cout&lt;&lt;func()&lt;&lt;std::endl;</span><br><span class="line">    </span><br><span class="line">    //值捕获和引用捕获</span><br><span class="line">    int b=1024,c=2048;</span><br><span class="line">    auto func2=[b,&amp;c]&#123;</span><br><span class="line">        std::cout&lt;&lt;i&lt;&lt;std::endl;</span><br><span class="line">        std::cout&lt;&lt;&amp;j&lt;&lt;std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    func2();</span><br><span class="line">    </span><br><span class="line">    //与stl算法结合，找出a中大于3的一个元素</span><br><span class="line">    int x=3;</span><br><span class="line">    auto d=find_if(a.begin(),a.end(),</span><br><span class="line">        [x](int num)</span><br><span class="line">            &#123;return num&gt;x;&#125;);</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 新特性 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
