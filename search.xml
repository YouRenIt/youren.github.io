<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C++新特性之Variadic Template]]></title>
    <url>%2FC-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2FC-%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BVariadic-Template%2F</url>
    <content type="text"><![CDATA[可变参数模板的定义可变参数模板是至少有一个参数宝的模板，参数包则是可以接受零个或者更多模板实参的模板形参，其格式如下：123template &lt;class ...T&gt; class classname;template &lt;class ...T&gt; void func(T ...args); 其中T为模板参数包，args为函数参数包。 可变参数模板可以用任意数量的模板参数实例化：1234567template &lt;class... T&gt; class Myclass&#123;&#125;;Myclass&lt;&gt; t0; //T 不包含实参Myclass&lt;int&gt; t1; //T 包含一个实参，类型为intMyclass&lt;int,float&gt; t2; //T 包含两个实参，类型为int和float//模板参数包必须是模板参数列表中的最后一个形参。template &lt;typename... T,typename U&gt; struct Invalid; //错误 可变参数函数模板可以用任意数量的函数实参调用：12345678910template &lt;class... T&gt; void func(T... args);func(); //args不包含实参func(1); //包含一个实参，类型为intfunc(1,2.1); //包含两个实参，类型为int和double//与类模板不同，函数模板参数包不必是模板参数列表中的最后一个，它可以在列表早于所有能从函数实参推导的参数出现template &lt;class... T,class U&gt;void valid(U,T...); //正确valid(1.0,2,3,4); //推导U为double，T为&#123;int，int，int&#125; 包展开包展开的场所不同，产生的逗号分隔列表种类不同： 函数实参列表 12345func(&amp;args...); //展开成func(&amp;E1,&amp;E2,&amp;E3)func(++args...,n); //展开成func(++E1,++E2,++E3,n)func(n,++args); //展开成func(n,++E1,++E2,++E3)func(const_cast&lt;const Args*&gt;(&amp;args)...); // func(const_cast&lt;const E1*&gt;(&amp;X1), const_cast&lt;const E2*&gt;(&amp;X2), const_cast&lt;const E3*&gt;(&amp;X3))func(h(args...) + args...); // 展开成 func(h(E1,E2,E3) + E1, h(E1,E2,E3) + E2, h(E1,E2,E3) + E3) 有括号初始化器 12Class c1(&amp;args...); // 调用 Class::Class(&amp;E1, &amp;E2, &amp;E3)Class c2 = Class(n, ++args...); // 调用 Class::Class(n, ++E1, ++E2, ++E3); 花括号环绕的初始化器 12345template &lt;class... T&gt; void func(T... args)&#123; const int size=sizeof...(args); int res[size]=&#123;args...&#125;;&#125; 模板实参列表 1234567//包展开可以用于模板形参列表的任何位置，前提是模板拥有匹配展开的形参。template &lt;class A,class B,class... C&gt; void func(A arg1,B arg2,C... arg3)&#123; container&lt;A,B,C...&gt; t1; // 展开成 container&lt;A,B,E1,E2,E3&gt; container&lt;C...,A,B&gt; t2; // 展开成 container&lt;E1,E2,E3,A,B&gt; container&lt;A,C...,B&gt; t3; // 展开成 container&lt;A,E1,E2,E3,B&gt; &#125; 函数形参列表 123template&lt;typename ...Ts&gt; void f(Ts...) &#123;&#125;f(&apos;a&apos;, 1); // Ts... 展开成 void f(char, int)f(0.1); // Ts... 展开成 void f(double) 模板形参列表 1234template &lt;class ...T&gt; class Myclass&#123; template&lt;T... Values&gt; // 展开成无类型模板参数列表，例如 &lt;int, char, int(&amp;)[5]&gt;&#125;; Lambda捕获 12345template &lt;class ...T&gt;void func(T... args)&#123; auto g=[&amp;,args...]&#123;return h(args...);&#125; g();&#125; sizeof…运算符 基类指定符和成员初始化列表12345template&lt;class... Mixins&gt;class X : public Mixins... &#123; public: X(const Mixins&amp;... mixins) : Mixins(mixins)... &#123; &#125;&#125;; 实例1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;void print()&#123; cout&lt;&lt;endl;&#125;template &lt;class T&gt; void print(const T&amp; t)&#123; cout&lt;&lt; t &lt;&lt;endl;&#125;template &lt;class First,class... Rest&gt;void print(const First&amp; first,const Rest&amp;... rest)&#123; cout&lt;&lt;first&lt;&lt;&quot;,&quot;; print(rest);&#125;int main()&#123; print(); print(1); print(10,20); print(100,200,300); print(&quot;first&quot;,2,&quot;third&quot;,3.14159);&#125; 实现C语言中的printf函数：12345678910111213141516171819202122232425#include &lt;iostream&gt; void tprintf(const char* format) // 基函数&#123; std::cout &lt;&lt; format;&#125; template&lt;typename T, typename... Targs&gt;void tprintf(const char* format, T value, Targs... Fargs) // 递归变参数函数&#123; for ( ; *format != &apos;\0&apos;; format++ ) &#123; if ( *format == &apos;%&apos; ) &#123; std::cout &lt;&lt; value; tprintf(format+1, Fargs...); // 递归调用 return; &#125; std::cout &lt;&lt; *format; &#125;&#125; int main()&#123; tprintf(&quot;% world% %\n&quot;,&quot;Hello&quot;,&apos;!&apos;,123); return 0;&#125;]]></content>
      <categories>
        <category>C++学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>新特性</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++新特性之Type Alias、Template Alias、noexcept、override、final]]></title>
    <url>%2FC-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2FC-%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BType-Alias%E3%80%81Template-Alias%E3%80%81noexcept%E3%80%81override%E3%80%81final%2F</url>
    <content type="text"><![CDATA[1. Type Alias（类型别名）and Template Alias（模板别名）在C++11中，我们不仅可以为类型定义别名，还可以对模板进行定义别名。 别名声明的语法12341. using identifier = type-id //identifier为引入的类型名，type-id为抽象声明器或者任何合法的type-id2. template &lt;template-parameter-list&gt; using identifier =type type-id 类型别名声明和typedef的声明没有差别。 举例1234567891011121314151617181920212223242526272829303132333435363738#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;type_traits&gt;class Base&#123; &#125;;//类型别名using A = Base;//等同于 typedef Base A;A *a = new A(4);using func=void (*)(int,int);//等同于typedef void (*func)(int,int);void example(int,int)&#123;&#125;func b=example;//别名模板template&lt;class T&gt;using point = T*;point&lt;const char&gt; str="I Love C++";//point&lt;const char&gt;为指向const char的指针//用于隐藏模板形参的别名模板template&lt;class CharT&gt;using mystring = std::basic_string&lt;CharT, std::char_traits&lt;CharT&gt;&gt;;mystring&lt;char&gt; str;能引入成员typedef名的别名模板template&lt;class T&gt;struct D&#123; using value_type=T;&#125;;template&lt;class D&gt;void g(const D&amp; c)&#123; typename D::value_type n; &#125;const D&lt;int&gt; d;g(d); //通过typeid(n).name()可以获取n的类型为int 2. noexcept在C++11中，我们可以通过noexcept来指定某个函数不会抛出异常。 在C++11之前，通常使用如下方式实现不抛出异常：12void func() throw();//throw()的()中通常用来放置函数可以抛出异常的类型，如果为空，则不抛出任何异常。 C++11将throw()用noexcept替换，如下：1void func() noexcept; 事实上，noexcept指定符的用法不仅仅是替代throw()。 语法12noexcept(expression)//如果没有expression,expression默认为true,即不抛出任何异常。 举例12345678910111213141516171819202122指向不抛出函数的指针可赋值给指向潜在抛出函数的指针，反之不可。void f(); //潜在抛出void (*fn)() noexcept =ft; //错误//若虚函数为不抛出，则所有声明，包括整个覆写的定义都必须是不抛出，除非覆写定义被删除。struct B&#123; virtual void f() noexcept; virtual void g(); virtual void h noexcept = delete;&#125;;struct D:B&#123; void f(); //错误，D::f为潜在抛出，B::f为不抛出 void g() noexcept; //正确 void h() = delete; //正确&#125;;//不抛出函数允许调用潜在抛出函数void func1(); //潜在抛出void func2() noexcept&#123; f(); //合法 throw 10; //合法，最终调用std::abort()终止程序&#125; 3. override我们在学习C++虚函数的时候，要求派生类的虚函数要覆盖掉基类中对应的虚函数（函数参数、返回类型必须相同）,。比如：123456789101112131415class Base&#123; public: Base()&#123;&#125; ~Base()&#123;&#125; virtual void print(const char *str);&#125;;class A::public Base&#123; public: A()&#123;&#125; ~A()&#123;&#125; void print(const char* str);&#125;; 但是上面的代码有一个缺点：如果派生类中想要重新定义的函数却不小心写错了，基类的函数没有被覆盖，但是编译器没有报错，使得调试的时候很难发现。 在C++11中提供的override关键字可以解决这一问题，它标记派生类中的虚函数，如果基类中的虚函数没有被覆盖，编译器则报错。 4. final假若一个函数被指定为final，则说明该函数不可被覆盖。 12345678910111213141516class A::public Base&#123; public: A()&#123;&#125; ~A()&#123;&#125; void print(const char* str) final;&#125;;class B:public A&#123; public: A()&#123;&#125; ~A()&#123;&#125; void print(const char* str); //编译器报错，print无法被重写&#125;;]]></content>
      <categories>
        <category>C++学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>新特性</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++新特性之Lambda表达式]]></title>
    <url>%2FC-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2FC-%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是lambda表达式？一个lambda表达式表示以一个可以调用的代码单元。或者理解为一个匿名的内联函数。与任何函数类似，一个lambda具有返回类型、一个参数列表和一个函数体。与函数不同，lambda可能定义在函数内部。 为什么要有lambda表达式？我们知道，在STL所提供的算法中，往往有两个版本。其中一个版本表现最直观的的某种运算，第二个版本则表现出最泛化的演算流程，允许用户“以template参数来指定所要采取的策略”。以sort()为例，第一版本是默认从小到大排序（operator&lt;），第二个版本则是允许你指定某种“操作”，使得排序后的两个相邻元素都能令该操作结果为true。事实上，第二版本允许我们想算法传递任何类别的可调用对象。这个“可调用对象”为第二个版本的第三个参数，被称为“谓词”。 可调用对象C++的可调用对象有5类： 函数 函数指针 重载了函数调用运算符的类 bind创建的对象 lambda表达式 而在标准算法中将“谓词”分为两类：一元谓词（只接受一个参数）、二元谓词（接受两个参数）。 但是我们在使用一个算法中，要使用更多的参数，超出了谓词的限制，或者调用的函数有时候只用一次，重用性太差，那我们就要解决这些问题。 C++11就引入了lambda表达式来解决这些问题。 lambda表达式怎么用？语法1231. [captures](params) -&gt; return type &#123; function body &#125;2. [captures](params) &#123; function body &#125;3. [captures] &#123; function body &#125; captures为捕获列表，为lambda中定义的局部变量的列表。 params表示参数列表。 return type表示返回类型，为尾随返回类型。 function body为函数体。 上面三种用法中，我们可以看出来，参数列表和返回类型可以忽略，但是必须包含捕获列表和函数体。 lambda 捕获123456[]：lambda不能使用所在函数的变量。[=]：值捕获，lambda表达式可以以拷贝的方式访问函数中的变量的值。[&amp;]：引用捕获，lambda表达式中以引用的方式访问函数中的变量的值。[=,&amp;]：值捕获和引用捕获混合使用。[var]：指定捕获或拷贝。[this]：捕获this指针。 举例12345678910111213141516171819202122232425262728293031#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;int main()&#123; std::vector&lt;int&gt; a=&#123;1,2,3,4,5&#125;; std::for_each(a.begin(),a.end(),[](int i)&#123; std::cout&lt;&lt;i&lt;&lt;&quot; &quot;&#125;); //C++14 lambda可以拥有自身的默认参数 auto func=[](inr i=6)&#123;return i+4;&#125;; std::cout&lt;&lt;func()&lt;&lt;std::endl; //值捕获和引用捕获 int b=1024,c=2048; auto func2=[b,&amp;c]&#123; std::cout&lt;&lt;i&lt;&lt;std::endl; std::cout&lt;&lt;&amp;j&lt;&lt;std::endl; &#125;; func2(); //与stl算法结合，找出a中大于3的一个元素 int x=3; auto d=find_if(a.begin(),a.end(), [x](int num) &#123;return num&gt;x;&#125;); return 0;&#125;]]></content>
      <categories>
        <category>C++学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>新特性</tag>
        <tag>编程</tag>
      </tags>
  </entry>
</search>
