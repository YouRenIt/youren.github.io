<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>幽人&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yourenit.top/"/>
  <updated>2018-09-22T11:45:07.104Z</updated>
  <id>http://yourenit.top/</id>
  
  <author>
    <name>幽人</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>右值引用和移动构造函数</title>
    <link href="http://yourenit.top/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <id>http://yourenit.top/C-学习笔记/右值引用和移动构造函数/</id>
    <published>2018-09-22T11:42:20.000Z</published>
    <updated>2018-09-22T11:45:07.104Z</updated>
    
    <content type="html"><![CDATA[<p>在了解右值引用之前，我们先复习什么左值、右值？什么是引用？</p><h3 id="左值、右值"><a href="#左值、右值" class="headerlink" title="左值、右值"></a>左值、右值</h3><p>在<code>C</code>语言中，左值可以位于赋值语句的左侧，右值则不能。<br>具体可以参考<a href="https://zh.cppreference.com/w/c/language/value_category" target="_blank" rel="noopener">C值类别</a>。</p><p>在<code>C++</code>中，每个表达式属于三种基本值之一：纯右值、亡值、左值。<br>具体参考<a href="https://zh.cppreference.com/w/cpp/language/value_category" target="_blank" rel="noopener">C++值类别</a>。</p><p>在<code>C++ Prime</code>中，对左值和右值的区别做了一个简单的归纳：</p><ol><li><strong>当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。</strong></li><li><strong>左值有持久的状态，而右值要么是字面常量，要么是表达式求值过程中创建的临时对象。</strong></li></ol><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用是为一个已经存在的对象或者函数起一个别名。并不是将这个对象或者函数拷贝给引用。通常用<code>&amp;</code>定义引用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a=123;</span><br><span class="line">int &amp;b=a;           //它相当于给a起个别名为b</span><br><span class="line"></span><br><span class="line">b=456;              //对引用的操作实在与之绑定的对象上进行的</span><br></pre></td></tr></table></figure></p><h4 id="引用的注意事项"><a href="#引用的注意事项" class="headerlink" title="引用的注意事项"></a>引用的注意事项</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int &amp;c=1;           //错误，引用类型的初始值必须是一个对象</span><br><span class="line">const int &amp;d=2;     //正确，d为一个常量引用</span><br><span class="line"></span><br><span class="line">double &amp;e=a;        //错误引用类型必须是int类型对象</span><br></pre></td></tr></table></figure><p>当我们复习完上面所有知识之后，我们来了解什么是左值引用、右值引用？</p><h3 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h3><p>左值引用用于对已经存在的对象起一个别名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#icnldue &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string s=&quot;Hello&quot;;</span><br><span class="line">    string&amp; r1s;</span><br><span class="line">    const string&amp;r2=s;</span><br><span class="line">    </span><br><span class="line">    r1+=&quot; World!&quot;;      //可以修改s</span><br><span class="line">    r2+=&quot; World!&quot;;      //不可以修改，r2为常量引用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也可以用于函数调用实现引用传递：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void print(string&amp; str)&#123;</span><br><span class="line">    str+=&quot; World!&quot;;</span><br><span class="line">    cout&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string str=&quot;Hello&quot;;</span><br><span class="line">    print(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>函数的返回值是左值引用时，函数调用表达式成为左值表达式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">char&amp; print_char(string&amp; str,size_t n)&#123;</span><br><span class="line">    return str.at(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string str=&quot;Hello&quot;;</span><br><span class="line">    print(str,0)=&apos;C&apos;;   //函数调用是左值，可以被赋值</span><br><span class="line">    cout&lt;&lt;str&lt;&lt;endl;    //输出Cello</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在C++中，我们常见的左值返回还有赋值、下标、解引用、和前置递增/递减运算符，他们的返回值都是可以被修改的。</span><br></pre></td></tr></table></figure></p><p>但是，对于一些要求转换的表达式、字面常量或是返回右值的表达式，左值引用就无能为力了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string &amp; print(string &amp; str)&#123;</span><br><span class="line">    return str+&quot; world!&quot;;       //编译器报错，非常量引用的初始值必须为左值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们知道<code>str+&quot; world!&quot;</code>为右值，我们将返回类型改为常量类型，就不会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const string &amp; print(string &amp; str)&#123;</span><br><span class="line">    return str+&quot; world!&quot;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们调用一下，试试看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const string&amp; str2=print(str);</span><br><span class="line">cout&lt;&lt;str2&lt;&lt;endl;</span><br></pre></td></tr></table></figure></p><p>此时，我们发现，输出的结果是乱码，调试发现，<code>str2</code>中根本没有值。这是因为函数调用产生一个临时对象，引用则将绑定这个临时对象，当函数调用完毕将临时对象销毁，引用将失效，所以返回乱码。</p><p>那么问题该怎么解决呢？就函数来看，毕竟返回引用类型要比返回值类型要高效，不用将临时对象的值拷贝给新的对象，而是“偷了”临时对象的值。</p><p><code>C++11</code>为我们则引入了一种新的类型————右值引用。</p><h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>新标准中用<code>&amp;&amp;</code>来定义右值引用，右值引用指向的是临时对象，因此延长了临时对象的生存期。这种“偷”走临时变量的行为，被称为“移动语义”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string s1=&quot;Hello&quot;;</span><br><span class="line">    string &amp;&amp; r=s1+s1;      //s1+s1创建一个临时对象</span><br><span class="line">    r+=&quot; World!&quot;;</span><br><span class="line">    cout&lt;&lt;r&lt;&lt;endl;      //输出Hello Hello World!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在新标准中，我们还可以显式的将一个左值转换为对应的右值引用类型——<code>move</code>函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i=10;  </span><br><span class="line">int &amp;&amp; k=std::move(i);</span><br><span class="line">cout&lt;&lt;&amp;i&lt;&lt;&quot; &quot;&lt;&lt;&amp;k&lt;&lt;endl;        //i和k的地址相同</span><br></pre></td></tr></table></figure></p><p>既然我们可以延长临时对象的生存期，并减少对象的拷贝操作，我们在自己的类中如果也支持移动操作，那么也提高不少效率。</p><h3 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h3><p>我们需要定义移动构造函数和移动赋值运算符。这两个成员类似于对应的拷贝操作，但它们是从给定的对象“窃取”资源而不是拷贝资源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class MyString &#123;</span><br><span class="line">private:</span><br><span class="line">char* data;</span><br><span class="line">size_t len;</span><br><span class="line">public:</span><br><span class="line">MyString():data(nullptr),len(0)&#123;&#125;</span><br><span class="line">MyString(const char* p):data(new char[strlen(p)+1]),len(strlen(p))&#123;</span><br><span class="line">strcpy(data, p);</span><br><span class="line">cout &lt;&lt; &quot;Construct: &quot; &lt;&lt; ++cstr &lt;&lt; endl;</span><br><span class="line">&#125;//构造函数</span><br><span class="line">MyString(const MyString&amp; str) :data(new char[strlen(str.data) + 1]), len(strlen(str.data)) &#123;</span><br><span class="line">strcpy(this-&gt;data, str.data);</span><br><span class="line">cout &lt;&lt; &quot;Copy Construct: &quot; &lt;&lt; ++cptr &lt;&lt; endl;</span><br><span class="line">&#125;//拷贝构造函数</span><br><span class="line"></span><br><span class="line">~MyString() &#123; </span><br><span class="line">delete data; </span><br><span class="line">cout &lt;&lt; &quot;Destruct: &quot; &lt;&lt; ++dstr &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">static int cstr;        //构造函数调用次数</span><br><span class="line">static int dstr;        //析构函数调用次数</span><br><span class="line">static int cptr;        //拷贝构造函数调用次数</span><br><span class="line">//static int mvtr;        //移动构造函数调用次数</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int MyString::cstr = 0;</span><br><span class="line">int MyString::dstr = 0;</span><br><span class="line">int MyString::cptr = 0;</span><br><span class="line">//int MyString::mvtr = 0;</span><br><span class="line"></span><br><span class="line">MyString GetStr() &#123; return MyString(&quot;Hello&quot;); &#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    MyString str=MyStriung(&quot;Hello&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面中的静态变量用来输出各种函数调用的次数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">在g++上的运行结果为：</span><br><span class="line">Construct: 1</span><br><span class="line">Copy Construct: 1</span><br><span class="line">Destruct: 1</span><br><span class="line">Copy Construct: 2</span><br><span class="line">Destruct: 2</span><br><span class="line">Destruct: 3</span><br><span class="line"></span><br><span class="line">在vs上的结果为：</span><br><span class="line">Construct: 1</span><br><span class="line">Copy Construct: 1</span><br><span class="line">Destruct: 1</span><br><span class="line">    </span><br><span class="line">vs将其优化了，用g++的-fno-elide-constructors参数就不会被优化。</span><br></pre></td></tr></table></figure></p><p>可以看出，拷贝构造函数被调用了两次，一次是将构造的变量拷贝构造给临时值，用来做<code>GetStr</code>的返回值，另一次是由临时值构造出<code>main</code>函数中的变量<code>str</code>。</p><p>如果字符串的数据很大的话，那么花在拷贝上的时间比较大了，效率就会大大降低。如果我们将临时对象的值“偷”过来，那效率会有什么变化呢？<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们在上述类中添加移动构造函数</span></span><br><span class="line">MyString(MyString &amp;&amp;str)&#123;</span><br><span class="line">    len=str.len;</span><br><span class="line">    <span class="keyword">this</span>-&gt;data=str.data;</span><br><span class="line">    str.len=<span class="number">0</span>;</span><br><span class="line">    str.data=<span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">MyString <span class="title">GetStr</span><span class="params">()</span></span>&#123; MyString str=<span class="string">"Hello"</span>; <span class="keyword">return</span> str;&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">运行结果为：</span><br><span class="line">Construct: 1</span><br><span class="line">Move Construct: 1</span><br><span class="line">Destruct: 1</span><br><span class="line">Move Construct: 2</span><br><span class="line">Destruct: 2</span><br><span class="line">Destruct: 3</span><br></pre></td></tr></table></figure><p>从结果可以看到，没有执行拷贝构造函数，而是执行的是移动构造函数。虽然在此没有将临时值和mian函数中str的成员变量地址输出出来，但是他们的地址是相同的。这就省去了再申请内存和拷贝的时间，效率也提高了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在了解右值引用之前，我们先复习什么左值、右值？什么是引用？&lt;/p&gt;
&lt;h3 id=&quot;左值、右值&quot;&gt;&lt;a href=&quot;#左值、右值&quot; class=&quot;headerlink&quot; title=&quot;左值、右值&quot;&gt;&lt;/a&gt;左值、右值&lt;/h3&gt;&lt;p&gt;在&lt;code&gt;C&lt;/code&gt;语言中，左值
      
    
    </summary>
    
      <category term="C++学习笔记" scheme="http://yourenit.top/categories/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="编程" scheme="http://yourenit.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="C++" scheme="http://yourenit.top/tags/C/"/>
    
      <category term="新特性" scheme="http://yourenit.top/tags/%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>Haskell初步</title>
    <link href="http://yourenit.top/Haskell%E5%AD%A6%E4%B9%A0/Haskell%E5%88%9D%E6%AD%A5/"/>
    <id>http://yourenit.top/Haskell学习/Haskell初步/</id>
    <published>2018-09-21T08:15:30.000Z</published>
    <updated>2018-09-21T08:17:14.164Z</updated>
    
    <content type="html"><![CDATA[<h3 id="函数的定义和调用"><a href="#函数的定义和调用" class="headerlink" title="函数的定义和调用"></a>函数的定义和调用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//函数名 参数1 参数2 ... = 函数体</span><br><span class="line"></span><br><span class="line">doubleMe x=x+x</span><br><span class="line"></span><br><span class="line">doubleUs x y= x*2 + y*2</span><br><span class="line"></span><br><span class="line">//可在其他函数中调用你编写的函数</span><br><span class="line">doubleUs x y = doubleMe x + doubleMe y</span><br><span class="line">//很符合我们数学中公式的组合f(x)=g(x)+h(x)+...</span><br></pre></td></tr></table></figure><p><code>Haskell</code>中函数没有顺序，无论先声明<code>doubleMe</code>还是<code>doubleUs</code>都是一样的。</p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">//定义，所有元素必须相同类型</span><br><span class="line">let lostNumber=[1,2,3,4]</span><br><span class="line"></span><br><span class="line">//两个list合并</span><br><span class="line">let lostNumber2=[5,6,7,8]</span><br><span class="line">lostNumber ++ lostNumber2</span><br><span class="line"></span><br><span class="line">//索引 !!</span><br><span class="line">lostNumber !!2  //2为下标</span><br><span class="line"></span><br><span class="line">//比较大小</span><br><span class="line">lostNumber &gt; lostNumber2    //返回False</span><br><span class="line">[2.1,3.1,4.1] &gt; [2,3,4]     //返回True</span><br><span class="line">lostNumber == lostNumber2   //返回False</span><br><span class="line"></span><br><span class="line">//常用搭配函数：</span><br><span class="line">head lostNumber         //返回list的第一个元素</span><br><span class="line">last lostNumber         //返回list的最后一个元素</span><br><span class="line">tail lostNumber         //返回除去第一个元素之后的部分</span><br><span class="line">init lostNumber         //返回除去最后一个元素之前的部分</span><br><span class="line">length lostNumber       //返回list的长度</span><br><span class="line">null lostNumber         //检查list是否为空，空则返回True</span><br><span class="line">reverse lostNumber      //将list反转</span><br><span class="line">take 3 lostNumber       //返回list的前几个元素，3指定返回前3个元素</span><br><span class="line">drop 3 lostNumber       //删除list前几个元素</span><br><span class="line">maximum lostNumber      //返回list中最大的元素</span><br><span class="line">minimum lostNumber      //返回list中最小的元素</span><br><span class="line">sum lostNumber          //返回list所有元素之和</span><br><span class="line">profuct lostNumber      //返回list中所有元素之积</span><br><span class="line"></span><br><span class="line">4 `elem` lostNumber      //判断一个元素是否在一个list中</span><br><span class="line"></span><br><span class="line">[1..20]                 //定义一个从1到20的list</span><br><span class="line">[20,19..1]              //[20..1]是不可以的</span><br><span class="line">//也可以是字符</span><br><span class="line">[&apos;a&apos;..&apos;z&apos;]              //返回&quot;abcdefghijklmnopqrstuvwxyz&quot;</span><br><span class="line">[&apos;A&apos;..&apos;z&apos;]              //返回&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz&quot;</span><br><span class="line">//设置步长</span><br><span class="line">[2,4..20]              //返回[2,4,6,8,10,12,14,16,18,20]</span><br><span class="line"></span><br><span class="line">//不标明上限</span><br><span class="line">take 24 [13,26..]           //用多少取多少</span><br><span class="line">[13.26..]                   //不停输出</span><br><span class="line"></span><br><span class="line">repeat接受一个值作为参数，返回一个仅包含该值的无限List</span><br><span class="line">cycle则是接受一个list，并无限输出</span><br><span class="line"></span><br><span class="line">replicate 3 10              //得到包含3个元素相同的list</span><br></pre></td></tr></table></figure><p>我们也可以表达数学中的集合：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S=&#123;2*x | x\in N,x\leq10&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[x*2 | x&lt;-[1..10]]          //返回[2,4,6,8,10,12,14,16,18,20]</span><br><span class="line">[x*2 | x&lt;-[1..10], x*2 &gt;= 12]   //返回[12,14,16,18,20]</span><br></pre></td></tr></table></figure><h3 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fst (8,11)              //返回一个序对的首项</span><br><span class="line">snd (8,11)              //返回一个序对的尾项</span><br><span class="line">//不能用于三元组或四元组以上</span><br><span class="line"></span><br><span class="line">zip [1,2,3,4] [7,8,9]   //zip用来生成一组序对的list</span><br><span class="line">//返回[(1,7),(2,8),(3,9)]</span><br></pre></td></tr></table></figure><p>解决一个问题：如何取得所有三边长度皆为整数且小于等于10，周长为24的直角三角形？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let rightTriangles = [ (a,b,c) | c&lt;-[1..10], b&lt;-[1..c], a&lt;-[1..b], a^2 + b^2 == c^2,a+b+c==24]</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;函数的定义和调用&quot;&gt;&lt;a href=&quot;#函数的定义和调用&quot; class=&quot;headerlink&quot; title=&quot;函数的定义和调用&quot;&gt;&lt;/a&gt;函数的定义和调用&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl
      
    
    </summary>
    
      <category term="Haskell学习" scheme="http://yourenit.top/categories/Haskell%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="编程" scheme="http://yourenit.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Haskell" scheme="http://yourenit.top/tags/Haskell/"/>
    
  </entry>
  
  <entry>
    <title>C++新特性之Variadic Template</title>
    <link href="http://yourenit.top/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BVariadic-Template%EF%BC%88%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF%EF%BC%89/"/>
    <id>http://yourenit.top/C-学习笔记/C-新特性之Variadic-Template（可变参数模板）/</id>
    <published>2018-09-20T16:41:55.000Z</published>
    <updated>2018-09-20T16:43:19.695Z</updated>
    
    <content type="html"><![CDATA[<h3 id="可变参数模板的定义"><a href="#可变参数模板的定义" class="headerlink" title="可变参数模板的定义"></a>可变参数模板的定义</h3><p>可变参数模板是至少有一个参数宝的模板，参数包则是可以接受零个或者更多模板实参的模板形参，其格式如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> ...<span class="title">T</span>&gt; <span class="title">class</span> <span class="title">classname</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> ...<span class="title">T</span>&gt; <span class="title">void</span> <span class="title">func</span>(<span class="title">T</span> ...<span class="title">args</span>);</span></span><br></pre></td></tr></table></figure></p><p>其中<code>T</code>为模板参数包，<code>args</code>为函数参数包。</p><p>可变参数模板可以用任意数量的模板参数实例化：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Myclass</span>&#123;</span>&#125;;</span><br><span class="line">Myclass&lt;&gt; t0;           <span class="comment">//T 不包含实参</span></span><br><span class="line">Myclass&lt;<span class="keyword">int</span>&gt; t1;        <span class="comment">//T 包含一个实参，类型为int</span></span><br><span class="line">Myclass&lt;<span class="keyword">int</span>,<span class="keyword">float</span>&gt; t2;  <span class="comment">//T 包含两个实参，类型为int和float</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//模板参数包必须是模板参数列表中的最后一个形参。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... T,<span class="keyword">typename</span> U&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Invalid</span>;</span>    <span class="comment">//错误</span></span><br></pre></td></tr></table></figure></p><p>可变参数函数模板可以用任意数量的函数实参调用：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">func</span>(<span class="title">T</span>... <span class="title">args</span>);</span></span><br><span class="line">func();        <span class="comment">//args不包含实参</span></span><br><span class="line">func(<span class="number">1</span>);        <span class="comment">//包含一个实参，类型为int</span></span><br><span class="line">func(<span class="number">1</span>,<span class="number">2.1</span>);    <span class="comment">//包含两个实参，类型为int和double</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//与类模板不同，函数模板参数包不必是模板参数列表中的最后一个，它可以在列表早于所有能从函数实参推导的参数出现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">T</span>,<span class="title">class</span> <span class="title">U</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">valid</span>(<span class="title">U</span>,<span class="title">T</span>...);</span>     <span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line">valid(<span class="number">1.0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);       <span class="comment">//推导U为double，T为&#123;int，int，int&#125;</span></span><br></pre></td></tr></table></figure></p><h3 id="包展开"><a href="#包展开" class="headerlink" title="包展开"></a>包展开</h3><p>包展开的场所不同，产生的逗号分隔列表种类不同：</p><ol><li><p>函数实参列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func(&amp;args...);         //展开成func(&amp;E1,&amp;E2,&amp;E3)</span><br><span class="line">func(++args...,n);      //展开成func(++E1,++E2,++E3,n)</span><br><span class="line">func(n,++args);         //展开成func(n,++E1,++E2,++E3)</span><br><span class="line">func(const_cast&lt;const Args*&gt;(&amp;args)...);    // func(const_cast&lt;const E1*&gt;(&amp;X1), const_cast&lt;const E2*&gt;(&amp;X2), const_cast&lt;const E3*&gt;(&amp;X3))</span><br><span class="line">func(h(args...) + args...); // 展开成 func(h(E1,E2,E3) + E1, h(E1,E2,E3) + E2, h(E1,E2,E3) + E3)</span><br></pre></td></tr></table></figure></li><li><p>有括号初始化器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class c1(&amp;args...);             // 调用 Class::Class(&amp;E1, &amp;E2, &amp;E3)</span><br><span class="line">Class c2 = Class(n, ++args...); // 调用 Class::Class(n, ++E1, ++E2, ++E3);</span><br></pre></td></tr></table></figure></li><li><p>花括号环绕的初始化器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class... T&gt; void func(T... args)</span><br><span class="line">&#123;</span><br><span class="line">    const int size=sizeof...(args);</span><br><span class="line">    int res[size]=&#123;args...&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>模板实参列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//包展开可以用于模板形参列表的任何位置，前提是模板拥有匹配展开的形参。</span><br><span class="line">template &lt;class A,class B,class... C&gt; void func(A arg1,B arg2,C... arg3)</span><br><span class="line">&#123;</span><br><span class="line">    container&lt;A,B,C...&gt; t1;     // 展开成 container&lt;A,B,E1,E2,E3&gt; </span><br><span class="line">    container&lt;C...,A,B&gt; t2;     // 展开成 container&lt;E1,E2,E3,A,B&gt; </span><br><span class="line">    container&lt;A,C...,B&gt; t3;      // 展开成 container&lt;A,E1,E2,E3,B&gt; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数形参列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename ...Ts&gt; void f(Ts...) &#123;&#125;</span><br><span class="line">f(&apos;a&apos;, 1);  // Ts... 展开成 void f(char, int)</span><br><span class="line">f(0.1);     // Ts... 展开成 void f(double)</span><br></pre></td></tr></table></figure></li><li><p>模板形参列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class ...T&gt; class Myclass</span><br><span class="line">&#123;</span><br><span class="line">    template&lt;T... Values&gt; // 展开成无类型模板参数列表，例如 &lt;int, char, int(&amp;)[5]&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>Lambda捕获</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class ...T&gt;</span><br><span class="line">void func(T... args)&#123;</span><br><span class="line">    auto g=[&amp;,args...]&#123;return h(args...);&#125;</span><br><span class="line">    g();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>sizeof…运算符</p></li><li>基类指定符和成员初始化列表<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class... Mixins&gt;</span><br><span class="line">class X : public Mixins... &#123;</span><br><span class="line"> public:</span><br><span class="line">    X(const Mixins&amp;... mixins) : Mixins(mixins)... &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void print()&#123;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T&gt; void print(const T&amp; t)&#123;</span><br><span class="line">    cout&lt;&lt; t &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class First,class... Rest&gt;void print(const First&amp; first,const Rest&amp;... rest)&#123;</span><br><span class="line">    cout&lt;&lt;first&lt;&lt;&quot;,&quot;;</span><br><span class="line">    print(rest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    print();</span><br><span class="line">    print(1);</span><br><span class="line">    </span><br><span class="line">    print(10,20);</span><br><span class="line">    print(100,200,300);</span><br><span class="line">    print(&quot;first&quot;,2,&quot;third&quot;,3.14159);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现<code>C</code>语言中的<code>printf</code>函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"> </span><br><span class="line">void tprintf(const char* format) // 基函数</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; format;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">template&lt;typename T, typename... Targs&gt;</span><br><span class="line">void tprintf(const char* format, T value, Targs... Fargs) // 递归变参数函数</span><br><span class="line">&#123;</span><br><span class="line">    for ( ; *format != &apos;\0&apos;; format++ ) &#123;</span><br><span class="line">        if ( *format == &apos;%&apos; ) &#123;</span><br><span class="line">           std::cout &lt;&lt; value;</span><br><span class="line">           tprintf(format+1, Fargs...); // 递归调用</span><br><span class="line">           return;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; *format;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    tprintf(&quot;% world% %\n&quot;,&quot;Hello&quot;,&apos;!&apos;,123);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;可变参数模板的定义&quot;&gt;&lt;a href=&quot;#可变参数模板的定义&quot; class=&quot;headerlink&quot; title=&quot;可变参数模板的定义&quot;&gt;&lt;/a&gt;可变参数模板的定义&lt;/h3&gt;&lt;p&gt;可变参数模板是至少有一个参数宝的模板，参数包则是可以接受零个或者更多模板实参的模板形
      
    
    </summary>
    
      <category term="C++学习笔记" scheme="http://yourenit.top/categories/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="编程" scheme="http://yourenit.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="C++" scheme="http://yourenit.top/tags/C/"/>
    
      <category term="新特性" scheme="http://yourenit.top/tags/%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>C++新特性之Type Alias、Template Alias、noexcept、override、final</title>
    <link href="http://yourenit.top/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BType-Alias%E3%80%81Template-Alias%E3%80%81noexcept%E3%80%81override%E3%80%81final/"/>
    <id>http://yourenit.top/C-学习笔记/C-新特性之Type-Alias、Template-Alias、noexcept、override、final/</id>
    <published>2018-09-19T12:49:13.000Z</published>
    <updated>2018-09-19T12:51:37.728Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Type-Alias（类型别名）and-Template-Alias（模板别名）"><a href="#1-Type-Alias（类型别名）and-Template-Alias（模板别名）" class="headerlink" title="1. Type Alias（类型别名）and Template Alias（模板别名）"></a>1. Type Alias（类型别名）and Template Alias（模板别名）</h3><p>在<code>C++11</code>中，我们不仅可以为类型定义别名，还可以对模板进行定义别名。</p><h4 id="别名声明的语法"><a href="#别名声明的语法" class="headerlink" title="别名声明的语法"></a>别名声明的语法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">using</span> identifier = type-id       <span class="comment">//identifier为引入的类型名，type-id为抽象声明器或者任何合法的type-id</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> <span class="keyword">template</span> &lt;<span class="keyword">template</span>-parameter-<span class="built_in">list</span>&gt;</span><br><span class="line">   <span class="keyword">using</span> identifier =type type-id</span><br></pre></td></tr></table></figure><p>类型别名声明和<code>typedef</code>的声明没有差别。</p><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">using</span> A = Base;</span><br><span class="line"><span class="comment">//等同于 typedef Base A;</span></span><br><span class="line">A *a = <span class="keyword">new</span> A(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> func=<span class="keyword">void</span> (*)(<span class="keyword">int</span>,<span class="keyword">int</span>);</span><br><span class="line"><span class="comment">//等同于typedef void (*func)(int,int);</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">example</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>&#123;&#125;</span><br><span class="line">func b=example;</span><br><span class="line"></span><br><span class="line"><span class="comment">//别名模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">using</span> <span class="title">point</span> = <span class="title">T</span>*;</span></span><br><span class="line">point&lt;<span class="keyword">const</span> <span class="keyword">char</span>&gt; str=<span class="string">"I Love C++"</span>;</span><br><span class="line"><span class="comment">//point&lt;const char&gt;为指向const char的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用于隐藏模板形参的别名模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">CharT</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">using</span> <span class="title">mystring</span> = <span class="title">std</span>:</span>:basic_string&lt;CharT, <span class="built_in">std</span>::char_traits&lt;CharT&gt;&gt;;</span><br><span class="line">mystring&lt;<span class="keyword">char</span>&gt; str;</span><br><span class="line"></span><br><span class="line">能引入成员<span class="keyword">typedef</span>名的别名模板</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">D</span>&#123;</span></span><br><span class="line">    <span class="keyword">using</span> value_type=T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">D</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">g</span>(<span class="title">const</span> <span class="title">D</span>&amp; <span class="title">c</span>)&#123;</span> <span class="keyword">typename</span> D::value_type n; &#125;</span><br><span class="line"><span class="keyword">const</span> D&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">g(d); </span><br><span class="line"><span class="comment">//通过typeid(n).name()可以获取n的类型为int</span></span><br></pre></td></tr></table></figure><h3 id="2-noexcept"><a href="#2-noexcept" class="headerlink" title="2. noexcept"></a>2. noexcept</h3><p>在<code>C++11</code>中，我们可以通过<code>noexcept</code>来指定某个函数不会抛出异常。</p><p>在<code>C++11</code>之前，通常使用如下方式实现不抛出异常：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void func() throw();</span><br><span class="line">//throw()的()中通常用来放置函数可以抛出异常的类型，如果为空，则不抛出任何异常。</span><br></pre></td></tr></table></figure></p><p><code>C++11</code>将<code>throw()</code>用<code>noexcept</code>替换，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void func() noexcept;</span><br></pre></td></tr></table></figure></p><p>事实上，<code>noexcept</code>指定符的用法不仅仅是替代<code>throw()</code>。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">noexcept(expression)</span><br><span class="line">//如果没有expression,expression默认为true,即不抛出任何异常。</span><br></pre></td></tr></table></figure><h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">指向不抛出函数的指针可赋值给指向潜在抛出函数的指针，反之不可。</span><br><span class="line">void f();   //潜在抛出</span><br><span class="line">void (*fn)() noexcept =ft;  //错误</span><br><span class="line"></span><br><span class="line">//若虚函数为不抛出，则所有声明，包括整个覆写的定义都必须是不抛出，除非覆写定义被删除。</span><br><span class="line">struct B&#123;</span><br><span class="line">    virtual void f() noexcept;</span><br><span class="line">    virtual void g();</span><br><span class="line">    virtual void h noexcept = delete;</span><br><span class="line">&#125;;</span><br><span class="line">struct D:B&#123;</span><br><span class="line">    void f();   //错误，D::f为潜在抛出，B::f为不抛出</span><br><span class="line">    void g() noexcept;  //正确</span><br><span class="line">    void h() = delete;  //正确</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//不抛出函数允许调用潜在抛出函数</span><br><span class="line">void func1();   //潜在抛出</span><br><span class="line">void func2() noexcept&#123;</span><br><span class="line">    f();    //合法</span><br><span class="line">    throw 10;   //合法，最终调用std::abort()终止程序</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-override"><a href="#3-override" class="headerlink" title="3. override"></a>3. override</h3><p>我们在学习C++虚函数的时候，要求派生类的虚函数要覆盖掉基类中对应的虚函数（函数参数、返回类型必须相同）,。比如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Base()&#123;&#125;</span><br><span class="line">        ~Base()&#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span>:<span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        A()&#123;&#125;</span><br><span class="line">        ~A()&#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>但是上面的代码有一个缺点：如果派生类中想要重新定义的函数却不小心写错了，基类的函数没有被覆盖，但是编译器没有报错，使得调试的时候很难发现。</p><p>在<code>C++11</code>中提供的<code>override</code>关键字可以解决这一问题，它标记派生类中的虚函数，如果基类中的虚函数没有被覆盖，编译器则报错。</p><h3 id="4-final"><a href="#4-final" class="headerlink" title="4. final"></a>4. final</h3><p>假若一个函数被指定为<code>final</code>，则说明该函数不可被覆盖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class A::public Base&#123;</span><br><span class="line">    public:</span><br><span class="line">        A()&#123;&#125;</span><br><span class="line">        ~A()&#123;&#125;</span><br><span class="line">        </span><br><span class="line">        void print(const char* str) final;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B:public A&#123;</span><br><span class="line">  public:</span><br><span class="line">    A()&#123;&#125;</span><br><span class="line">    ~A()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    void print(const char* str);</span><br><span class="line">    //编译器报错，print无法被重写</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Type-Alias（类型别名）and-Template-Alias（模板别名）&quot;&gt;&lt;a href=&quot;#1-Type-Alias（类型别名）and-Template-Alias（模板别名）&quot; class=&quot;headerlink&quot; title=&quot;1. Type 
      
    
    </summary>
    
      <category term="C++学习笔记" scheme="http://yourenit.top/categories/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="编程" scheme="http://yourenit.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="C++" scheme="http://yourenit.top/tags/C/"/>
    
      <category term="新特性" scheme="http://yourenit.top/tags/%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>C++新特性之Lambda表达式</title>
    <link href="http://yourenit.top/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yourenit.top/C-学习笔记/C-新特性之Lambda表达式/</id>
    <published>2018-09-14T04:28:37.000Z</published>
    <updated>2018-09-15T16:23:54.800Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是lambda表达式？"><a href="#什么是lambda表达式？" class="headerlink" title="什么是lambda表达式？"></a>什么是lambda表达式？</h3><p>一个<code>lambda</code>表达式表示以一个可以调用的代码单元。或者理解为一个匿名的内联函数。与任何函数类似，一个<code>lambda</code>具有返回类型、一个参数列表和一个函数体。与函数不同，<code>lambda</code>可能定义在函数内部。</p><h3 id="为什么要有lambda表达式？"><a href="#为什么要有lambda表达式？" class="headerlink" title="为什么要有lambda表达式？"></a>为什么要有lambda表达式？</h3><p>我们知道，在<code>STL</code>所提供的算法中，往往有两个版本。其中一个版本表现最直观的的某种运算，第二个版本则表现出最泛化的演算流程，允许用户“以<code>template</code>参数来指定所要采取的策略”。以<code>sort()</code>为例，第一版本是默认<strong>从小到大排序（operator&lt;）</strong>，第二个版本则是允许你指定某种“操作”，使得排序后的两个相邻元素都能令该操作结果为<code>true</code>。事实上，第二版本允许我们想算法传递任何类别的<strong>可调用对象</strong>。这个“可调用对象”为第二个版本的第三个参数，被称为“<strong>谓词</strong>”。</p><h4 id="可调用对象"><a href="#可调用对象" class="headerlink" title="可调用对象"></a>可调用对象</h4><p>C++的可调用对象有5类：</p><ol><li>函数</li><li>函数指针</li><li>重载了函数调用运算符的类</li><li>bind创建的对象</li><li><strong>lambda表达式</strong></li></ol><p>而在标准算法中将“谓词”分为两类：<strong>一元谓词（只接受一个参数）</strong>、<strong>二元谓词（接受两个参数）</strong>。</p><p>但是我们在使用一个算法中，要使用更多的参数，超出了谓词的限制，或者调用的函数有时候只用一次，重用性太差，那我们就要解决这些问题。</p><p><code>C++11</code>就引入了<code>lambda表达式</code>来解决这些问题。</p><h3 id="lambda表达式怎么用？"><a href="#lambda表达式怎么用？" class="headerlink" title="lambda表达式怎么用？"></a>lambda表达式怎么用？</h3><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. [captures](params) -&gt; return type &#123; function body &#125;</span><br><span class="line">2. [captures](params) &#123; function body &#125;</span><br><span class="line">3. [captures] &#123; function body &#125;</span><br></pre></td></tr></table></figure><p><code>captures</code>为捕获列表，为lambda中定义的局部变量的列表。</p><p><code>params</code>表示参数列表。</p><p><code>return type</code>表示返回类型，为尾随返回类型。</p><p><code>function body</code>为函数体。</p><p>上面三种用法中，我们可以看出来，<strong>参数列表</strong>和<strong>返回类型</strong>可以忽略，但是必须包含<strong>捕获列表</strong>和<strong>函数体</strong>。</p><h4 id="lambda-捕获"><a href="#lambda-捕获" class="headerlink" title="lambda 捕获"></a>lambda 捕获</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[]：lambda不能使用所在函数的变量。</span><br><span class="line">[=]：值捕获，lambda表达式可以以拷贝的方式访问函数中的变量的值。</span><br><span class="line">[&amp;]：引用捕获，lambda表达式中以引用的方式访问函数中的变量的值。</span><br><span class="line">[=,&amp;]：值捕获和引用捕获混合使用。</span><br><span class="line">[var]：指定捕获或拷贝。</span><br><span class="line">[this]：捕获this指针。</span><br></pre></td></tr></table></figure><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;int&gt; a=&#123;1,2,3,4,5&#125;;</span><br><span class="line">    std::for_each(a.begin(),a.end(),[](int i)&#123; std::cout&lt;&lt;i&lt;&lt;&quot; &quot;&#125;);</span><br><span class="line">    </span><br><span class="line">    //C++14 lambda可以拥有自身的默认参数</span><br><span class="line">    auto func=[](inr i=6)&#123;return i+4;&#125;;</span><br><span class="line">    std::cout&lt;&lt;func()&lt;&lt;std::endl;</span><br><span class="line">    </span><br><span class="line">    //值捕获和引用捕获</span><br><span class="line">    int b=1024,c=2048;</span><br><span class="line">    auto func2=[b,&amp;c]&#123;</span><br><span class="line">        std::cout&lt;&lt;i&lt;&lt;std::endl;</span><br><span class="line">        std::cout&lt;&lt;&amp;j&lt;&lt;std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    func2();</span><br><span class="line">    </span><br><span class="line">    //与stl算法结合，找出a中大于3的一个元素</span><br><span class="line">    int x=3;</span><br><span class="line">    auto d=find_if(a.begin(),a.end(),</span><br><span class="line">        [x](int num)</span><br><span class="line">            &#123;return num&gt;x;&#125;);</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是lambda表达式？&quot;&gt;&lt;a href=&quot;#什么是lambda表达式？&quot; class=&quot;headerlink&quot; title=&quot;什么是lambda表达式？&quot;&gt;&lt;/a&gt;什么是lambda表达式？&lt;/h3&gt;&lt;p&gt;一个&lt;code&gt;lambda&lt;/code&gt;表达式表示
      
    
    </summary>
    
      <category term="C++学习笔记" scheme="http://yourenit.top/categories/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="编程" scheme="http://yourenit.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="C++" scheme="http://yourenit.top/tags/C/"/>
    
      <category term="新特性" scheme="http://yourenit.top/tags/%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
</feed>
