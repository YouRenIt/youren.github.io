<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>幽人&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yourenit.top/"/>
  <updated>2019-09-03T03:58:48.330Z</updated>
  <id>http://yourenit.top/</id>
  
  <author>
    <name>幽人</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>常用函数的封装</title>
    <link href="http://yourenit.top/uncategorized/%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E7%9A%84%E5%B0%81%E8%A3%85/"/>
    <id>http://yourenit.top/uncategorized/常用函数的封装/</id>
    <published>2019-09-02T11:33:35.000Z</published>
    <updated>2019-09-03T03:58:48.330Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常用函数的封装"><a href="#常用函数的封装" class="headerlink" title="常用函数的封装"></a>常用函数的封装</h3><p>常用函数的封装：</p><ul><li>字符串操作常用函数<ul><li>大小写转换函数</li><li>分割字符串函数</li><li>字符串转换函数</li><li>字符串替换函数</li></ul></li><li>时间操作常用函数</li></ul><h4 id="帮助类定义"><a href="#帮助类定义" class="headerlink" title="帮助类定义"></a>帮助类定义</h4><h5 id="字符串操作封装"><a href="#字符串操作封装" class="headerlink" title="字符串操作封装"></a>字符串操作封装</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YR_Common</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//去掉头部及尾部的字符或者字符串</span></span><br><span class="line">    <span class="comment">//bool为true 去除s中的每个字符，为false去除s字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">string</span> <span class="title">trim</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; sStr, <span class="keyword">const</span> <span class="built_in">string</span>&amp; s=<span class="string">" \r\n\t"</span>, <span class="keyword">bool</span> bChar=<span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="comment">//去掉左边的字符或者字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">string</span> <span class="title">trimleft</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;sStr, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s = <span class="string">" \r\n\t"</span>, <span class="keyword">bool</span> bChar = <span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="comment">//去掉右边的字符或者字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">string</span> <span class="title">trimright</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;sStr, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s = <span class="string">" \r\n\t"</span>, <span class="keyword">bool</span> bChar = <span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="comment">//字符串转换成小写</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">string</span> <span class="title">lower</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;sString)</span></span>;</span><br><span class="line">    <span class="comment">//字符串转换成大写</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">string</span> <span class="title">upper</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;sString)</span></span>;</span><br><span class="line">    <span class="comment">//字符串是否都是数字</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">isdigit</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;sInput)</span></span>;</span><br><span class="line">    <span class="comment">//字符串转换成时间结构</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">strTotm</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;sString, <span class="keyword">const</span> <span class="built_in">string</span> &amp;sFormat, struct tm &amp;stTm)</span></span>;</span><br><span class="line">    <span class="comment">//时间转换为字符串,默认格式为sFormat格式</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">string</span> <span class="title">tmTostr</span><span class="params">(<span class="keyword">const</span> struct tm &amp;stTm, <span class="keyword">const</span> <span class="built_in">string</span> &amp;sFormat = <span class="string">"%Y%m%d%H%M%S"</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">string</span> <span class="title">tmTostr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span> &amp;t, <span class="keyword">const</span> <span class="built_in">string</span> &amp;sFormat = <span class="string">"%Y%m%d%H%M%S"</span>)</span></span>;</span><br><span class="line">    <span class="comment">//当前时间转换为字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">string</span> <span class="title">nowTostr</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;sFormat = <span class="string">"%Y%m%d%H%M%S"</span>)</span></span>;</span><br><span class="line">    <span class="comment">//获取当前时间的毫秒数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> int64_t <span class="title">nowToms</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取当前时间的微秒数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> int64_t <span class="title">nowTous</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//字符串转换函数</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> T <span class="title">strto</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;sStr)</span></span>;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> T <span class="title">strto</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;sStr, <span class="keyword">const</span> <span class="built_in">string</span> &amp;sDefault)</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> YR_Common::trim(<span class="keyword">const</span> <span class="built_in">string</span> &amp;sStr, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">bool</span> bChar)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(sStr.empty())</span><br><span class="line">        <span class="keyword">return</span> sStr;</span><br><span class="line">    <span class="keyword">if</span>(!bChar)<span class="comment">//当bChar为false，则去除s字符串</span></span><br><span class="line">        <span class="comment">//先去掉字符串左边的字符串，再去掉右边的字符串</span></span><br><span class="line">        <span class="keyword">return</span> trimright(trimleft(sStr, s, <span class="literal">false</span>), s, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> trimright(trimleft(sStr, s, <span class="literal">true</span>), s, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> YR_Common::trimleft(<span class="keyword">const</span> <span class="built_in">string</span> &amp;sStr, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">bool</span> bChar)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(sStr.empty())</span><br><span class="line">        <span class="keyword">return</span> sStr;</span><br><span class="line"><span class="comment">//如果bChar为false，则去除s字符串</span></span><br><span class="line">    <span class="keyword">if</span>(!bChar)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sStr.length() &lt; s.length())</span><br><span class="line">            <span class="keyword">return</span> sStr;</span><br><span class="line">        <span class="keyword">if</span>(sStr.compare(<span class="number">0</span>, s.length(), s) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> sStr.substr(s.length());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sStr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 去掉sStr左边的 字符串s中的字符</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> sStr.substr(sStr.find_first_not_of(s));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> YR_Common::trimright(<span class="keyword">const</span> <span class="built_in">string</span> &amp;sStr, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">bool</span> bChar)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(sStr.empty())</span><br><span class="line">        <span class="keyword">return</span> sStr;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 去掉sStr右边的字符串s</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(!bChar)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sStr.length() &lt; s.length())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> sStr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sStr.compare(sStr.length() - s.length(), s.length(), s) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> sStr.substr(<span class="number">0</span>, sStr.length() - s.length());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sStr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 去掉sStr右边的 字符串s中的字符</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> sStr.substr(<span class="number">0</span>, sStr.find_first_not_of(s));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//toupper和tolower原型：</span></span><br><span class="line"><span class="comment">//int toupper(int c);</span></span><br><span class="line"><span class="comment">//int tolower(int c);</span></span><br><span class="line"><span class="built_in">string</span> YR_Common::lower(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> sStr = s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sStr.length();i++)</span><br><span class="line">        sStr[i] = <span class="built_in">tolower</span>(sStr[i]);</span><br><span class="line">    <span class="keyword">return</span> sStr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">string</span> YR_Common::upper(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> sStr = s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sStr.length();i++)</span><br><span class="line">        sStr[i] = <span class="built_in">toupper</span>(sStr[i]);</span><br><span class="line">    <span class="keyword">return</span> sStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> YR_Common::<span class="built_in">isdigit</span>(<span class="keyword">const</span> <span class="built_in">string</span> &amp;sInput)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::count_if(sInput.begin(),sInput.end(),[](<span class="keyword">char</span> c)&#123;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="built_in">isdigit</span>(c);</span><br><span class="line">    &#125;) == <span class="keyword">static_cast</span>&lt;<span class="keyword">int32_t</span>&gt;(sInput.length());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//strptime和strftime原型：</span></span><br><span class="line"><span class="comment">// #include &lt;time.h&gt;</span></span><br><span class="line"><span class="comment">//char *strptime(const char *s, const char *format, struct tm *tm);</span></span><br><span class="line"><span class="comment">//std::size_t strftime( char* str, std::size_t count, const char* format, const std::tm* time );</span></span><br><span class="line"><span class="comment">//struct tm &#123;</span></span><br><span class="line"><span class="comment">//      int tm_sec;    /* Seconds (0-60) */</span></span><br><span class="line"><span class="comment">//      int tm_min;    /* Minutes (0-59) */</span></span><br><span class="line"><span class="comment">//      int tm_hour;   /* Hours (0-23) */</span></span><br><span class="line"><span class="comment">//      int tm_mday;   /* Day of the month (1-31) */</span></span><br><span class="line"><span class="comment">//      int tm_mon;    /* Month (0-11) */</span></span><br><span class="line"><span class="comment">//      int tm_year;   /* Year - 1900 */</span></span><br><span class="line"><span class="comment">//      int tm_wday;   /* Day of the week (0-6, Sunday = 0) */</span></span><br><span class="line"><span class="comment">//      int tm_yday;   /* Day in the year (0-365, 1 Jan = 0) */</span></span><br><span class="line"><span class="comment">//      int tm_isdst;  /* Daylight saving time */</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> YR_Common::strTotm(<span class="keyword">const</span> <span class="built_in">string</span> &amp;sString, <span class="keyword">const</span> <span class="built_in">string</span> &amp;sFormat, struct tm &amp;stTm)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = strptime(sString.c_str(), sFormat.c_str(), &amp;stTm);</span><br><span class="line">    <span class="keyword">return</span> (p != <span class="literal">NULL</span>) ? <span class="number">0</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">string</span> YR_Common::tmTostr(<span class="keyword">const</span> struct tm &amp;stTm, <span class="keyword">const</span> <span class="built_in">string</span> &amp;sFormat)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> sTimeString[<span class="number">255</span>] = <span class="string">"\0"</span>;</span><br><span class="line">    strftime(sTimeString, <span class="keyword">sizeof</span>(sTimeString), sFormat.c_str(), &amp;stTm);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>(sTimeString);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">string</span> YR_Common::tmTostr(<span class="keyword">const</span> <span class="keyword">time_t</span> &amp;t, <span class="keyword">const</span> <span class="built_in">string</span> &amp;sFormat)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">tt</span>;</span></span><br><span class="line">    localtime_r(&amp;t, &amp;tt);</span><br><span class="line">    <span class="keyword">return</span> tmTostr(tt, sFormat);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">string</span> YR_Common::nowTostr(<span class="keyword">const</span> <span class="built_in">string</span> &amp;sFormat)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">time_t</span> t = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> tmTostr(t, sFormat.c_str());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原型：</span></span><br><span class="line"><span class="comment">// #include &lt;sys/time.h&gt;</span></span><br><span class="line"><span class="comment">//int gettimeofday(struct timeval *tv, struct timezone *tz);</span></span><br><span class="line"><span class="comment">//int settimeofday(const struct timeval *tv, const struct timezone *tz);</span></span><br><span class="line"><span class="comment">//struct timeval &#123;</span></span><br><span class="line"><span class="comment">//time_t      tv_sec;     /* seconds */</span></span><br><span class="line"><span class="comment">//suseconds_t tv_usec;    /* microseconds */</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int64_t</span> YR_Common::nowToms()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    gettimeofday(&amp;tv, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> tv.tv_sec * (<span class="keyword">int64_t</span>)<span class="number">1000</span> + tv.tv_usec/<span class="number">1000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int64_t</span> YR_Common::nowTous()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    gettimeofday(&amp;tv, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> tv.tv_sec * (<span class="keyword">int64_t</span>)<span class="number">1000000</span> + tv.tv_usec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>未完待续~</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;常用函数的封装&quot;&gt;&lt;a href=&quot;#常用函数的封装&quot; class=&quot;headerlink&quot; title=&quot;常用函数的封装&quot;&gt;&lt;/a&gt;常用函数的封装&lt;/h3&gt;&lt;p&gt;常用函数的封装：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字符串操作常用函数&lt;ul&gt;
&lt;li&gt;大小写转换函数&lt;/l
      
    
    </summary>
    
    
      <category term="-C++" scheme="http://yourenit.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>线程池的设计</title>
    <link href="http://yourenit.top/uncategorized/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yourenit.top/uncategorized/线程池的设计/</id>
    <published>2019-08-30T03:05:56.000Z</published>
    <updated>2019-09-03T03:58:58.156Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线程池的设计"><a href="#线程池的设计" class="headerlink" title="线程池的设计"></a>线程池的设计</h3><p>线程池，顾名思义就是一个存放了已经创建好的线程资源的池子，当有任务提交给线程池的时候，池中的某一个线程就会执行该任务，执行完毕之后就会回到池子中等待下次执行任务。</p><p><img src="E:\Blog\Hexo\source\_posts\picture\TIM图片20190903114333.png" alt=""></p><p>从上图中我们可以看到，实现一个线程池应该具备下列要素：</p><ul><li>线程队列：提交的任务缓冲在这里</li><li>线程数量管理功能</li><li>任务拒绝策略</li><li>队列长度</li></ul><h4 id="线程安全队列的封装"><a href="#线程安全队列的封装" class="headerlink" title="线程安全队列的封装"></a>线程安全队列的封装</h4><p><a href="">线程安全队列的封装</a></p><h4 id="线程池的定义"><a href="#线程池的定义" class="headerlink" title="线程池的定义"></a>线程池的定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YR_ThreadPool</span> :</span> <span class="keyword">public</span> YR_ThreadLock</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">YR_ThreadPool();</span><br><span class="line"><span class="keyword">virtual</span> ~YR_ThreadPool();</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程池的初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line"><span class="comment">//启动所有线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//终止线程池</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">terminate</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//获取线程数量</span></span><br><span class="line"><span class="keyword">size_t</span> getThreadNum() <span class="keyword">const</span>;</span><br><span class="line"><span class="comment">//获取线程池的任务数量</span></span><br><span class="line"><span class="keyword">size_t</span> getThreadJobNum() <span class="keyword">const</span>;</span><br><span class="line"><span class="comment">//添加任务</span></span><br><span class="line">bool Execute(std::function&lt;void()&gt; tf);</span><br><span class="line"><span class="comment">//清除线程池</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//通知等待在任务队列的线程醒来</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notifyT</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//等待所有工作全部结束</span></span><br><span class="line"><span class="comment">//millsecond表示等待的时间</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">waitForAllDone</span><span class="params">(<span class="keyword">int</span> millsecond = <span class="number">-1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//线程中的工作线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YR_ThreadWorker</span> :</span> <span class="keyword">public</span> YR_Thread</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">YR_ThreadWorker(YR_ThreadPool *pool);</span><br><span class="line">~YR_ThreadWorker();</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;<span class="comment">//实现逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">terminate</span><span class="params">()</span></span>;<span class="comment">//线程终止</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">YR_ThreadPool*  _tpool;</span><br><span class="line"><span class="keyword">bool</span> _bTerminate;<span class="comment">//是否结束线程</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">YR_ThreadQueue&lt;<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt;&gt; _jobqueue;<span class="comment">//任务队列</span></span><br><span class="line">YR_ThreadLock_tmutex;<span class="comment">//任务队列的锁</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;YR_ThreadWorker*&gt;_jobthread;<span class="comment">//工作队列</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;YR_ThreadWorker*&gt;_busthread;<span class="comment">//繁忙线程</span></span><br><span class="line"><span class="keyword">bool</span> _bAllDone;<span class="comment">//是否所有任务执行完毕</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="线程池的实现"><a href="#线程池的实现" class="headerlink" title="线程池的实现"></a>线程池的实现</h4><h5 id="构造与析构"><a href="#构造与析构" class="headerlink" title="构造与析构"></a>构造与析构</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">YR_ThreadPool::YR_ThreadPool()</span><br><span class="line">    :bAllDone(<span class="literal">true</span>)</span><br><span class="line">&#123;&#125;</span><br><span class="line">YR_ThreadPool::~YR_ThreadPool()</span><br><span class="line">&#123;</span><br><span class="line">    terminate();</span><br><span class="line">    clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="线程池的初始化"><a href="#线程池的初始化" class="headerlink" title="线程池的初始化"></a>线程池的初始化</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> YR_ThreadPool::init(<span class="keyword">size_t</span> num)</span><br><span class="line">&#123;</span><br><span class="line">    terminate();</span><br><span class="line">    <span class="function">Lock <span class="title">sync</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    clear();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        _jobthread.push_back(<span class="keyword">new</span> ThreadWorker(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="启动所有线程"><a href="#启动所有线程" class="headerlink" title="启动所有线程"></a>启动所有线程</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> YR_ThreadPool::start()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">sync</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> it = _jobthread.begin();</span><br><span class="line">    <span class="keyword">while</span>(it != _jobthread.end())</span><br><span class="line">    &#123;</span><br><span class="line">        (*it)-&gt;start();</span><br><span class="line">        ++it;</span><br><span class="line">    &#125;</span><br><span class="line">    _bAllDone = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="终止线程池"><a href="#终止线程池" class="headerlink" title="终止线程池"></a>终止线程池</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> YR_ThreadPool::terminate()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">sync</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> it = _jobthread.begin();</span><br><span class="line">    <span class="keyword">while</span>(it != _jobthread.end())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((*it)-&gt;isAlive())</span><br><span class="line">        &#123;</span><br><span class="line">            (*it)-&gt;terminate();</span><br><span class="line">            (*it)-&gt;getThreadControl.join();<span class="comment">//线程回收</span></span><br><span class="line">        &#125;</span><br><span class="line">        ++it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="获取线程数数量"><a href="#获取线程数数量" class="headerlink" title="获取线程数数量"></a>获取线程数数量</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> YR_ThreadPool::getThreadNum()</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">Lock <span class="title">sync</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> _jobthread.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="获取线程池的任务数量"><a href="#获取线程池的任务数量" class="headerlink" title="获取线程池的任务数量"></a>获取线程池的任务数量</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> YR_ThreadPool::getThreadJobNum()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _jobqueue.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="添加任务"><a href="#添加任务" class="headerlink" title="添加任务"></a>添加任务</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> YR_ThreadPool::Execute(<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; tf)</span><br><span class="line">&#123;</span><br><span class="line">_jobqueue.push_back(<span class="built_in">std</span>::move(tf));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="清除线程池"><a href="#清除线程池" class="headerlink" title="清除线程池"></a>清除线程池</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> YR_ThreadPool::clear()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> it = _jobthread.begin();</span><br><span class="line">    <span class="keyword">while</span>(it != _jobthread.end())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>(*it);</span><br><span class="line">        ++it;</span><br><span class="line">    &#125;</span><br><span class="line">    _jobthread.clear();</span><br><span class="line">    _busthread.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="通知等待在工作队列的线程醒来"><a href="#通知等待在工作队列的线程醒来" class="headerlink" title="通知等待在工作队列的线程醒来"></a>通知等待在工作队列的线程醒来</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void YR_ThreadPool::notifyT()</span><br><span class="line">&#123;</span><br><span class="line">_jobqueue.notifyT();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="线程运行逻辑"><a href="#线程运行逻辑" class="headerlink" title="线程运行逻辑"></a>线程运行逻辑</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> YR_ThreadPool::ThreadWorker::run()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//调用初始化部分</span></span><br><span class="line">    <span class="keyword">auto</span> pst = _tpool-&gt;get();</span><br><span class="line">    <span class="keyword">if</span>(pst)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            pst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> ( ... )</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用处理部分</span></span><br><span class="line">    <span class="keyword">while</span> (!_bTerminate)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> pfw = _tpool-&gt;get(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span>(pfw)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                pfw();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> ( ... )</span><br><span class="line">            &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            _tpool-&gt;idle(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//结束</span></span><br><span class="line">    _tpool-&gt;<span class="built_in">exit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="工作线程终止"><a href="#工作线程终止" class="headerlink" title="工作线程终止"></a>工作线程终止</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> YR_ThreadPool::ThreadWorker::terminate()</span><br><span class="line">&#123;</span><br><span class="line">    _bTerminate = <span class="literal">true</span>;</span><br><span class="line">    _tpool-&gt;notifyT();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="等待所有工作全部结束"><a href="#等待所有工作全部结束" class="headerlink" title="等待所有工作全部结束"></a>等待所有工作全部结束</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> YR_ThreadPool::waitForAllDone(<span class="keyword">int</span> millsecond)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">sync</span><span class="params">(_tmutex)</span></span>;</span><br><span class="line">start1:</span><br><span class="line">    <span class="comment">//任务队列和繁忙线程都是空的</span></span><br><span class="line">    <span class="keyword">if</span> (finish())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//永远等待</span></span><br><span class="line">    <span class="keyword">if</span>(millsecond &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _tmutex.timedWait(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">goto</span> start1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int64_t</span> iNow= YR_Common::nowToms();</span><br><span class="line">    <span class="keyword">int</span> m       = millsecond;</span><br><span class="line">start2:</span><br><span class="line">    <span class="keyword">bool</span> b = _tmutex.timedWait(millsecond);</span><br><span class="line">    <span class="comment">//完成处理了</span></span><br><span class="line">    <span class="keyword">if</span>(finish())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    millsecond = max((<span class="keyword">int64_t</span>)<span class="number">0</span>, m  - (YR_Common::nowToms() - iNow));</span><br><span class="line">    <span class="keyword">goto</span> start2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线程存储"><a href="#线程存储" class="headerlink" title="线程存储"></a>线程存储</h4><p>“防止任务在共享资源上发生冲突的第二种方式是根除对变量的共享”。线程局部存储为每一个访问此变量的线程<strong>提供一个此变量独立的副本</strong>，线程可以修改此变量，而不会影响到其他线程。</p><h5 id="线程私有数据的封装"><a href="#线程私有数据的封装" class="headerlink" title="线程私有数据的封装"></a>线程私有数据的封装</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ThreadData()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">ThreadData</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">static</span> <span class="title">T</span>* <span class="title">makeThreadData</span>()&#123;</span> <span class="keyword">return</span> <span class="keyword">new</span> T;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>YR_ThreadPool</code>类中添加<code>pthread_key_t  g_key</code>属性。</p><p><code>YR_ThreadPool</code>类中添加<code>static void destructor(void *p);</code>方法，用来销毁线程数据。</p><h5 id="线程池中添加线程私有数据的操作方法"><a href="#线程池中添加线程私有数据的操作方法" class="headerlink" title="线程池中添加线程私有数据的操作方法"></a>线程池中添加线程私有数据的操作方法</h5><p>线程存储的操作方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns 0 on success, or a positive error number on error</span></span><br><span class="line">int pthread_key_create (pthread_key_t *key, void (*destructor)(void *));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns 0 on success, or a positive error number on error</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_key_delete</span> <span class="params">(<span class="keyword">pthread_key_t</span> key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns 0 on success, or a positive error number on error</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setspecific</span> <span class="params">(<span class="keyword">pthread_key_t</span> key, <span class="keyword">const</span> <span class="keyword">void</span> *value)</span></span>;</span><br><span class="line"><span class="comment">//该函数将value的值（不是内容）与key相关联。用pthread_setspecific为一个键指定新的线程数据时，线程必须先释放原有的线程数据用以回收空间。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns pointer, or NULL if no thread-specific data is associated with key</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">pthread_getspecific</span> <span class="params">(<span class="keyword">pthread_key_t</span> key)</span></span>;</span><br></pre></td></tr></table></figure><p>原理参考：<a href="https://blog.csdn.net/caoyan_12727/article/details/52280604" target="_blank" rel="noopener">linux线程私有数据详解</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setThreadData</span><span class="params">(ThreadData *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//释放原有的线程数据</span></span><br><span class="line">    YR_ThreadPool::ThreadData *pOld = getThreadData();</span><br><span class="line">    <span class="keyword">if</span>(pOld != <span class="literal">NULL</span> &amp;&amp; pOld != p)</span><br><span class="line">        <span class="keyword">delete</span> pOld;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ret = pthread_setspecific(g_key, (<span class="keyword">void</span>*)p);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> YR_ThreadPool_Exception(<span class="string">"[YR_ThreadPool::setThreadData] pthread_setspecific error"</span>,ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setThreadData</span><span class="params">(<span class="keyword">pthread_key_t</span> pkey, ThreadData *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//释放原有的线程数据</span></span><br><span class="line">    YR_ThreadPool::ThreadData *pOld = getThreadData(pkey);</span><br><span class="line">    <span class="keyword">if</span>(pOld != <span class="literal">NULL</span> &amp;&amp; pOld != p)</span><br><span class="line">        <span class="keyword">delete</span> pOld;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ret = pthread_setspecific(pkey, (<span class="keyword">void</span> *)p);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> YR_ThreadPool_Exception(<span class="string">"[YR_ThreadPool::setThreadData] pthread_setspecific error"</span>, ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> ThreadData* <span class="title">getThreadData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (ThreadData*)pthread_getspecific(g_key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> ThreadData* <span class="title">getThreadData</span><span class="params">(<span class="keyword">pthread_key_t</span> pkey)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (ThreadData*)pthread_getspecific(pkey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">destructor</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ThreadData* ttd = (ThreadData*)p;</span><br><span class="line">    <span class="keyword">delete</span> ttd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="key的初始化"><a href="#key的初始化" class="headerlink" title="key的初始化"></a>key的初始化</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KeyInitialize</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//初始化key</span></span><br><span class="line">KeyInitialize()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> ret = pthread_key_create(&amp;YR_ThreadPool::g_key, YR_ThreadPool::destructor);</span><br><span class="line"><span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> YR_ThreadPool_Exception(<span class="string">"[YR_ThreadPool::KeyInitialize] pthread_key_create error"</span>, ret);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放key</span></span><br><span class="line">    ~KeyInitialize()</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_key_delete(YR_ThreadPool::g_key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>YR_ThreadPool</code>添加<code>static KeyInitialize g_key_initialize</code>属性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;线程池的设计&quot;&gt;&lt;a href=&quot;#线程池的设计&quot; class=&quot;headerlink&quot; title=&quot;线程池的设计&quot;&gt;&lt;/a&gt;线程池的设计&lt;/h3&gt;&lt;p&gt;线程池，顾名思义就是一个存放了已经创建好的线程资源的池子，当有任务提交给线程池的时候，池中的某一个线程就会执
      
    
    </summary>
    
    
      <category term="-C++" scheme="http://yourenit.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>线程队列的封装</title>
    <link href="http://yourenit.top/uncategorized/%E7%BA%BF%E7%A8%8B%E9%98%9F%E5%88%97%E7%9A%84%E5%B0%81%E8%A3%85/"/>
    <id>http://yourenit.top/uncategorized/线程队列的封装/</id>
    <published>2019-08-30T02:52:28.000Z</published>
    <updated>2019-09-03T03:59:02.595Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线程队列的封装"><a href="#线程队列的封装" class="headerlink" title="线程队列的封装"></a>线程队列的封装</h3><p>C++中虽然有std::queue、std::deque这些队列容器，但是不是线程安全的，因此我们需要封装一个线程安全的线程队列。</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Container</span> = <span class="title">std</span>:</span>:<span class="built_in">queue</span>&lt;T&gt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YR_Thread_Queue</span> :</span> <span class="keyword">protected</span> YR_ThreadLock</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> Container queue_type;</span><br><span class="line">YR_Thread_Queue() : _size(<span class="number">0</span>)&#123; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">(<span class="keyword">const</span> T&amp; t)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">(<span class="keyword">const</span> queue_type&amp; qt)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; t)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> queue_type&amp; qt)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从头部获取数据，没有数据则等待</span></span><br><span class="line">    <span class="comment">//millsecond为阻塞等待时间,0为不阻塞，-1为永久等待</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">pop_front</span><span class="params">(T&amp; t, <span class="keyword">int</span> millsecond = <span class="number">0</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">size_t</span> size() <span class="keyword">const</span> &#123; <span class="function">Lock <span class="title">lock</span><span class="params">(*<span class="keyword">this</span>)</span></span>; <span class="keyword">return</span> _size;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; <span class="function">Lock <span class="title">lock</span><span class="params">(*<span class="keyword">this</span>)</span></span>; _queue.clear();_size=<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123; <span class="function">Lock <span class="title">lock</span><span class="params">(*<span class="keyword">this</span>)</span></span>; <span class="keyword">return</span> _queue.empty();&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//队列</span></span><br><span class="line">queue_type _queue;</span><br><span class="line">    <span class="comment">//队列长度</span></span><br><span class="line">    <span class="keyword">size_t</span> _size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="push-back"><a href="#push-back" class="headerlink" title="push_back"></a>push_back</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Container</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">YR_Thread_Queue</span>&lt;T,Container&gt;:</span>:push_back(<span class="keyword">const</span> T&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在queue的push_back函数前加锁保证线程安全</span></span><br><span class="line">    <span class="comment">//构造加锁，析构解锁</span></span><br><span class="line"><span class="function">Lock <span class="title">lock</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">notify();</span><br><span class="line">_queue.push_back(t);</span><br><span class="line">++_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Container</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">YR_Thread_Queue</span>&lt;T,Container&gt;:</span>:push_back(<span class="keyword">const</span> queue_type&amp; qt)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">lock</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> it = qt.begin();</span><br><span class="line">    <span class="keyword">auto</span> end = qt.end();</span><br><span class="line">    <span class="keyword">while</span>(it != end)</span><br><span class="line">    &#123;</span><br><span class="line">        notify();</span><br><span class="line">        _queue.push_back(*it);</span><br><span class="line">        ++it;</span><br><span class="line">        ++_size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="push-front"><a href="#push-front" class="headerlink" title="push_front"></a>push_front</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Container&gt;</span><br><span class="line"><span class="keyword">void</span> YR_ThreadQueue&lt;T, Container&gt;::push_front(<span class="keyword">const</span> T&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">lock</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    notify();</span><br><span class="line">    _queue.push_front(t);</span><br><span class="line">    ++_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Container</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">YR_Thread_Queue</span>&lt;T,Container&gt;:</span>:push_front(<span class="keyword">const</span> queue_type&amp; qt)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">lock</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> it = qt.begin();</span><br><span class="line">    <span class="keyword">auto</span> end = qt.end();</span><br><span class="line">    <span class="keyword">while</span>(it != end)</span><br><span class="line">    &#123;</span><br><span class="line">        notify();</span><br><span class="line">        _queue.push_front(*it);</span><br><span class="line">        ++it;</span><br><span class="line">        ++_size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Container</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">YR_Thread_Queue</span>&lt;T,Container&gt;:</span>:pop_front(T&amp; t, <span class="keyword">int</span> millsecond)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">lock</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(_queue.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(millsecond == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(millsecond == (<span class="keyword">size_t</span>)<span class="number">-1</span>)</span><br><span class="line">            wait();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!timeWait(millsecond))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(_queue.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    t= _queue.front();</span><br><span class="line">    _queue.pop_front();</span><br><span class="line">    assert(_size &gt; <span class="number">0</span>);</span><br><span class="line">    --_size();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;线程队列的封装&quot;&gt;&lt;a href=&quot;#线程队列的封装&quot; class=&quot;headerlink&quot; title=&quot;线程队列的封装&quot;&gt;&lt;/a&gt;线程队列的封装&lt;/h3&gt;&lt;p&gt;C++中虽然有std::queue、std::deque这些队列容器，但是不是线程安全的，因此我们需
      
    
    </summary>
    
    
      <category term="-C++" scheme="http://yourenit.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>线程控制类的封装</title>
    <link href="http://yourenit.top/uncategorized/%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85/"/>
    <id>http://yourenit.top/uncategorized/线程控制类的封装/</id>
    <published>2019-08-28T08:59:44.000Z</published>
    <updated>2019-09-03T03:59:05.489Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线程控制类的封装"><a href="#线程控制类的封装" class="headerlink" title="线程控制类的封装"></a>线程控制类的封装</h3><h4 id="线程常用方法"><a href="#线程常用方法" class="headerlink" title="线程常用方法"></a>线程常用方法</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span> **retval)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br><span class="line"><span class="keyword">pthread_t</span> pthread_self(<span class="keyword">void</span>);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *thread, <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr,</span></span></span><br><span class="line">                          void *(*start_routine) (void *), void *arg);</span><br></pre></td></tr></table></figure><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief  线程控制异常类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">YR_ThreadThreadControl_Exception</span> :</span> <span class="keyword">public</span> YR_Exception</span><br><span class="line">&#123;</span><br><span class="line">   YR_ThreadThreadControl_Exception(<span class="keyword">const</span> <span class="built_in">string</span> &amp;buffer) : YR_Exception(buffer)&#123;&#125;;</span><br><span class="line">    YR_ThreadThreadControl_Exception(<span class="keyword">const</span> <span class="built_in">string</span> &amp;buffer, <span class="keyword">int</span> err) : YR_Exception(buffer, err)&#123;&#125;;</span><br><span class="line">    ~YR_ThreadThreadControl_Exception() <span class="keyword">throw</span>() &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief  线程控制类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YR_ThreadControl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief  构造, 表示当前运行的线程，</span></span><br><span class="line"><span class="comment">     *          join和detach在不能在该对象上调用</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    YR_ThreadControl();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @return explicit</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">YR_ThreadControl</span><span class="params">(<span class="keyword">pthread_t</span>)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief  等待当前线程结束, 不能在当前线程上调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief  detach, 不能在当前线程上调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">detach</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief  获取当前线程id.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return pthread_t当前线程id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">pthread_t</span> id() <span class="keyword">const</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief  休息ms时间. </span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * @param millsecond 休息的时间，具体ms数字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millsecond)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief  交出当前线程控制权</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">pthread_t</span> _thread;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="构造和析构"><a href="#构造和析构" class="headerlink" title="构造和析构"></a>构造和析构</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">YR_ThreadControl::YR_ThreadControl(<span class="keyword">pthread_t</span> thread) : _thread(thread)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">YR_ThreadControl::YR_ThreadControl() : _thread(pthread_self())</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="控制方法"><a href="#控制方法" class="headerlink" title="控制方法"></a>控制方法</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> YR_ThreadControl::join()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(pthread_self() == _thread)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> YR_ThreadThreadControl_Exception(<span class="string">"[YR_ThreadControl::join] can't be called in the same thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>* ignore = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rc = pthread_join(_thread, &amp;ignore);</span><br><span class="line">    <span class="keyword">if</span>(rc != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> YR_ThreadThreadControl_Exception(<span class="string">"[YR_ThreadControl::join] pthread_join error "</span>, rc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> YR_ThreadControl::detach()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(pthread_self() == _thread)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> YR_ThreadThreadControl_Exception(<span class="string">"[YR_ThreadControl::join] can't be called in the same thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rc = pthread_detach(_thread);</span><br><span class="line">    <span class="keyword">if</span>(rc != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> YR_ThreadThreadControl_Exception(<span class="string">"[YR_ThreadControl::join] pthread_join error"</span>, rc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_t</span> YR_ThreadControl::id() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _thread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> YR_ThreadControl::sleep(<span class="keyword">long</span> millsecond)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">ts</span>;</span></span><br><span class="line">    ts.tv_sec = millsecond / <span class="number">1000</span>;</span><br><span class="line">    ts.tv_nsec = (millsecond % <span class="number">1000</span>)*<span class="number">1000000</span>;</span><br><span class="line">    nanosleep(&amp;ts, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> YR_ThreadControl::yield()</span><br><span class="line">&#123;</span><br><span class="line">    sched_yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线程基类的定义"><a href="#线程基类的定义" class="headerlink" title="线程基类的定义"></a>线程基类的定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YR_Runable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~YR_Runable()&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 线程基类. </span></span><br><span class="line"><span class="comment"> * 线程基类，所有自定义线程继承于该类，同时实现run接口即可, </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * 可以通过YR_ThreadContorl管理线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YR_Thread</span> :</span> <span class="keyword">public</span> YR_Runable</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    YR_Thread();</span><br><span class="line">    <span class="keyword">virtual</span> ~YR_Thread()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief  线程运行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">YR_ThreadControl <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief  获取线程控制类.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return ThreadControl</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">YR_ThreadControl <span class="title">getThreadControl</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief  线程是否存活.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return bool 存活返回true，否则返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAlive</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief  获取线程id.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return pthread_t 线程id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">pthread_t</span> id() &#123; <span class="keyword">return</span> _tid; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief  静态函数, 线程入口. </span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * @param pThread 线程对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">threadEntry</span><span class="params">(YR_Thread *pThread)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief  运行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否在运行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">bool</span>            _running;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">pthread_t</span>        _tid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通线程锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    YR_ThreadLock   _lock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><h5 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">YR_Thread::YR_Thread() : _running(<span class="literal">false</span>),_tid(<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="线程入口"><a href="#线程入口" class="headerlink" title="线程入口"></a>线程入口</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> YR_Thread::threadEntry(YR_Thread *pThread)</span><br><span class="line">&#123;</span><br><span class="line">    pThread-&gt;_running = <span class="literal">true</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//YR_ThreadLock::Lock -&gt; </span></span><br><span class="line">        <span class="comment">//YR_Monitor&lt;YR_ThreadMutex, YR_ThreadCond&gt;::YR_LockT&lt;YR_Monitor&lt;YR_ThreadMutex, </span></span><br><span class="line">        <span class="comment">//YR_ThreadCond&gt;&gt;</span></span><br><span class="line">        <span class="comment">//构造时加锁，析构时解锁</span></span><br><span class="line">        YR_ThreadLock::<span class="function">Lock <span class="title">sync</span><span class="params">(pThread-&gt;_lock)</span></span>;</span><br><span class="line">        pThread-&gt;_lock.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        pThread-&gt;run();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(...)</span><br><span class="line">    &#123;</span><br><span class="line">        pThread-&gt;_running = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pThread-&gt;_running = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="线程启动"><a href="#线程启动" class="headerlink" title="线程启动"></a>线程启动</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">YR_ThreadControl YR_Thread::start()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//构造时加锁，析构时解锁</span></span><br><span class="line">    YR_ThreadLock::<span class="function">Lock <span class="title">sync</span><span class="params">(_lock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(_running)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> YR_ThreadThreadControl_Exception(<span class="string">"[YR_Thread::start] thread has start"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create(&amp;_tid,</span><br><span class="line">                   <span class="number">0</span>,</span><br><span class="line">                   (<span class="keyword">void</span> *(*)(<span class="keyword">void</span> *))&amp;threadEntry,</span><br><span class="line">                   (<span class="keyword">void</span> *)<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> YR_ThreadThreadControl_Exception(<span class="string">"[YR_Thread::start] thread start error"</span>, ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _lock.wait();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> YR_ThreadControl(_tid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="其他函数实现"><a href="#其他函数实现" class="headerlink" title="其他函数实现"></a>其他函数实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">YR_ThreadControl YR_Thread::getThreadControl() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> YR_ThreadControl(_tid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> YR_Thread::isAlive() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _running;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;线程控制类的封装&quot;&gt;&lt;a href=&quot;#线程控制类的封装&quot; class=&quot;headerlink&quot; title=&quot;线程控制类的封装&quot;&gt;&lt;/a&gt;线程控制类的封装&lt;/h3&gt;&lt;h4 id=&quot;线程常用方法&quot;&gt;&lt;a href=&quot;#线程常用方法&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="-C++" scheme="http://yourenit.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>线程信号类的封装</title>
    <link href="http://yourenit.top/uncategorized/%E7%BA%BF%E7%A8%8B%E6%9D%A1%E4%BB%B6%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85/"/>
    <id>http://yourenit.top/uncategorized/线程条件类的封装/</id>
    <published>2019-08-28T01:14:00.000Z</published>
    <updated>2019-09-03T03:59:15.896Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线程条件类的封装"><a href="#线程条件类的封装" class="headerlink" title="线程条件类的封装"></a>线程条件类的封装</h3><h4 id="线程条件的基本操作"><a href="#线程条件的基本操作" class="headerlink" title="线程条件的基本操作"></a>线程条件的基本操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">//条件的销毁和初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程条件等待</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span></span>;</span><br><span class="line"><span class="comment">//带有超时等待的函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timedwait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">const</span> struct timespec *<span class="keyword">restrict</span> abstime)</span></span>;</span><br><span class="line"><span class="comment">//线程唤醒</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="线程条件类的定义"><a href="#线程条件类的定义" class="headerlink" title="线程条件类的定义"></a>线程条件类的定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程信号异常类</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">YR_ThreadCond_Exception</span> :</span> <span class="keyword">public</span> YR_Exception</span><br><span class="line">&#123;</span><br><span class="line">    YR_ThreadCond_Exception(<span class="keyword">const</span> <span class="built_in">string</span> &amp;buffer) : YR_Exception(buffer)&#123;&#125;;</span><br><span class="line">    YR_ThreadCond_Exception(<span class="keyword">const</span> <span class="built_in">string</span> &amp;buffer, <span class="keyword">int</span> err) : YR_Exception(buffer, err)&#123;&#125;;</span><br><span class="line">    ~YR_ThreadCond_Exception() <span class="keyword">throw</span>() &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程信号类，所有锁在上面等待信号发生</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YR_ThreadCond</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    YR_ThreadCond();</span><br><span class="line">    ~YR_ThreadCond();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  @brief 发送信号, 等待在该条件上的一个线程会醒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  @brief 等待在该条件的所有线程都会醒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">broadcast</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  @brief 获取绝对等待时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">timespec <span class="title">abstime</span><span class="params">(<span class="keyword">int</span> millsecond)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  @brief 无限制等待.</span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * @param M</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Mutex&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">const</span> Mutex&amp; mutex)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = mutex.count();</span><br><span class="line">        <span class="keyword">int</span> rc = pthread_cond_wait(&amp;_cond, &amp;mutex._mutex);</span><br><span class="line">        mutex.count(c);</span><br><span class="line">        <span class="keyword">if</span>(rc != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> YR_ThreadCond_Exception(<span class="string">"[YR_ThreadCond::wait] pthread_cond_wait error"</span>, errno);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 等待时间. </span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * @param M </span></span><br><span class="line"><span class="comment">     * @return bool, false表示超时, true:表示有事件来了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Mutex&gt;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">timedWait</span><span class="params">(<span class="keyword">const</span> Mutex&amp; mutex, <span class="keyword">int</span> millsecond)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = mutex.count();</span><br><span class="line">        timespec ts = abstime(millsecond);</span><br><span class="line">        <span class="keyword">int</span> rc = pthread_cond_timedwait(&amp;_cond, &amp;mutex._mutex, &amp;ts);</span><br><span class="line">        mutex.count(c);</span><br><span class="line">        <span class="keyword">if</span>(rc != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(rc != ETIMEDOUT)<span class="comment">//如果超时</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> YR_ThreadCond_Exception(<span class="string">"[YR_ThreadCond::timedWait] pthread_cond_timedwait error"</span>, errno);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    YR_ThreadCond(<span class="keyword">const</span> YR_ThreadCond&amp;);</span><br><span class="line">    YR_ThreadCond&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> YR_ThreadCond&amp;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程条件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">pthread_cond_t</span> _cond;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="构造与析构"><a href="#构造与析构" class="headerlink" title="构造与析构"></a>构造与析构</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">YR_ThreadCond::YR_ThreadCond()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> rc;</span><br><span class="line">    <span class="keyword">pthread_condattr_t</span> attr;<span class="comment">//定义条件属性对象</span></span><br><span class="line">    rc = pthread_condattr_init(&amp;attr);<span class="comment">//1. 初始化条件属性对象</span></span><br><span class="line">    <span class="keyword">if</span>(rc != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> YR_ThreadCond_Exception(<span class="string">"[YR_ThreadCond::YR_ThreadCond] pthread_condattr_init error"</span>, errno);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rc = pthread_cond_init(&amp;_cond, &amp;attr);<span class="comment">//2. 初始化条件</span></span><br><span class="line">    <span class="keyword">if</span>(rc != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> YR_ThreadCond_Exception(<span class="string">"[YR_ThreadCond::YR_ThreadCond] pthread_cond_init error"</span>, errno);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rc = pthread_condattr_destroy(&amp;attr);<span class="comment">//3. 销毁条件属性对象</span></span><br><span class="line">    <span class="keyword">if</span>(rc != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> YR_ThreadCond_Exception(<span class="string">"[YR_ThreadCond::YR_ThreadCond] pthread_condattr_destroy error"</span>, errno);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">YR_ThreadCond::~YR_ThreadCond()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> rc = <span class="number">0</span>;</span><br><span class="line">    rc = pthread_cond_destroy(&amp;_cond);</span><br><span class="line">    <span class="keyword">if</span>(rc != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"[YR_ThreadCond::~YR_ThreadCond] pthread_cond_destroy error:"</span> &lt;&lt; <span class="built_in">string</span>(strerror(rc)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="唤醒线程"><a href="#唤醒线程" class="headerlink" title="唤醒线程"></a>唤醒线程</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> YR_ThreadCond::signal()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> rc = pthread_cond_signal(&amp;_cond);</span><br><span class="line">    <span class="keyword">if</span>(rc != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> YR_ThreadCond_Exception(<span class="string">"[YR_ThreadCond::signal] pthread_cond_signal error"</span>, errno);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> YR_ThreadCond::broadcast()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> rc = pthread_cond_broadcast(&amp;_cond);</span><br><span class="line">    <span class="keyword">if</span>(rc != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> YR_ThreadCond_Exception(<span class="string">"[YR_ThreadCond::broadcast] pthread_cond_broadcast error"</span>, errno);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="获取绝对等待时间（精度为纳秒）"><a href="#获取绝对等待时间（精度为纳秒）" class="headerlink" title="获取绝对等待时间（精度为纳秒）"></a>获取绝对等待时间（精度为纳秒）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">timespec YR_ThreadCond::abstime( <span class="keyword">int</span> millsecond) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    gettimeofday(&amp;tv, <span class="number">0</span>);<span class="comment">//时间操作将会被封装，如下注释</span></span><br><span class="line">    <span class="comment">//TC_TimeProvider::getInstance()-&gt;getNow(&amp;tv);</span></span><br><span class="line">    <span class="comment">//it 精度为微秒</span></span><br><span class="line">    <span class="keyword">int64_t</span> it  = tv.tv_sec * (<span class="keyword">int64_t</span>)<span class="number">1000000</span> + tv.tv_usec + (<span class="keyword">int64_t</span>)millsecond * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    tv.tv_sec   = it / (<span class="keyword">int64_t</span>)<span class="number">1000000</span>;</span><br><span class="line">    tv.tv_usec  = it % (<span class="keyword">int64_t</span>)<span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line">    timespec ts;</span><br><span class="line">    ts.tv_sec   = tv.tv_sec;</span><br><span class="line">    ts.tv_nsec  = tv.tv_usec * <span class="number">1000</span>; </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> ts; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注：timeval的最高精度为微秒，timespec的最高精度为纳秒</span></span><br><span class="line"><span class="comment">//timeval由gettimeofday()获取系统时间</span></span><br><span class="line"><span class="comment">//  timespec由clock_gettime(clockid_t, struct timespec *)获取特定时间</span></span><br><span class="line"><span class="comment">//CLOCK_REALTIME 统当前时间，从1970年1.1日算起</span></span><br><span class="line"><span class="comment">//CLOCK_MONOTONIC 系统的启动时间，不能被设置</span></span><br><span class="line"><span class="comment">//CLOCK_PROCESS_CPUTIME_ID 本进程运行时间</span></span><br><span class="line"><span class="comment">//CLOCK_THREAD_CPUTIME_ID 本线程运行时间</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;线程条件类的封装&quot;&gt;&lt;a href=&quot;#线程条件类的封装&quot; class=&quot;headerlink&quot; title=&quot;线程条件类的封装&quot;&gt;&lt;/a&gt;线程条件类的封装&lt;/h3&gt;&lt;h4 id=&quot;线程条件的基本操作&quot;&gt;&lt;a href=&quot;#线程条件的基本操作&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="-C++" scheme="http://yourenit.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>线程控制类的封装</title>
    <link href="http://yourenit.top/uncategorized/%E7%BA%BF%E7%A8%8B%E9%94%81%E7%9B%91%E6%8E%A7%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85/"/>
    <id>http://yourenit.top/uncategorized/线程锁监控类的封装/</id>
    <published>2019-08-28T01:11:52.000Z</published>
    <updated>2019-09-03T03:59:13.242Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线程锁监控类的封装"><a href="#线程锁监控类的封装" class="headerlink" title="线程锁监控类的封装"></a>线程锁监控类的封装</h3><p>互斥锁一个明显的缺点是它只有两种状态：锁定和非锁定。而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，它常和互斥锁一起配合使用。使用时，条件变量被用来阻塞一个线程，当条件不满足时，线程往往解开相应的互斥锁并等待条件发生变化。一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。这些线程将重新锁定互斥锁并重新测试条件是否满足。一般说来，条件变量被用来进行线程间的同步。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 通常线程锁，都通过该类来使用，而不是直接用YR_ThreadMutex、YR_ThreadRecMutex </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * 该类将YR_ThreadMutex/YR_ThreadRecMutex 与YR_ThreadCond结合起来； */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">P</span>&gt;//<span class="title">T</span>为线程锁类型，<span class="title">P</span>为线程条件类型</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">YR_Monitor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 定义锁控制对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">typedef</span> YR_LockT&lt;TC_Monitor&lt;T, P&gt; &gt; Lock;</span><br><span class="line">    <span class="comment">//typedef YR_TryLockT&lt;TC_Monitor&lt;T, P&gt; &gt; TryLock;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    YR_Monitor() : _nnotify(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 析够</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">virtual</span> ~YR_Monitor()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _mutex.lock();</span><br><span class="line">        _nnotify = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 解锁, 根据上锁的次数通知</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        notifyImpl(_nnotify);</span><br><span class="line">        _mutex.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 尝试锁.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return bool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">tryLock</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> result = _mutex.tryLock();</span><br><span class="line">        <span class="keyword">if</span>(result)</span><br><span class="line">        &#123;</span><br><span class="line">            _nnotify = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 等待,当前调用线程在锁上等待，直到事件通知，</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        notifyImpl(_nnotify);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            _cond.wait(_mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(...)</span><br><span class="line">        &#123;</span><br><span class="line">            _nnotify = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">throw</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _nnotify = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 等待时间,当前调用线程在锁上等待，直到超时或有事件通知</span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * @param millsecond 等待时间</span></span><br><span class="line"><span class="comment">     * @return           false:超时了, ture:有事件来了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">timedWait</span><span class="params">(<span class="keyword">int</span> millsecond)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        notifyImpl(_nnotify);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> rc;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            rc = _cond.timedWait(_mutex, millsecond);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(...)</span><br><span class="line">        &#123;</span><br><span class="line">            _nnotify = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">throw</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _nnotify = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> rc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 通知某一个线程醒来 </span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * 通知等待在该锁上某一个线程醒过来 ,调用该函数之前必须加锁, </span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * 在解锁的时候才真正通知 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(_nnotify != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++_nnotify;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 通知等待在该锁上的所有线程醒过来，</span></span><br><span class="line"><span class="comment">     * 注意调用该函数时必须已经获得锁.</span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * 该函数调用前之必须加锁, 在解锁的时候才真正通知 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _nnotify = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 通知实现. </span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * @param nnotify 上锁的次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyImpl</span><span class="params">(<span class="keyword">int</span> nnotify)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nnotify != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nnotify == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                _cond.broadcast();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(nnotify &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    _cond.signal();</span><br><span class="line">                    --nnotify;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    YR_Monitor(<span class="keyword">const</span> YR_Monitor&amp;);</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> YR_Monitor&amp;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">int</span>     _nnotify;<span class="comment">//上锁的次数</span></span><br><span class="line">    <span class="keyword">mutable</span> P       _cond;</span><br><span class="line">    T               _mutex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通线程锁</span></span><br><span class="line"><span class="keyword">typedef</span> YR_Monitor&lt;YR_ThreadMutex, YR_ThreadCond&gt; YR_ThreadLock;</span><br><span class="line"><span class="comment">//循环锁(一个线程可以加多次锁)</span></span><br><span class="line"><span class="keyword">typedef</span> YR_Monitor&lt;YR_ThreadRecMutex, YR_ThreadCond&gt; YR_ThreadRecLock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里互斥锁和条件变量的配合使用是下面的模式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_lock</span><br><span class="line">...</span><br><span class="line">pthread_cond_signal</span><br><span class="line">pthread_mutex_unlock</span><br></pre></td></tr></table></figure><p>原因：详见参考</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/FlayHigherGT/article/details/83790972" target="_blank" rel="noopener">浅谈互斥锁为什么还要和条件变量配合使用</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;线程锁监控类的封装&quot;&gt;&lt;a href=&quot;#线程锁监控类的封装&quot; class=&quot;headerlink&quot; title=&quot;线程锁监控类的封装&quot;&gt;&lt;/a&gt;线程锁监控类的封装&lt;/h3&gt;&lt;p&gt;互斥锁一个明显的缺点是它只有两种状态：锁定和非锁定。而条件变量通过允许线程阻塞和等待
      
    
    </summary>
    
    
      <category term="-C++" scheme="http://yourenit.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>线程锁的封装</title>
    <link href="http://yourenit.top/uncategorized/%E7%BA%BF%E7%A8%8B%E9%94%81%E7%9A%84%E5%B0%81%E8%A3%85/"/>
    <id>http://yourenit.top/uncategorized/线程锁的封装/</id>
    <published>2019-08-26T04:06:28.000Z</published>
    <updated>2019-08-28T08:58:54.327Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程锁的封装"><a href="#线程锁的封装" class="headerlink" title="线程锁的封装"></a>线程锁的封装</h2><h3 id="线程锁的基本操作："><a href="#线程锁的基本操作：" class="headerlink" title="线程锁的基本操作："></a>线程锁的基本操作：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 创建锁 <span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span>*mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> * attr)</span></span>;</span><br><span class="line">    attr：创建锁的属性。一般默认为<span class="literal">NULL</span>，分为以下几个属性：</span><br><span class="line">        * PTHREAD_MUTEX_TIMED_NP，这是缺省值，也就是普通锁。当一个线程加锁以后，其余请求锁的线程将形成一个等待队列，并在解锁后按优先级获得锁。这种锁策略保证了资源分配的公平性；</span><br><span class="line">        * PTHREAD_MUTEX_RECURSIVE_NP，嵌套锁，允许同一个线程对同一个锁成功获得多次，并通过多次unlock解锁。如果是不同线程请求，则在加锁线程解锁时重新竞争；</span><br><span class="line">        * PTHREAD_MUTEX_ERRORCHECK_NP，检错锁，如果同一个线程请求同一个锁，则返回EDEADLK，否则与PTHREAD_MUTEX_TIMED_NP类型动作相同。这样就保证当不允许多次加锁时不会出现最简单情况下的死锁；</span><br><span class="line">        * PTHREAD_MUTEX_ADAPTIVE_NP，适应锁，动作最简单的锁类型，仅等待解锁后重新竞争；</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.</span> 加锁 <span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span>*mutex)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.</span> 解锁 <span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4.</span> 尝试锁 <span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>; <span class="comment">//锁被占用返回EBUSY，而非等待</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5.</span> 锁销毁 <span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_destroy</span> <span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="线程锁的封装-1"><a href="#线程锁的封装-1" class="headerlink" title="线程锁的封装"></a>线程锁的封装</h3><h4 id="线程锁异常"><a href="#线程锁异常" class="headerlink" title="线程锁异常"></a>线程锁异常</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">YR_ThreadMutex_Exception</span> :</span> <span class="keyword">public</span> YR_Lock_Exception</span><br><span class="line">&#123;</span><br><span class="line">    YR_ThreadMutex_Exception(<span class="keyword">const</span> <span class="built_in">string</span> &amp;buffer) : YR_Lock_Exception(buffer)&#123;&#125;;</span><br><span class="line">    YR_ThreadMutex_Exception(<span class="keyword">const</span> <span class="built_in">string</span> &amp;buffer, <span class="keyword">int</span> err) : YR_Lock_Exception(buffer, err)&#123;&#125;;</span><br><span class="line">    ~YR_ThreadMutex_Exception() <span class="keyword">throw</span>() &#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="线程锁的定义"><a href="#线程锁的定义" class="headerlink" title="线程锁的定义"></a>线程锁的定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YR_ThreadMutex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">YR_ThreadMutex();</span><br><span class="line">    <span class="keyword">virtual</span> ~YR_ThreadMutex();</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//解锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//尝试锁</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">tryLock</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">pthread_mutex_t</span> _mutex;<span class="comment">//创建线程锁</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>锁的初始化可以放在构造函数里，这里分为四步来初始化线程锁<code>_mutex</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">YR_ThreadMutex::YR_ThreadMutex()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> rc;</span><br><span class="line">    <span class="keyword">pthread_mutexattr_t</span> attr;<span class="comment">//1. 创建线程锁属性对象</span></span><br><span class="line">    rc = pthread_mutexattr_init(&amp;attr);<span class="comment">//初始化锁属性对象</span></span><br><span class="line">    assert(rc == <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 将锁属性中的锁类型设为检错锁</span></span><br><span class="line">    rc = pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_ERRORCHECK);</span><br><span class="line">    assert(rc == <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. 初始化锁对象</span></span><br><span class="line">    rc = pthread_mutex_init(&amp;_mutex, &amp;attr);</span><br><span class="line">    assert(rc == <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4. 销毁锁属性对象</span></span><br><span class="line">    rc = pthread_mutexattr_destroy(&amp;attr);</span><br><span class="line">    assert(rc == <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果操作不成功，则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span>(rc != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> TC_ThreadMutex_Exception(<span class="string">"[TC_ThreadMutex::TC_ThreadMutex] pthread_mutexattr_init error"</span>, rc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程锁在析构函数中销毁：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">YR_ThreadMutex::~YR_ThreadMutex()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> rc = <span class="number">0</span>;</span><br><span class="line">    rc = pthread_mutex_destroy(&amp;_mutex);</span><br><span class="line">    <span class="keyword">if</span>(rc != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"[YR_ThreadMutex::~YR_ThreadMutex] pthread_mutex_destroy error:"</span> &lt;&lt; <span class="built_in">string</span>(strerror(rc)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> YR_ThreadMutex::lock() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> rc = pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">    <span class="keyword">if</span>(rc != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(rc == EDEADLK)<span class="comment">//如果当前线程已经拥有线程锁</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> YR_ThreadMutex_Exception(<span class="string">"[YR_ThreadMutex::lock] pthread_mutex_lock dead lock error"</span>, rc);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> YR_ThreadMutex_Exception(<span class="string">"[YR_ThreadMutex::lock] pthread_mutex_lock error"</span>, rc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> YR_ThreadMutex::unlock() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> rc = pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">    <span class="keyword">if</span>(rc != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> YR_ThreadMutex_Exception(<span class="string">"[YR_ThreadMutex::unlock] pthread_mutex_unlock error"</span>, rc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="尝试锁"><a href="#尝试锁" class="headerlink" title="尝试锁"></a>尝试锁</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> YR_ThreadMutex::tryLock() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> rc = pthread_mutex_trylock(&amp;_mutex);</span><br><span class="line">    <span class="keyword">if</span>(rc != <span class="number">0</span> &amp;&amp; rc != EBUSY)<span class="comment">//如果所占用则返回EBUSY</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(rc == EDEADLK)<span class="comment">//如果当前线程已经拥有线程锁</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> YR_ThreadMutex_Exception(<span class="string">"[YR_ThreadMutex::tryLock] pthread_mutex_trylock dead lock error"</span>, rc);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> YR_ThreadMutex_Exception(<span class="string">"[YR_ThreadMutex::tryLock] pthread_mutex_trylock error"</span>, rc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (rc == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="嵌套锁的封装"><a href="#嵌套锁的封装" class="headerlink" title="嵌套锁的封装"></a>嵌套锁的封装</h3><h4 id="嵌套锁的定义"><a href="#嵌套锁的定义" class="headerlink" title="嵌套锁的定义"></a>嵌套锁的定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YR_ThreadRecMutex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * @brief 构造函数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    YR_ThreadRecMutex();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * @brief 析够函数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">virtual</span> ~YR_ThreadRecMutex();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * @brief 锁, 调用pthread_mutex_lock. </span></span><br><span class="line"><span class="comment">    *  </span></span><br><span class="line"><span class="comment">    * return : 返回pthread_mutex_lock的返回值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * @brief 解锁, pthread_mutex_unlock. </span></span><br><span class="line"><span class="comment">    *  </span></span><br><span class="line"><span class="comment">    * return : 返回pthread_mutex_lock的返回值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">unlock</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * @brief 尝试锁, 失败抛出异常. </span></span><br><span class="line"><span class="comment">    *  </span></span><br><span class="line"><span class="comment">    * return : true, 成功锁; false 其他线程已经锁了</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">tryLock</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 加锁后调用unlock是否会解锁, 给TC_Monitor使用的</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @return bool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">willUnlock</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 友元类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">TC_ThreadCond</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 计数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 计数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> c)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    锁对象</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">pthread_mutex_t</span> _mutex;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">int</span> _count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">YR_ThreadRecMutex::YR_ThreadRecMutex()</span><br><span class="line">: _count(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> rc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_mutexattr_t</span> attr;</span><br><span class="line">    <span class="comment">//1. 线程属性的初始化</span></span><br><span class="line">    rc = pthread_mutexattr_init(&amp;attr);</span><br><span class="line">    <span class="keyword">if</span>(rc != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> YR_ThreadMutex_Exception(<span class="string">"[YR_ThreadRecMutex::YR_ThreadRecMutex] pthread_mutexattr_init error"</span>, rc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 设置线程锁类型，PTHREAD_MUTEX_RECURSIVE为嵌套锁</span></span><br><span class="line">    rc = pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line">    <span class="keyword">if</span>(rc != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> YR_ThreadMutex_Exception(<span class="string">"[YR_ThreadRecMutex::YR_ThreadRecMutex] pthread_mutexattr_settype error"</span>, rc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 初始化线程</span></span><br><span class="line">    rc = pthread_mutex_init(&amp;_mutex, &amp;attr);</span><br><span class="line">    <span class="keyword">if</span>(rc != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> YR_ThreadMutex_Exception(<span class="string">"[YR_ThreadRecMutex::YR_ThreadRecMutex] pthread_mutex_init error"</span>, rc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 销毁线程属性对象</span></span><br><span class="line">    rc = pthread_mutexattr_destroy(&amp;attr);</span><br><span class="line">    <span class="keyword">if</span>(rc != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> YR_ThreadMutex_Exception(<span class="string">"[YR_ThreadRecMutex::YR_ThreadRecMutex] pthread_mutexattr_destroy error"</span>, rc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">YR_ThreadRecMutex::~YR_ThreadRecMutex()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (_count)</span><br><span class="line">    &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rc = <span class="number">0</span>;</span><br><span class="line">    rc = pthread_mutex_destroy(&amp;_mutex);<span class="comment">//销毁线程</span></span><br><span class="line">    <span class="keyword">if</span>(rc != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"[YR_ThreadRecMutex::~YR_ThreadRecMutex] pthread_mutex_destroy error:"</span> &lt;&lt; <span class="built_in">string</span>(strerror(rc)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="加锁-1"><a href="#加锁-1" class="headerlink" title="加锁"></a>加锁</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> YR_ThreadRecMutex::lock() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> rc = pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">    <span class="keyword">if</span>(rc != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//嵌套锁不用判断EDEADLK</span></span><br><span class="line">        <span class="keyword">throw</span> YR_ThreadMutex_Exception(<span class="string">"[YR_ThreadRecMutex::lock] pthread_mutex_lock error"</span>,rc);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//只是计数加1，pthread_mutex_unlock避免锁叠加</span></span><br><span class="line">    <span class="keyword">if</span>(++_count &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rc = pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">        assert(rc == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="解锁-1"><a href="#解锁-1" class="headerlink" title="解锁"></a>解锁</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> YR_ThreadRecMutex::unlock() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//当计数只有1的时候进行解锁操作，大于1的情况只是计数减一即可</span></span><br><span class="line">    <span class="keyword">if</span>(--_count == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> rc = <span class="number">0</span>;</span><br><span class="line">        rc = pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">        <span class="keyword">return</span> rc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="尝试锁-1"><a href="#尝试锁-1" class="headerlink" title="尝试锁"></a>尝试锁</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> YR_ThreadRecMutex::tryLock() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> rc = pthread_mutex_trylock(&amp;_mutex);</span><br><span class="line">    <span class="keyword">if</span>(rc != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(rc != EBUSY)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> YR_ThreadMutex_Exception(<span class="string">"[YR_ThreadRecMutex::tryLock] pthread_mutex_trylock error"</span>, rc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(++_count &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rc = pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">        <span class="keyword">if</span>(rc != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> YR_ThreadMutex_Exception(<span class="string">"[YR_ThreadRecMutex::tryLock] pthread_mutex_unlock error"</span>, rc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (rc == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> YR_ThreadRecMutex::count() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> c   = _count;</span><br><span class="line">    _count  = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> YR_ThreadRecMutex::count(<span class="keyword">int</span> c) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    _count = c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="unlock-之后是否会解锁"><a href="#unlock-之后是否会解锁" class="headerlink" title="unlock()之后是否会解锁"></a>unlock()之后是否会解锁</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> YR_ThreadRecMutex::willUnlock() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _count == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;线程锁的封装&quot;&gt;&lt;a href=&quot;#线程锁的封装&quot; class=&quot;headerlink&quot; title=&quot;线程锁的封装&quot;&gt;&lt;/a&gt;线程锁的封装&lt;/h2&gt;&lt;h3 id=&quot;线程锁的基本操作：&quot;&gt;&lt;a href=&quot;#线程锁的基本操作：&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="-C++" scheme="http://yourenit.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>锁的封装</title>
    <link href="http://yourenit.top/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%94%81%E7%9A%84%E5%B0%81%E8%A3%85/"/>
    <id>http://yourenit.top/C-学习笔记/锁的封装/</id>
    <published>2019-08-26T04:04:56.000Z</published>
    <updated>2019-09-03T03:58:59.455Z</updated>
    
    <content type="html"><![CDATA[<p>锁异常的封装，继承与自定义的异常类即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">YR_Lock_Exception</span> :</span> <span class="keyword">public</span> YR_Exception</span><br><span class="line">&#123;</span><br><span class="line">YR_Lock_Exception(<span class="keyword">const</span> <span class="built_in">string</span>&amp; buffer) : YR_Exception(buffer)&#123;&#125;</span><br><span class="line">    YR_Lock_Exception(<span class="keyword">const</span> <span class="built_in">string</span>&amp; buffer, <span class="keyword">int</span> err) : YR_Exception(buffer,err)&#123;&#125;</span><br><span class="line">    ~YR_Lock_Exception() <span class="keyword">throw</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Linux下有各种锁机制，比如互斥锁、读写锁、自旋锁等，我们可以使用模板类实现对锁的封装。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; //<span class="title">T</span>为锁的类型</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">YR_LockT</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数，构造时加锁</span></span><br><span class="line">    YR_LockT(<span class="keyword">const</span> T&amp; mutex) : _mutex(mutex)</span><br><span class="line">    &#123;</span><br><span class="line">        _mutex.lock();</span><br><span class="line">        _acquired = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//析构函数，析构时解锁</span></span><br><span class="line">    ~YR_LockT()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(_acquired)</span><br><span class="line">            _mutex.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上锁，如果已经上锁，则抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(_acquired)</span><br><span class="line">            <span class="keyword">throw</span> YR_Lock_Exception(<span class="string">"thread has locked!"</span>);</span><br><span class="line">        _mutex.lock();</span><br><span class="line">        _acquired = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//尝试上锁</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">tryAcquire</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _acquired = _mutex.tryLock();</span><br><span class="line">        <span class="keyword">return</span> _acquired;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//释放锁，如果没有上锁，抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!_acquired)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> YR_Lock_Exception(<span class="string">"thread hasn't been locked!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        _mutex.unlock();</span><br><span class="line">        _acquired = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否已经上锁</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">acquired</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _acquired;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//构造函数，用于锁尝试操作</span></span><br><span class="line">    TC_LockT(<span class="keyword">const</span> T&amp; mutex, <span class="keyword">bool</span>) : _mutex(mutex)</span><br><span class="line">    &#123;</span><br><span class="line">        _acquired = _mutex.tryLock();</span><br><span class="line">    &#125;   </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TC_LockT(<span class="keyword">const</span> TC_LockT&amp;);</span><br><span class="line">    TC_LockT&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> TC_LockT&amp;);</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//锁对象</span></span><br><span class="line">    <span class="keyword">const</span> T&amp;        _mutex;</span><br><span class="line">    <span class="comment">//是否已经上锁</span></span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">bool</span> _acquired;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>尝试上锁类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YR_TryLockT</span> :</span> <span class="keyword">public</span> YR_LockT&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    YR_TryLockT(<span class="keyword">const</span> T&amp; mutex) : YR_LockT&lt;T&gt;(mutex, <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>空锁，不做任何锁动作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YR_EmptyMutex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * @brief  写锁.</span></span><br><span class="line"><span class="comment">    *  </span></span><br><span class="line"><span class="comment">    * @return int, 0 正确</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lock</span><span class="params">()</span>  <span class="keyword">const</span>   </span>&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * @brief  解写锁</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">unlock</span><span class="params">()</span> <span class="keyword">const</span>  </span>&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * @brief  尝试解锁. </span></span><br><span class="line"><span class="comment">    *  </span></span><br><span class="line"><span class="comment">    * @return int, 0 正确</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">trylock</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>读写锁读锁模板类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YR_RW_RLockT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief  构造函数，构造时加锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param lock 锁对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    YR_RW_RLockT(T&amp; lock)</span><br><span class="line">        : _rwLock(lock),_acquired(<span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _rwLock.ReadLock();</span><br><span class="line">        _acquired = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 析构时解锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ~YR_RW_RLockT()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_acquired)</span><br><span class="line">        &#123;</span><br><span class="line">            _rwLock.Unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *锁对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> T&amp; _rwLock;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否已经上锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">bool</span> _acquired;</span><br><span class="line"></span><br><span class="line">    YR_RW_RLockT(<span class="keyword">const</span> YR_RW_RLockT&amp;);</span><br><span class="line">    YR_RW_RLockT&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> YR_RW_RLockT&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>读写锁写锁模板类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YR_RW_WLockT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief  构造函数，构造时枷锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param lock 锁对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    YR_RW_WLockT(T&amp; lock)</span><br><span class="line">        : _rwLock(lock),_acquired(<span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _rwLock.WriteLock();</span><br><span class="line">        _acquired = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 析构时解锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ~YR_RW_WLockT()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(_acquired)</span><br><span class="line">        &#123;</span><br><span class="line">            _rwLock.Unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *锁对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> T&amp; _rwLock;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否已经上锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">bool</span> _acquired;</span><br><span class="line"></span><br><span class="line">    YR_RW_WLockT(<span class="keyword">const</span> YR_RW_WLockT&amp;);</span><br><span class="line">    YR_RW_WLockT&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> YR_RW_WLockT&amp;);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;锁异常的封装，继承与自定义的异常类即可。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;lin
      
    
    </summary>
    
      <category term="C++学习笔记" scheme="http://yourenit.top/categories/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="-C++" scheme="http://yourenit.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>异常的封装</title>
    <link href="http://yourenit.top/uncategorized/%E5%BC%82%E5%B8%B8%E7%9A%84%E5%B0%81%E8%A3%85/"/>
    <id>http://yourenit.top/uncategorized/异常的封装/</id>
    <published>2019-08-26T02:21:52.857Z</published>
    <updated>2019-08-26T04:07:07.761Z</updated>
    
    <content type="html"><![CDATA[<h2 id="异常的封装"><a href="#异常的封装" class="headerlink" title="异常的封装"></a>异常的封装</h2><p>这里展示的是自定义异常类，继承与<code>exception</code>类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> youren &#123;</span><br><span class="line"><span class="comment">////////////////////////////////////////////////</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YR_Exception</span> :</span> <span class="keyword">public</span> exception</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">YR_Exception(<span class="keyword">const</span> <span class="built_in">string</span>&amp; buffer);</span><br><span class="line">YR_Exception(<span class="keyword">const</span> <span class="built_in">string</span>&amp; buffer, <span class="keyword">int</span> err);</span><br><span class="line">~YR_Exception() <span class="keyword">throw</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误信息</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">what</span><span class="params">()</span> <span class="keyword">const</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//获取错误码</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getErrCode</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> _code;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getBacktrace</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">string</span> _buffer;</span><br><span class="line"><span class="keyword">int</span> _code;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"util/YR_Exception.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;execinfo.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> youren</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">YR_Exception::YR_Exception(<span class="keyword">const</span> <span class="built_in">string</span> &amp;buffer)</span><br><span class="line">:_buffer(buffer), _code(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">YR_Exception::YR_Exception(<span class="keyword">const</span> <span class="built_in">string</span> &amp;buffer, <span class="keyword">int</span> err)</span><br><span class="line">&#123;</span><br><span class="line">    _buffer = buffer + <span class="string">" :"</span> + strerror(err);</span><br><span class="line">    _code   = err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">YR_Exception::~YR_Exception() <span class="keyword">throw</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* YR_Exception::what() <span class="keyword">const</span> <span class="keyword">throw</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _buffer.c_str();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> YR_Exception::getBacktrace()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> * <span class="built_in">array</span>[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">int</span> nSize = backtrace(<span class="built_in">array</span>, <span class="number">64</span>);</span><br><span class="line">    <span class="keyword">char</span> ** symbols = backtrace_symbols(<span class="built_in">array</span>, nSize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        _buffer += symbols[i];</span><br><span class="line">        _buffer += <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(symbols);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;异常的封装&quot;&gt;&lt;a href=&quot;#异常的封装&quot; class=&quot;headerlink&quot; title=&quot;异常的封装&quot;&gt;&lt;/a&gt;异常的封装&lt;/h2&gt;&lt;p&gt;这里展示的是自定义异常类，继承与&lt;code&gt;exception&lt;/code&gt;类。&lt;/p&gt;
&lt;figure class
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yourenit.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++新特性之完美转发</title>
    <link href="http://yourenit.top/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/"/>
    <id>http://yourenit.top/C-学习笔记/C-新特性之完美转发/</id>
    <published>2018-09-24T13:45:07.000Z</published>
    <updated>2018-09-24T13:47:14.104Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章中，我们了解了什么是右值引用。</p><p>这篇文章则是了解<code>C++11</code>如何解决右值引用的一个实际问题：转发问题。</p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>我们考虑一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void process_func(MySTring t)&#123;&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">void forward_func(T&amp;&amp; t)&#123;</span><br><span class="line">    process_func(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //以上篇右值引用实现的MyString类为测试对象</span><br><span class="line">    forward_func(MyString(&quot;Hello&quot;));</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从代码来看，我们的<code>forward_func</code>函数传入的参数是一个右值引用，那么<code>process_func</code>的参数是不是也是右值引用呢？让我们看一下结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Construct</span><br><span class="line">Copy Construct</span><br><span class="line">Destruct</span><br><span class="line">Destruct</span><br></pre></td></tr></table></figure></p><p>从结果中，我们可以看到，构造临时变量之后，便执行了拷贝构造函数，也就是说，传进<code>process_func</code>的不是右值，而是左值。这显然不是我们想要的结果，我们希望<code>process_func</code>传入的参数也是右值，该怎么做？我们将需要从一个函数中的一个或者多个实参连同其类型完整的转发给其他函数，称之为“完美转发”。</p><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>我们如果要做到完美转发，该怎么做呢？<br><code>C++11</code>给出了我们答案：引入一条新语言规则——引用折叠，并结合新的模板推导规则来完成完美转发。</p><p>引用折叠：</p><table><br><thead><br><tr><br>  <th>折叠前</th><br>  <th>折叠后</th><br>  <th>注释</th><br></tr><br></thead><br><tbody><tr><br>  <td>A&amp; &amp;</td><br>  <td>A&amp;</td><br>  <td>指向左值引用的左值引用折叠/崩塌为左值引用</td><br></tr><br><tr><br>  <td>A&amp; &amp;&amp;</td><br>  <td>A&amp;</td><br>  <td>指向左值引用的右值引用折叠/崩塌为左值引用</td><br></tr><br><tr><br>  <td>A&amp;&amp; &amp;</td><br>  <td>A&amp;</td><br>  <td>指向右值引用的左值引用折叠/崩塌为左值引用</td><br></tr><br><tr><br>  <td>A&amp;&amp; &amp;&amp;</td><br>  <td>A&amp;&amp;</td><br>  <td>指向右值引用的右值引用折叠/崩塌为右值引用</td><br></tr><br></tbody></table><p>从上表可以看出，当<code>forward_func</code>函数传入左值引用的时候，<code>process_func</code>的参数类型被折叠成左值引用，当<code>forward_func</code>函数传入右值引用的时候普，<code>process_func</code>的参数类型被折叠成右值引用。具体我们看下例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void process_func(MyString&amp;&amp; t)&#123;</span><br><span class="line">    cout&lt;&lt;&quot; rvalue ref&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">void process_func(MyString&amp; t)&#123;</span><br><span class="line">    cout&lt;&lt;&quot;lvalue ref&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">void forward_func(T&amp;&amp; t)&#123;</span><br><span class="line">    //cout&lt;&lt;typeid(t).name()&lt;&lt;endl;</span><br><span class="line">    //cout&lt;&lt;&quot;forward_value&quot;&lt;&lt;endl;</span><br><span class="line">    process_func(forward&lt;T&gt;(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    MyString str=&quot;World!&quot;;</span><br><span class="line">    forward_func(str);      //传入左值</span><br><span class="line"></span><br><span class="line">    forward_func(MyString(&quot;Hello&quot;));    //传入右值</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Construct</span><br><span class="line">Move Construct</span><br><span class="line">Destruct</span><br><span class="line">lvalue ref          //MyString str=&quot;World!&quot;;  forward_func(str);</span><br><span class="line">Construct</span><br><span class="line">rvalue ref          //forward_func(MyString(&quot;Hello&quot;)); </span><br><span class="line">Destruct</span><br><span class="line">Destruct</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在上一篇文章中，我们了解了什么是右值引用。&lt;/p&gt;
&lt;p&gt;这篇文章则是了解&lt;code&gt;C++11&lt;/code&gt;如何解决右值引用的一个实际问题：转发问题。&lt;/p&gt;
&lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
      <category term="C++学习笔记" scheme="http://yourenit.top/categories/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://yourenit.top/tags/C/"/>
    
      <category term="新特性" scheme="http://yourenit.top/tags/%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
      <category term="编程" scheme="http://yourenit.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>右值引用和移动构造函数</title>
    <link href="http://yourenit.top/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <id>http://yourenit.top/C-学习笔记/右值引用和移动构造函数/</id>
    <published>2018-09-22T11:42:20.000Z</published>
    <updated>2018-09-22T11:45:07.104Z</updated>
    
    <content type="html"><![CDATA[<p>在了解右值引用之前，我们先复习什么左值、右值？什么是引用？</p><h3 id="左值、右值"><a href="#左值、右值" class="headerlink" title="左值、右值"></a>左值、右值</h3><p>在<code>C</code>语言中，左值可以位于赋值语句的左侧，右值则不能。<br>具体可以参考<a href="https://zh.cppreference.com/w/c/language/value_category" target="_blank" rel="noopener">C值类别</a>。</p><p>在<code>C++</code>中，每个表达式属于三种基本值之一：纯右值、亡值、左值。<br>具体参考<a href="https://zh.cppreference.com/w/cpp/language/value_category" target="_blank" rel="noopener">C++值类别</a>。</p><p>在<code>C++ Prime</code>中，对左值和右值的区别做了一个简单的归纳：</p><ol><li><strong>当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。</strong></li><li><strong>左值有持久的状态，而右值要么是字面常量，要么是表达式求值过程中创建的临时对象。</strong></li></ol><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用是为一个已经存在的对象或者函数起一个别名。并不是将这个对象或者函数拷贝给引用。通常用<code>&amp;</code>定义引用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a=123;</span><br><span class="line">int &amp;b=a;           //它相当于给a起个别名为b</span><br><span class="line"></span><br><span class="line">b=456;              //对引用的操作实在与之绑定的对象上进行的</span><br></pre></td></tr></table></figure></p><h4 id="引用的注意事项"><a href="#引用的注意事项" class="headerlink" title="引用的注意事项"></a>引用的注意事项</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int &amp;c=1;           //错误，引用类型的初始值必须是一个对象</span><br><span class="line">const int &amp;d=2;     //正确，d为一个常量引用</span><br><span class="line"></span><br><span class="line">double &amp;e=a;        //错误引用类型必须是int类型对象</span><br></pre></td></tr></table></figure><p>当我们复习完上面所有知识之后，我们来了解什么是左值引用、右值引用？</p><h3 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h3><p>左值引用用于对已经存在的对象起一个别名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#icnldue &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string s=&quot;Hello&quot;;</span><br><span class="line">    string&amp; r1s;</span><br><span class="line">    const string&amp;r2=s;</span><br><span class="line">    </span><br><span class="line">    r1+=&quot; World!&quot;;      //可以修改s</span><br><span class="line">    r2+=&quot; World!&quot;;      //不可以修改，r2为常量引用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也可以用于函数调用实现引用传递：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void print(string&amp; str)&#123;</span><br><span class="line">    str+=&quot; World!&quot;;</span><br><span class="line">    cout&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string str=&quot;Hello&quot;;</span><br><span class="line">    print(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>函数的返回值是左值引用时，函数调用表达式成为左值表达式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">char&amp; print_char(string&amp; str,size_t n)&#123;</span><br><span class="line">    return str.at(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string str=&quot;Hello&quot;;</span><br><span class="line">    print(str,0)=&apos;C&apos;;   //函数调用是左值，可以被赋值</span><br><span class="line">    cout&lt;&lt;str&lt;&lt;endl;    //输出Cello</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在C++中，我们常见的左值返回还有赋值、下标、解引用、和前置递增/递减运算符，他们的返回值都是可以被修改的。</span><br></pre></td></tr></table></figure></p><p>但是，对于一些要求转换的表达式、字面常量或是返回右值的表达式，左值引用就无能为力了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string &amp; print(string &amp; str)&#123;</span><br><span class="line">    return str+&quot; world!&quot;;       //编译器报错，非常量引用的初始值必须为左值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们知道<code>str+&quot; world!&quot;</code>为右值，我们将返回类型改为常量类型，就不会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const string &amp; print(string &amp; str)&#123;</span><br><span class="line">    return str+&quot; world!&quot;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们调用一下，试试看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const string&amp; str2=print(str);</span><br><span class="line">cout&lt;&lt;str2&lt;&lt;endl;</span><br></pre></td></tr></table></figure></p><p>此时，我们发现，输出的结果是乱码，调试发现，<code>str2</code>中根本没有值。这是因为函数调用产生一个临时对象，引用则将绑定这个临时对象，当函数调用完毕将临时对象销毁，引用将失效，所以返回乱码。</p><p>那么问题该怎么解决呢？就函数来看，毕竟返回引用类型要比返回值类型要高效，不用将临时对象的值拷贝给新的对象，而是“偷了”临时对象的值。</p><p><code>C++11</code>为我们则引入了一种新的类型————右值引用。</p><h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>新标准中用<code>&amp;&amp;</code>来定义右值引用，右值引用指向的是临时对象，因此延长了临时对象的生存期。这种“偷”走临时变量的行为，被称为“移动语义”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string s1=&quot;Hello&quot;;</span><br><span class="line">    string &amp;&amp; r=s1+s1;      //s1+s1创建一个临时对象</span><br><span class="line">    r+=&quot; World!&quot;;</span><br><span class="line">    cout&lt;&lt;r&lt;&lt;endl;      //输出Hello Hello World!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在新标准中，我们还可以显式的将一个左值转换为对应的右值引用类型——<code>move</code>函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i=10;  </span><br><span class="line">int &amp;&amp; k=std::move(i);</span><br><span class="line">cout&lt;&lt;&amp;i&lt;&lt;&quot; &quot;&lt;&lt;&amp;k&lt;&lt;endl;        //i和k的地址相同</span><br></pre></td></tr></table></figure></p><p>既然我们可以延长临时对象的生存期，并减少对象的拷贝操作，我们在自己的类中如果也支持移动操作，那么也提高不少效率。</p><h3 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h3><p>我们需要定义移动构造函数和移动赋值运算符。这两个成员类似于对应的拷贝操作，但它们是从给定的对象“窃取”资源而不是拷贝资源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class MyString &#123;</span><br><span class="line">private:</span><br><span class="line">char* data;</span><br><span class="line">size_t len;</span><br><span class="line">public:</span><br><span class="line">MyString():data(nullptr),len(0)&#123;&#125;</span><br><span class="line">MyString(const char* p):data(new char[strlen(p)+1]),len(strlen(p))&#123;</span><br><span class="line">strcpy(data, p);</span><br><span class="line">cout &lt;&lt; &quot;Construct: &quot; &lt;&lt; ++cstr &lt;&lt; endl;</span><br><span class="line">&#125;//构造函数</span><br><span class="line">MyString(const MyString&amp; str) :data(new char[strlen(str.data) + 1]), len(strlen(str.data)) &#123;</span><br><span class="line">strcpy(this-&gt;data, str.data);</span><br><span class="line">cout &lt;&lt; &quot;Copy Construct: &quot; &lt;&lt; ++cptr &lt;&lt; endl;</span><br><span class="line">&#125;//拷贝构造函数</span><br><span class="line"></span><br><span class="line">~MyString() &#123; </span><br><span class="line">delete data; </span><br><span class="line">cout &lt;&lt; &quot;Destruct: &quot; &lt;&lt; ++dstr &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">static int cstr;        //构造函数调用次数</span><br><span class="line">static int dstr;        //析构函数调用次数</span><br><span class="line">static int cptr;        //拷贝构造函数调用次数</span><br><span class="line">//static int mvtr;        //移动构造函数调用次数</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int MyString::cstr = 0;</span><br><span class="line">int MyString::dstr = 0;</span><br><span class="line">int MyString::cptr = 0;</span><br><span class="line">//int MyString::mvtr = 0;</span><br><span class="line"></span><br><span class="line">MyString GetStr() &#123; return MyString(&quot;Hello&quot;); &#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    MyString str=MyStriung(&quot;Hello&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面中的静态变量用来输出各种函数调用的次数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">在g++上的运行结果为：</span><br><span class="line">Construct: 1</span><br><span class="line">Copy Construct: 1</span><br><span class="line">Destruct: 1</span><br><span class="line">Copy Construct: 2</span><br><span class="line">Destruct: 2</span><br><span class="line">Destruct: 3</span><br><span class="line"></span><br><span class="line">在vs上的结果为：</span><br><span class="line">Construct: 1</span><br><span class="line">Copy Construct: 1</span><br><span class="line">Destruct: 1</span><br><span class="line">    </span><br><span class="line">vs将其优化了，用g++的-fno-elide-constructors参数就不会被优化。</span><br></pre></td></tr></table></figure></p><p>可以看出，拷贝构造函数被调用了两次，一次是将构造的变量拷贝构造给临时值，用来做<code>GetStr</code>的返回值，另一次是由临时值构造出<code>main</code>函数中的变量<code>str</code>。</p><p>如果字符串的数据很大的话，那么花在拷贝上的时间比较大了，效率就会大大降低。如果我们将临时对象的值“偷”过来，那效率会有什么变化呢？<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们在上述类中添加移动构造函数</span></span><br><span class="line">MyString(MyString &amp;&amp;str)&#123;</span><br><span class="line">    len=str.len;</span><br><span class="line">    <span class="keyword">this</span>-&gt;data=str.data;</span><br><span class="line">    str.len=<span class="number">0</span>;</span><br><span class="line">    str.data=<span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">MyString <span class="title">GetStr</span><span class="params">()</span></span>&#123; MyString str=<span class="string">"Hello"</span>; <span class="keyword">return</span> str;&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">运行结果为：</span><br><span class="line">Construct: 1</span><br><span class="line">Move Construct: 1</span><br><span class="line">Destruct: 1</span><br><span class="line">Move Construct: 2</span><br><span class="line">Destruct: 2</span><br><span class="line">Destruct: 3</span><br></pre></td></tr></table></figure><p>从结果可以看到，没有执行拷贝构造函数，而是执行的是移动构造函数。虽然在此没有将临时值和mian函数中str的成员变量地址输出出来，但是他们的地址是相同的。这就省去了再申请内存和拷贝的时间，效率也提高了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在了解右值引用之前，我们先复习什么左值、右值？什么是引用？&lt;/p&gt;
&lt;h3 id=&quot;左值、右值&quot;&gt;&lt;a href=&quot;#左值、右值&quot; class=&quot;headerlink&quot; title=&quot;左值、右值&quot;&gt;&lt;/a&gt;左值、右值&lt;/h3&gt;&lt;p&gt;在&lt;code&gt;C&lt;/code&gt;语言中，左值
      
    
    </summary>
    
      <category term="C++学习笔记" scheme="http://yourenit.top/categories/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://yourenit.top/tags/C/"/>
    
      <category term="新特性" scheme="http://yourenit.top/tags/%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
      <category term="编程" scheme="http://yourenit.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Haskell初步</title>
    <link href="http://yourenit.top/Haskell%E5%AD%A6%E4%B9%A0/Haskell%E5%88%9D%E6%AD%A5/"/>
    <id>http://yourenit.top/Haskell学习/Haskell初步/</id>
    <published>2018-09-21T08:15:30.000Z</published>
    <updated>2018-09-21T08:17:14.164Z</updated>
    
    <content type="html"><![CDATA[<h3 id="函数的定义和调用"><a href="#函数的定义和调用" class="headerlink" title="函数的定义和调用"></a>函数的定义和调用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//函数名 参数1 参数2 ... = 函数体</span><br><span class="line"></span><br><span class="line">doubleMe x=x+x</span><br><span class="line"></span><br><span class="line">doubleUs x y= x*2 + y*2</span><br><span class="line"></span><br><span class="line">//可在其他函数中调用你编写的函数</span><br><span class="line">doubleUs x y = doubleMe x + doubleMe y</span><br><span class="line">//很符合我们数学中公式的组合f(x)=g(x)+h(x)+...</span><br></pre></td></tr></table></figure><p><code>Haskell</code>中函数没有顺序，无论先声明<code>doubleMe</code>还是<code>doubleUs</code>都是一样的。</p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">//定义，所有元素必须相同类型</span><br><span class="line">let lostNumber=[1,2,3,4]</span><br><span class="line"></span><br><span class="line">//两个list合并</span><br><span class="line">let lostNumber2=[5,6,7,8]</span><br><span class="line">lostNumber ++ lostNumber2</span><br><span class="line"></span><br><span class="line">//索引 !!</span><br><span class="line">lostNumber !!2  //2为下标</span><br><span class="line"></span><br><span class="line">//比较大小</span><br><span class="line">lostNumber &gt; lostNumber2    //返回False</span><br><span class="line">[2.1,3.1,4.1] &gt; [2,3,4]     //返回True</span><br><span class="line">lostNumber == lostNumber2   //返回False</span><br><span class="line"></span><br><span class="line">//常用搭配函数：</span><br><span class="line">head lostNumber         //返回list的第一个元素</span><br><span class="line">last lostNumber         //返回list的最后一个元素</span><br><span class="line">tail lostNumber         //返回除去第一个元素之后的部分</span><br><span class="line">init lostNumber         //返回除去最后一个元素之前的部分</span><br><span class="line">length lostNumber       //返回list的长度</span><br><span class="line">null lostNumber         //检查list是否为空，空则返回True</span><br><span class="line">reverse lostNumber      //将list反转</span><br><span class="line">take 3 lostNumber       //返回list的前几个元素，3指定返回前3个元素</span><br><span class="line">drop 3 lostNumber       //删除list前几个元素</span><br><span class="line">maximum lostNumber      //返回list中最大的元素</span><br><span class="line">minimum lostNumber      //返回list中最小的元素</span><br><span class="line">sum lostNumber          //返回list所有元素之和</span><br><span class="line">profuct lostNumber      //返回list中所有元素之积</span><br><span class="line"></span><br><span class="line">4 `elem` lostNumber      //判断一个元素是否在一个list中</span><br><span class="line"></span><br><span class="line">[1..20]                 //定义一个从1到20的list</span><br><span class="line">[20,19..1]              //[20..1]是不可以的</span><br><span class="line">//也可以是字符</span><br><span class="line">[&apos;a&apos;..&apos;z&apos;]              //返回&quot;abcdefghijklmnopqrstuvwxyz&quot;</span><br><span class="line">[&apos;A&apos;..&apos;z&apos;]              //返回&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz&quot;</span><br><span class="line">//设置步长</span><br><span class="line">[2,4..20]              //返回[2,4,6,8,10,12,14,16,18,20]</span><br><span class="line"></span><br><span class="line">//不标明上限</span><br><span class="line">take 24 [13,26..]           //用多少取多少</span><br><span class="line">[13.26..]                   //不停输出</span><br><span class="line"></span><br><span class="line">repeat接受一个值作为参数，返回一个仅包含该值的无限List</span><br><span class="line">cycle则是接受一个list，并无限输出</span><br><span class="line"></span><br><span class="line">replicate 3 10              //得到包含3个元素相同的list</span><br></pre></td></tr></table></figure><p>我们也可以表达数学中的集合：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S=&#123;2*x | x\in N,x\leq10&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[x*2 | x&lt;-[1..10]]          //返回[2,4,6,8,10,12,14,16,18,20]</span><br><span class="line">[x*2 | x&lt;-[1..10], x*2 &gt;= 12]   //返回[12,14,16,18,20]</span><br></pre></td></tr></table></figure><h3 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fst (8,11)              //返回一个序对的首项</span><br><span class="line">snd (8,11)              //返回一个序对的尾项</span><br><span class="line">//不能用于三元组或四元组以上</span><br><span class="line"></span><br><span class="line">zip [1,2,3,4] [7,8,9]   //zip用来生成一组序对的list</span><br><span class="line">//返回[(1,7),(2,8),(3,9)]</span><br></pre></td></tr></table></figure><p>解决一个问题：如何取得所有三边长度皆为整数且小于等于10，周长为24的直角三角形？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let rightTriangles = [ (a,b,c) | c&lt;-[1..10], b&lt;-[1..c], a&lt;-[1..b], a^2 + b^2 == c^2,a+b+c==24]</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;函数的定义和调用&quot;&gt;&lt;a href=&quot;#函数的定义和调用&quot; class=&quot;headerlink&quot; title=&quot;函数的定义和调用&quot;&gt;&lt;/a&gt;函数的定义和调用&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl
      
    
    </summary>
    
      <category term="Haskell学习" scheme="http://yourenit.top/categories/Haskell%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="编程" scheme="http://yourenit.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Haskell" scheme="http://yourenit.top/tags/Haskell/"/>
    
  </entry>
  
  <entry>
    <title>C++新特性之Variadic Template</title>
    <link href="http://yourenit.top/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BVariadic-Template%EF%BC%88%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF%EF%BC%89/"/>
    <id>http://yourenit.top/C-学习笔记/C-新特性之Variadic-Template（可变参数模板）/</id>
    <published>2018-09-20T16:41:55.000Z</published>
    <updated>2018-09-20T16:43:19.695Z</updated>
    
    <content type="html"><![CDATA[<h3 id="可变参数模板的定义"><a href="#可变参数模板的定义" class="headerlink" title="可变参数模板的定义"></a>可变参数模板的定义</h3><p>可变参数模板是至少有一个参数宝的模板，参数包则是可以接受零个或者更多模板实参的模板形参，其格式如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> ...<span class="title">T</span>&gt; <span class="title">class</span> <span class="title">classname</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> ...<span class="title">T</span>&gt; <span class="title">void</span> <span class="title">func</span>(<span class="title">T</span> ...<span class="title">args</span>);</span></span><br></pre></td></tr></table></figure></p><p>其中<code>T</code>为模板参数包，<code>args</code>为函数参数包。</p><p>可变参数模板可以用任意数量的模板参数实例化：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Myclass</span>&#123;</span>&#125;;</span><br><span class="line">Myclass&lt;&gt; t0;           <span class="comment">//T 不包含实参</span></span><br><span class="line">Myclass&lt;<span class="keyword">int</span>&gt; t1;        <span class="comment">//T 包含一个实参，类型为int</span></span><br><span class="line">Myclass&lt;<span class="keyword">int</span>,<span class="keyword">float</span>&gt; t2;  <span class="comment">//T 包含两个实参，类型为int和float</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//模板参数包必须是模板参数列表中的最后一个形参。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... T,<span class="keyword">typename</span> U&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Invalid</span>;</span>    <span class="comment">//错误</span></span><br></pre></td></tr></table></figure></p><p>可变参数函数模板可以用任意数量的函数实参调用：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">func</span>(<span class="title">T</span>... <span class="title">args</span>);</span></span><br><span class="line">func();        <span class="comment">//args不包含实参</span></span><br><span class="line">func(<span class="number">1</span>);        <span class="comment">//包含一个实参，类型为int</span></span><br><span class="line">func(<span class="number">1</span>,<span class="number">2.1</span>);    <span class="comment">//包含两个实参，类型为int和double</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//与类模板不同，函数模板参数包不必是模板参数列表中的最后一个，它可以在列表早于所有能从函数实参推导的参数出现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">T</span>,<span class="title">class</span> <span class="title">U</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">valid</span>(<span class="title">U</span>,<span class="title">T</span>...);</span>     <span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line">valid(<span class="number">1.0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);       <span class="comment">//推导U为double，T为&#123;int，int，int&#125;</span></span><br></pre></td></tr></table></figure></p><h3 id="包展开"><a href="#包展开" class="headerlink" title="包展开"></a>包展开</h3><p>包展开的场所不同，产生的逗号分隔列表种类不同：</p><ol><li><p>函数实参列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func(&amp;args...);         //展开成func(&amp;E1,&amp;E2,&amp;E3)</span><br><span class="line">func(++args...,n);      //展开成func(++E1,++E2,++E3,n)</span><br><span class="line">func(n,++args);         //展开成func(n,++E1,++E2,++E3)</span><br><span class="line">func(const_cast&lt;const Args*&gt;(&amp;args)...);    // func(const_cast&lt;const E1*&gt;(&amp;X1), const_cast&lt;const E2*&gt;(&amp;X2), const_cast&lt;const E3*&gt;(&amp;X3))</span><br><span class="line">func(h(args...) + args...); // 展开成 func(h(E1,E2,E3) + E1, h(E1,E2,E3) + E2, h(E1,E2,E3) + E3)</span><br></pre></td></tr></table></figure></li><li><p>有括号初始化器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class c1(&amp;args...);             // 调用 Class::Class(&amp;E1, &amp;E2, &amp;E3)</span><br><span class="line">Class c2 = Class(n, ++args...); // 调用 Class::Class(n, ++E1, ++E2, ++E3);</span><br></pre></td></tr></table></figure></li><li><p>花括号环绕的初始化器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class... T&gt; void func(T... args)</span><br><span class="line">&#123;</span><br><span class="line">    const int size=sizeof...(args);</span><br><span class="line">    int res[size]=&#123;args...&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>模板实参列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//包展开可以用于模板形参列表的任何位置，前提是模板拥有匹配展开的形参。</span><br><span class="line">template &lt;class A,class B,class... C&gt; void func(A arg1,B arg2,C... arg3)</span><br><span class="line">&#123;</span><br><span class="line">    container&lt;A,B,C...&gt; t1;     // 展开成 container&lt;A,B,E1,E2,E3&gt; </span><br><span class="line">    container&lt;C...,A,B&gt; t2;     // 展开成 container&lt;E1,E2,E3,A,B&gt; </span><br><span class="line">    container&lt;A,C...,B&gt; t3;      // 展开成 container&lt;A,E1,E2,E3,B&gt; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数形参列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename ...Ts&gt; void f(Ts...) &#123;&#125;</span><br><span class="line">f(&apos;a&apos;, 1);  // Ts... 展开成 void f(char, int)</span><br><span class="line">f(0.1);     // Ts... 展开成 void f(double)</span><br></pre></td></tr></table></figure></li><li><p>模板形参列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class ...T&gt; class Myclass</span><br><span class="line">&#123;</span><br><span class="line">    template&lt;T... Values&gt; // 展开成无类型模板参数列表，例如 &lt;int, char, int(&amp;)[5]&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>Lambda捕获</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class ...T&gt;</span><br><span class="line">void func(T... args)&#123;</span><br><span class="line">    auto g=[&amp;,args...]&#123;return h(args...);&#125;</span><br><span class="line">    g();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>sizeof…运算符</p></li><li>基类指定符和成员初始化列表<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class... Mixins&gt;</span><br><span class="line">class X : public Mixins... &#123;</span><br><span class="line"> public:</span><br><span class="line">    X(const Mixins&amp;... mixins) : Mixins(mixins)... &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void print()&#123;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T&gt; void print(const T&amp; t)&#123;</span><br><span class="line">    cout&lt;&lt; t &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class First,class... Rest&gt;void print(const First&amp; first,const Rest&amp;... rest)&#123;</span><br><span class="line">    cout&lt;&lt;first&lt;&lt;&quot;,&quot;;</span><br><span class="line">    print(rest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    print();</span><br><span class="line">    print(1);</span><br><span class="line">    </span><br><span class="line">    print(10,20);</span><br><span class="line">    print(100,200,300);</span><br><span class="line">    print(&quot;first&quot;,2,&quot;third&quot;,3.14159);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现<code>C</code>语言中的<code>printf</code>函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"> </span><br><span class="line">void tprintf(const char* format) // 基函数</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; format;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">template&lt;typename T, typename... Targs&gt;</span><br><span class="line">void tprintf(const char* format, T value, Targs... Fargs) // 递归变参数函数</span><br><span class="line">&#123;</span><br><span class="line">    for ( ; *format != &apos;\0&apos;; format++ ) &#123;</span><br><span class="line">        if ( *format == &apos;%&apos; ) &#123;</span><br><span class="line">           std::cout &lt;&lt; value;</span><br><span class="line">           tprintf(format+1, Fargs...); // 递归调用</span><br><span class="line">           return;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; *format;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    tprintf(&quot;% world% %\n&quot;,&quot;Hello&quot;,&apos;!&apos;,123);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;可变参数模板的定义&quot;&gt;&lt;a href=&quot;#可变参数模板的定义&quot; class=&quot;headerlink&quot; title=&quot;可变参数模板的定义&quot;&gt;&lt;/a&gt;可变参数模板的定义&lt;/h3&gt;&lt;p&gt;可变参数模板是至少有一个参数宝的模板，参数包则是可以接受零个或者更多模板实参的模板形
      
    
    </summary>
    
      <category term="C++学习笔记" scheme="http://yourenit.top/categories/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://yourenit.top/tags/C/"/>
    
      <category term="新特性" scheme="http://yourenit.top/tags/%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
      <category term="编程" scheme="http://yourenit.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++新特性之Type Alias、Template Alias、noexcept、override、final</title>
    <link href="http://yourenit.top/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BType-Alias%E3%80%81Template-Alias%E3%80%81noexcept%E3%80%81override%E3%80%81final/"/>
    <id>http://yourenit.top/C-学习笔记/C-新特性之Type-Alias、Template-Alias、noexcept、override、final/</id>
    <published>2018-09-19T12:49:13.000Z</published>
    <updated>2018-09-19T12:51:37.728Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Type-Alias（类型别名）and-Template-Alias（模板别名）"><a href="#1-Type-Alias（类型别名）and-Template-Alias（模板别名）" class="headerlink" title="1. Type Alias（类型别名）and Template Alias（模板别名）"></a>1. Type Alias（类型别名）and Template Alias（模板别名）</h3><p>在<code>C++11</code>中，我们不仅可以为类型定义别名，还可以对模板进行定义别名。</p><h4 id="别名声明的语法"><a href="#别名声明的语法" class="headerlink" title="别名声明的语法"></a>别名声明的语法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">using</span> identifier = type-id       <span class="comment">//identifier为引入的类型名，type-id为抽象声明器或者任何合法的type-id</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> <span class="keyword">template</span> &lt;<span class="keyword">template</span>-parameter-<span class="built_in">list</span>&gt;</span><br><span class="line">   <span class="keyword">using</span> identifier =type type-id</span><br></pre></td></tr></table></figure><p>类型别名声明和<code>typedef</code>的声明没有差别。</p><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">using</span> A = Base;</span><br><span class="line"><span class="comment">//等同于 typedef Base A;</span></span><br><span class="line">A *a = <span class="keyword">new</span> A(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> func=<span class="keyword">void</span> (*)(<span class="keyword">int</span>,<span class="keyword">int</span>);</span><br><span class="line"><span class="comment">//等同于typedef void (*func)(int,int);</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">example</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>&#123;&#125;</span><br><span class="line">func b=example;</span><br><span class="line"></span><br><span class="line"><span class="comment">//别名模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">using</span> <span class="title">point</span> = <span class="title">T</span>*;</span></span><br><span class="line">point&lt;<span class="keyword">const</span> <span class="keyword">char</span>&gt; str=<span class="string">"I Love C++"</span>;</span><br><span class="line"><span class="comment">//point&lt;const char&gt;为指向const char的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用于隐藏模板形参的别名模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">CharT</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">using</span> <span class="title">mystring</span> = <span class="title">std</span>:</span>:basic_string&lt;CharT, <span class="built_in">std</span>::char_traits&lt;CharT&gt;&gt;;</span><br><span class="line">mystring&lt;<span class="keyword">char</span>&gt; str;</span><br><span class="line"></span><br><span class="line">能引入成员<span class="keyword">typedef</span>名的别名模板</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">D</span>&#123;</span></span><br><span class="line">    <span class="keyword">using</span> value_type=T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">D</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">g</span>(<span class="title">const</span> <span class="title">D</span>&amp; <span class="title">c</span>)&#123;</span> <span class="keyword">typename</span> D::value_type n; &#125;</span><br><span class="line"><span class="keyword">const</span> D&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">g(d); </span><br><span class="line"><span class="comment">//通过typeid(n).name()可以获取n的类型为int</span></span><br></pre></td></tr></table></figure><h3 id="2-noexcept"><a href="#2-noexcept" class="headerlink" title="2. noexcept"></a>2. noexcept</h3><p>在<code>C++11</code>中，我们可以通过<code>noexcept</code>来指定某个函数不会抛出异常。</p><p>在<code>C++11</code>之前，通常使用如下方式实现不抛出异常：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void func() throw();</span><br><span class="line">//throw()的()中通常用来放置函数可以抛出异常的类型，如果为空，则不抛出任何异常。</span><br></pre></td></tr></table></figure></p><p><code>C++11</code>将<code>throw()</code>用<code>noexcept</code>替换，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void func() noexcept;</span><br></pre></td></tr></table></figure></p><p>事实上，<code>noexcept</code>指定符的用法不仅仅是替代<code>throw()</code>。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">noexcept(expression)</span><br><span class="line">//如果没有expression,expression默认为true,即不抛出任何异常。</span><br></pre></td></tr></table></figure><h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">指向不抛出函数的指针可赋值给指向潜在抛出函数的指针，反之不可。</span><br><span class="line">void f();   //潜在抛出</span><br><span class="line">void (*fn)() noexcept =ft;  //错误</span><br><span class="line"></span><br><span class="line">//若虚函数为不抛出，则所有声明，包括整个覆写的定义都必须是不抛出，除非覆写定义被删除。</span><br><span class="line">struct B&#123;</span><br><span class="line">    virtual void f() noexcept;</span><br><span class="line">    virtual void g();</span><br><span class="line">    virtual void h noexcept = delete;</span><br><span class="line">&#125;;</span><br><span class="line">struct D:B&#123;</span><br><span class="line">    void f();   //错误，D::f为潜在抛出，B::f为不抛出</span><br><span class="line">    void g() noexcept;  //正确</span><br><span class="line">    void h() = delete;  //正确</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//不抛出函数允许调用潜在抛出函数</span><br><span class="line">void func1();   //潜在抛出</span><br><span class="line">void func2() noexcept&#123;</span><br><span class="line">    f();    //合法</span><br><span class="line">    throw 10;   //合法，最终调用std::abort()终止程序</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-override"><a href="#3-override" class="headerlink" title="3. override"></a>3. override</h3><p>我们在学习C++虚函数的时候，要求派生类的虚函数要覆盖掉基类中对应的虚函数（函数参数、返回类型必须相同）,。比如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Base()&#123;&#125;</span><br><span class="line">        ~Base()&#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span>:<span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        A()&#123;&#125;</span><br><span class="line">        ~A()&#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>但是上面的代码有一个缺点：如果派生类中想要重新定义的函数却不小心写错了，基类的函数没有被覆盖，但是编译器没有报错，使得调试的时候很难发现。</p><p>在<code>C++11</code>中提供的<code>override</code>关键字可以解决这一问题，它标记派生类中的虚函数，如果基类中的虚函数没有被覆盖，编译器则报错。</p><h3 id="4-final"><a href="#4-final" class="headerlink" title="4. final"></a>4. final</h3><p>假若一个函数被指定为<code>final</code>，则说明该函数不可被覆盖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class A::public Base&#123;</span><br><span class="line">    public:</span><br><span class="line">        A()&#123;&#125;</span><br><span class="line">        ~A()&#123;&#125;</span><br><span class="line">        </span><br><span class="line">        void print(const char* str) final;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B:public A&#123;</span><br><span class="line">  public:</span><br><span class="line">    A()&#123;&#125;</span><br><span class="line">    ~A()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    void print(const char* str);</span><br><span class="line">    //编译器报错，print无法被重写</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Type-Alias（类型别名）and-Template-Alias（模板别名）&quot;&gt;&lt;a href=&quot;#1-Type-Alias（类型别名）and-Template-Alias（模板别名）&quot; class=&quot;headerlink&quot; title=&quot;1. Type 
      
    
    </summary>
    
      <category term="C++学习笔记" scheme="http://yourenit.top/categories/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://yourenit.top/tags/C/"/>
    
      <category term="新特性" scheme="http://yourenit.top/tags/%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
      <category term="编程" scheme="http://yourenit.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++新特性之Lambda表达式</title>
    <link href="http://yourenit.top/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yourenit.top/C-学习笔记/C-新特性之Lambda表达式/</id>
    <published>2018-09-14T04:28:37.000Z</published>
    <updated>2018-09-15T16:23:54.800Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是lambda表达式？"><a href="#什么是lambda表达式？" class="headerlink" title="什么是lambda表达式？"></a>什么是lambda表达式？</h3><p>一个<code>lambda</code>表达式表示以一个可以调用的代码单元。或者理解为一个匿名的内联函数。与任何函数类似，一个<code>lambda</code>具有返回类型、一个参数列表和一个函数体。与函数不同，<code>lambda</code>可能定义在函数内部。</p><h3 id="为什么要有lambda表达式？"><a href="#为什么要有lambda表达式？" class="headerlink" title="为什么要有lambda表达式？"></a>为什么要有lambda表达式？</h3><p>我们知道，在<code>STL</code>所提供的算法中，往往有两个版本。其中一个版本表现最直观的的某种运算，第二个版本则表现出最泛化的演算流程，允许用户“以<code>template</code>参数来指定所要采取的策略”。以<code>sort()</code>为例，第一版本是默认<strong>从小到大排序（operator&lt;）</strong>，第二个版本则是允许你指定某种“操作”，使得排序后的两个相邻元素都能令该操作结果为<code>true</code>。事实上，第二版本允许我们想算法传递任何类别的<strong>可调用对象</strong>。这个“可调用对象”为第二个版本的第三个参数，被称为“<strong>谓词</strong>”。</p><h4 id="可调用对象"><a href="#可调用对象" class="headerlink" title="可调用对象"></a>可调用对象</h4><p>C++的可调用对象有5类：</p><ol><li>函数</li><li>函数指针</li><li>重载了函数调用运算符的类</li><li>bind创建的对象</li><li><strong>lambda表达式</strong></li></ol><p>而在标准算法中将“谓词”分为两类：<strong>一元谓词（只接受一个参数）</strong>、<strong>二元谓词（接受两个参数）</strong>。</p><p>但是我们在使用一个算法中，要使用更多的参数，超出了谓词的限制，或者调用的函数有时候只用一次，重用性太差，那我们就要解决这些问题。</p><p><code>C++11</code>就引入了<code>lambda表达式</code>来解决这些问题。</p><h3 id="lambda表达式怎么用？"><a href="#lambda表达式怎么用？" class="headerlink" title="lambda表达式怎么用？"></a>lambda表达式怎么用？</h3><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. [captures](params) -&gt; return type &#123; function body &#125;</span><br><span class="line">2. [captures](params) &#123; function body &#125;</span><br><span class="line">3. [captures] &#123; function body &#125;</span><br></pre></td></tr></table></figure><p><code>captures</code>为捕获列表，为lambda中定义的局部变量的列表。</p><p><code>params</code>表示参数列表。</p><p><code>return type</code>表示返回类型，为尾随返回类型。</p><p><code>function body</code>为函数体。</p><p>上面三种用法中，我们可以看出来，<strong>参数列表</strong>和<strong>返回类型</strong>可以忽略，但是必须包含<strong>捕获列表</strong>和<strong>函数体</strong>。</p><h4 id="lambda-捕获"><a href="#lambda-捕获" class="headerlink" title="lambda 捕获"></a>lambda 捕获</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[]：lambda不能使用所在函数的变量。</span><br><span class="line">[=]：值捕获，lambda表达式可以以拷贝的方式访问函数中的变量的值。</span><br><span class="line">[&amp;]：引用捕获，lambda表达式中以引用的方式访问函数中的变量的值。</span><br><span class="line">[=,&amp;]：值捕获和引用捕获混合使用。</span><br><span class="line">[var]：指定捕获或拷贝。</span><br><span class="line">[this]：捕获this指针。</span><br></pre></td></tr></table></figure><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;int&gt; a=&#123;1,2,3,4,5&#125;;</span><br><span class="line">    std::for_each(a.begin(),a.end(),[](int i)&#123; std::cout&lt;&lt;i&lt;&lt;&quot; &quot;&#125;);</span><br><span class="line">    </span><br><span class="line">    //C++14 lambda可以拥有自身的默认参数</span><br><span class="line">    auto func=[](inr i=6)&#123;return i+4;&#125;;</span><br><span class="line">    std::cout&lt;&lt;func()&lt;&lt;std::endl;</span><br><span class="line">    </span><br><span class="line">    //值捕获和引用捕获</span><br><span class="line">    int b=1024,c=2048;</span><br><span class="line">    auto func2=[b,&amp;c]&#123;</span><br><span class="line">        std::cout&lt;&lt;i&lt;&lt;std::endl;</span><br><span class="line">        std::cout&lt;&lt;&amp;j&lt;&lt;std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    func2();</span><br><span class="line">    </span><br><span class="line">    //与stl算法结合，找出a中大于3的一个元素</span><br><span class="line">    int x=3;</span><br><span class="line">    auto d=find_if(a.begin(),a.end(),</span><br><span class="line">        [x](int num)</span><br><span class="line">            &#123;return num&gt;x;&#125;);</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是lambda表达式？&quot;&gt;&lt;a href=&quot;#什么是lambda表达式？&quot; class=&quot;headerlink&quot; title=&quot;什么是lambda表达式？&quot;&gt;&lt;/a&gt;什么是lambda表达式？&lt;/h3&gt;&lt;p&gt;一个&lt;code&gt;lambda&lt;/code&gt;表达式表示
      
    
    </summary>
    
      <category term="C++学习笔记" scheme="http://yourenit.top/categories/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://yourenit.top/tags/C/"/>
    
      <category term="新特性" scheme="http://yourenit.top/tags/%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
      <category term="编程" scheme="http://yourenit.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
