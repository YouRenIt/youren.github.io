<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>幽人&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yourenit.top/"/>
  <updated>2019-08-28T01:12:23.034Z</updated>
  <id>http://yourenit.top/</id>
  
  <author>
    <name>幽人</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>线程锁的封装</title>
    <link href="http://yourenit.top/uncategorized/%E7%BA%BF%E7%A8%8B%E9%94%81%E7%9A%84%E5%B0%81%E8%A3%85/"/>
    <id>http://yourenit.top/uncategorized/线程锁的封装/</id>
    <published>2019-08-26T04:06:28.000Z</published>
    <updated>2019-08-28T01:12:23.034Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程锁的封装"><a href="#线程锁的封装" class="headerlink" title="线程锁的封装"></a>线程锁的封装</h2><h3 id="线程锁的基本操作："><a href="#线程锁的基本操作：" class="headerlink" title="线程锁的基本操作："></a>线程锁的基本操作：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 创建锁 <span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span>*mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> * attr)</span></span>;</span><br><span class="line">    attr：创建锁的属性。一般默认为<span class="literal">NULL</span>，分为以下几个属性：</span><br><span class="line">        * PTHREAD_MUTEX_TIMED_NP，这是缺省值，也就是普通锁。当一个线程加锁以后，其余请求锁的线程将形成一个等待队列，并在解锁后按优先级获得锁。这种锁策略保证了资源分配的公平性；</span><br><span class="line">        * PTHREAD_MUTEX_RECURSIVE_NP，嵌套锁，允许同一个线程对同一个锁成功获得多次，并通过多次unlock解锁。如果是不同线程请求，则在加锁线程解锁时重新竞争；</span><br><span class="line">        * PTHREAD_MUTEX_ERRORCHECK_NP，检错锁，如果同一个线程请求同一个锁，则返回EDEADLK，否则与PTHREAD_MUTEX_TIMED_NP类型动作相同。这样就保证当不允许多次加锁时不会出现最简单情况下的死锁；</span><br><span class="line">        * PTHREAD_MUTEX_ADAPTIVE_NP，适应锁，动作最简单的锁类型，仅等待解锁后重新竞争；</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.</span> 加锁 <span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span>*mutex)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.</span> 解锁 <span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4.</span> 尝试锁 <span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>; <span class="comment">//锁被占用返回EBUSY，而非等待</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5.</span> 锁销毁 <span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_destroy</span> <span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="线程锁的封装-1"><a href="#线程锁的封装-1" class="headerlink" title="线程锁的封装"></a>线程锁的封装</h3><h4 id="线程锁异常"><a href="#线程锁异常" class="headerlink" title="线程锁异常"></a>线程锁异常</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">YR_ThreadMutex_Exception</span> :</span> <span class="keyword">public</span> YR_Lock_Exception</span><br><span class="line">&#123;</span><br><span class="line">    YR_ThreadMutex_Exception(<span class="keyword">const</span> <span class="built_in">string</span> &amp;buffer) : YR_Lock_Exception(buffer)&#123;&#125;;</span><br><span class="line">    YR_ThreadMutex_Exception(<span class="keyword">const</span> <span class="built_in">string</span> &amp;buffer, <span class="keyword">int</span> err) : YR_Lock_Exception(buffer, err)&#123;&#125;;</span><br><span class="line">    ~YR_ThreadMutex_Exception() <span class="keyword">throw</span>() &#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="线程锁的定义"><a href="#线程锁的定义" class="headerlink" title="线程锁的定义"></a>线程锁的定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YR_ThreadMutex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">YR_ThreadMutex();</span><br><span class="line">    <span class="keyword">virtual</span> ~YR_ThreadMutex();</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//解锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//尝试锁</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">tryLock</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">pthread_mutex_t</span> _mutex;<span class="comment">//创建线程锁</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>锁的初始化可以放在构造函数里，这里分为四步来初始化线程锁<code>_mutex</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">YR_ThreadMutex::YR_ThreadMutex()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> rc;</span><br><span class="line">    <span class="keyword">pthread_mutexattr_t</span> attr;<span class="comment">//1. 创建线程锁属性对象</span></span><br><span class="line">    rc = pthread_mutexattr_init(&amp;attr);<span class="comment">//初始化锁属性对象</span></span><br><span class="line">    assert(rc == <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 将锁属性中的锁类型设为检错锁</span></span><br><span class="line">    rc = pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_ERRORCHECK);</span><br><span class="line">    assert(rc == <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. 初始化锁对象</span></span><br><span class="line">    rc = pthread_mutex_init(&amp;_mutex, &amp;attr);</span><br><span class="line">    assert(rc == <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4. 销毁锁属性对象</span></span><br><span class="line">    rc = pthread_mutexattr_destroy(&amp;attr);</span><br><span class="line">    assert(rc == <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果操作不成功，则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span>(rc != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> TC_ThreadMutex_Exception(<span class="string">"[TC_ThreadMutex::TC_ThreadMutex] pthread_mutexattr_init error"</span>, rc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程锁在析构函数中销毁：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">YR_ThreadMutex::~YR_ThreadMutex()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> rc = <span class="number">0</span>;</span><br><span class="line">    rc = pthread_mutex_destroy(&amp;_mutex);</span><br><span class="line">    <span class="keyword">if</span>(rc != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"[YR_ThreadMutex::~YR_ThreadMutex] pthread_mutex_destroy error:"</span> &lt;&lt; <span class="built_in">string</span>(strerror(rc)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> YR_ThreadMutex::lock() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> rc = pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">    <span class="keyword">if</span>(rc != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(rc == EDEADLK)<span class="comment">//如果当前线程已经拥有线程锁</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> YR_ThreadMutex_Exception(<span class="string">"[YR_ThreadMutex::lock] pthread_mutex_lock dead lock error"</span>, rc);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> YR_ThreadMutex_Exception(<span class="string">"[YR_ThreadMutex::lock] pthread_mutex_lock error"</span>, rc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> YR_ThreadMutex::unlock() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> rc = pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">    <span class="keyword">if</span>(rc != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> YR_ThreadMutex_Exception(<span class="string">"[YR_ThreadMutex::unlock] pthread_mutex_unlock error"</span>, rc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="尝试锁"><a href="#尝试锁" class="headerlink" title="尝试锁"></a>尝试锁</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> YR_ThreadMutex::tryLock() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> rc = pthread_mutex_trylock(&amp;_mutex);</span><br><span class="line">    <span class="keyword">if</span>(rc != <span class="number">0</span> &amp;&amp; rc != EBUSY)<span class="comment">//如果所占用则返回EBUSY</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(rc == EDEADLK)<span class="comment">//如果当前线程已经拥有线程锁</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> YR_ThreadMutex_Exception(<span class="string">"[YR_ThreadMutex::tryLock] pthread_mutex_trylock dead lock error"</span>, rc);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> YR_ThreadMutex_Exception(<span class="string">"[YR_ThreadMutex::tryLock] pthread_mutex_trylock error"</span>, rc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (rc == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="嵌套锁的封装"><a href="#嵌套锁的封装" class="headerlink" title="嵌套锁的封装"></a>嵌套锁的封装</h3><h4 id="嵌套锁的定义"><a href="#嵌套锁的定义" class="headerlink" title="嵌套锁的定义"></a>嵌套锁的定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YR_ThreadRecMutex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * @brief 构造函数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    YR_ThreadRecMutex();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * @brief 析够函数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">virtual</span> ~YR_ThreadRecMutex();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * @brief 锁, 调用pthread_mutex_lock. </span></span><br><span class="line"><span class="comment">    *  </span></span><br><span class="line"><span class="comment">    * return : 返回pthread_mutex_lock的返回值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * @brief 解锁, pthread_mutex_unlock. </span></span><br><span class="line"><span class="comment">    *  </span></span><br><span class="line"><span class="comment">    * return : 返回pthread_mutex_lock的返回值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">unlock</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * @brief 尝试锁, 失败抛出异常. </span></span><br><span class="line"><span class="comment">    *  </span></span><br><span class="line"><span class="comment">    * return : true, 成功锁; false 其他线程已经锁了</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">tryLock</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 加锁后调用unlock是否会解锁, 给TC_Monitor使用的</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @return bool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">willUnlock</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 友元类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">TC_ThreadCond</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 计数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 计数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> c)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    锁对象</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">pthread_mutex_t</span> _mutex;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">int</span> _count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">YR_ThreadRecMutex::YR_ThreadRecMutex()</span><br><span class="line">: _count(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> rc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_mutexattr_t</span> attr;</span><br><span class="line">    <span class="comment">//1. 线程属性的初始化</span></span><br><span class="line">    rc = pthread_mutexattr_init(&amp;attr);</span><br><span class="line">    <span class="keyword">if</span>(rc != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> YR_ThreadMutex_Exception(<span class="string">"[YR_ThreadRecMutex::YR_ThreadRecMutex] pthread_mutexattr_init error"</span>, rc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 设置线程锁类型，PTHREAD_MUTEX_RECURSIVE为嵌套锁</span></span><br><span class="line">    rc = pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line">    <span class="keyword">if</span>(rc != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> YR_ThreadMutex_Exception(<span class="string">"[YR_ThreadRecMutex::YR_ThreadRecMutex] pthread_mutexattr_settype error"</span>, rc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 初始化线程</span></span><br><span class="line">    rc = pthread_mutex_init(&amp;_mutex, &amp;attr);</span><br><span class="line">    <span class="keyword">if</span>(rc != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> YR_ThreadMutex_Exception(<span class="string">"[YR_ThreadRecMutex::YR_ThreadRecMutex] pthread_mutex_init error"</span>, rc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 销毁线程属性对象</span></span><br><span class="line">    rc = pthread_mutexattr_destroy(&amp;attr);</span><br><span class="line">    <span class="keyword">if</span>(rc != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> YR_ThreadMutex_Exception(<span class="string">"[YR_ThreadRecMutex::YR_ThreadRecMutex] pthread_mutexattr_destroy error"</span>, rc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">YR_ThreadRecMutex::~YR_ThreadRecMutex()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (_count)</span><br><span class="line">    &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rc = <span class="number">0</span>;</span><br><span class="line">    rc = pthread_mutex_destroy(&amp;_mutex);<span class="comment">//销毁线程</span></span><br><span class="line">    <span class="keyword">if</span>(rc != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"[YR_ThreadRecMutex::~YR_ThreadRecMutex] pthread_mutex_destroy error:"</span> &lt;&lt; <span class="built_in">string</span>(strerror(rc)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="加锁-1"><a href="#加锁-1" class="headerlink" title="加锁"></a>加锁</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> YR_ThreadRecMutex::lock() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> rc = pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">    <span class="keyword">if</span>(rc != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//嵌套锁不用判断EDEADLK</span></span><br><span class="line">        <span class="keyword">throw</span> YR_ThreadMutex_Exception(<span class="string">"[YR_ThreadRecMutex::lock] pthread_mutex_lock error"</span>,rc);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//只是计数加1，pthread_mutex_unlock避免锁叠加</span></span><br><span class="line">    <span class="keyword">if</span>(++_count &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rc = pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">        assert(rc == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="解锁-1"><a href="#解锁-1" class="headerlink" title="解锁"></a>解锁</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> YR_ThreadRecMutex::unlock() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//当计数只有1的时候进行解锁操作，大于1的情况只是计数减一即可</span></span><br><span class="line">    <span class="keyword">if</span>(--_count == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> rc = <span class="number">0</span>;</span><br><span class="line">        rc = pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">        <span class="keyword">return</span> rc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="尝试锁-1"><a href="#尝试锁-1" class="headerlink" title="尝试锁"></a>尝试锁</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> YR_ThreadRecMutex::tryLock() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> rc = pthread_mutex_trylock(&amp;_mutex);</span><br><span class="line">    <span class="keyword">if</span>(rc != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(rc != EBUSY)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> YR_ThreadMutex_Exception(<span class="string">"[YR_ThreadRecMutex::tryLock] pthread_mutex_trylock error"</span>, rc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(++_count &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rc = pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">        <span class="keyword">if</span>(rc != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> YR_ThreadMutex_Exception(<span class="string">"[YR_ThreadRecMutex::tryLock] pthread_mutex_unlock error"</span>, rc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (rc == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> YR_ThreadRecMutex::count() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> c   = _count;</span><br><span class="line">    _count  = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> YR_ThreadRecMutex::count(<span class="keyword">int</span> c) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    _count = c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="unlock-之后是否会解锁"><a href="#unlock-之后是否会解锁" class="headerlink" title="unlock()之后是否会解锁"></a>unlock()之后是否会解锁</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> YR_ThreadRecMutex::willUnlock() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _count == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;线程锁的封装&quot;&gt;&lt;a href=&quot;#线程锁的封装&quot; class=&quot;headerlink&quot; title=&quot;线程锁的封装&quot;&gt;&lt;/a&gt;线程锁的封装&lt;/h2&gt;&lt;h3 id=&quot;线程锁的基本操作：&quot;&gt;&lt;a href=&quot;#线程锁的基本操作：&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="-C++" scheme="http://yourenit.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>异常的封装</title>
    <link href="http://yourenit.top/uncategorized/%E5%BC%82%E5%B8%B8%E7%9A%84%E5%B0%81%E8%A3%85/"/>
    <id>http://yourenit.top/uncategorized/异常的封装/</id>
    <published>2019-08-26T02:21:52.857Z</published>
    <updated>2019-08-26T04:07:07.761Z</updated>
    
    <content type="html"><![CDATA[<h2 id="异常的封装"><a href="#异常的封装" class="headerlink" title="异常的封装"></a>异常的封装</h2><p>这里展示的是自定义异常类，继承与<code>exception</code>类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> youren &#123;</span><br><span class="line"><span class="comment">////////////////////////////////////////////////</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YR_Exception</span> :</span> <span class="keyword">public</span> exception</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">YR_Exception(<span class="keyword">const</span> <span class="built_in">string</span>&amp; buffer);</span><br><span class="line">YR_Exception(<span class="keyword">const</span> <span class="built_in">string</span>&amp; buffer, <span class="keyword">int</span> err);</span><br><span class="line">~YR_Exception() <span class="keyword">throw</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误信息</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">what</span><span class="params">()</span> <span class="keyword">const</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//获取错误码</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getErrCode</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> _code;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getBacktrace</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">string</span> _buffer;</span><br><span class="line"><span class="keyword">int</span> _code;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"util/YR_Exception.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;execinfo.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> youren</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">YR_Exception::YR_Exception(<span class="keyword">const</span> <span class="built_in">string</span> &amp;buffer)</span><br><span class="line">:_buffer(buffer), _code(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">YR_Exception::YR_Exception(<span class="keyword">const</span> <span class="built_in">string</span> &amp;buffer, <span class="keyword">int</span> err)</span><br><span class="line">&#123;</span><br><span class="line">    _buffer = buffer + <span class="string">" :"</span> + strerror(err);</span><br><span class="line">    _code   = err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">YR_Exception::~YR_Exception() <span class="keyword">throw</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* YR_Exception::what() <span class="keyword">const</span> <span class="keyword">throw</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _buffer.c_str();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> YR_Exception::getBacktrace()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> * <span class="built_in">array</span>[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">int</span> nSize = backtrace(<span class="built_in">array</span>, <span class="number">64</span>);</span><br><span class="line">    <span class="keyword">char</span> ** symbols = backtrace_symbols(<span class="built_in">array</span>, nSize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        _buffer += symbols[i];</span><br><span class="line">        _buffer += <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(symbols);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;异常的封装&quot;&gt;&lt;a href=&quot;#异常的封装&quot; class=&quot;headerlink&quot; title=&quot;异常的封装&quot;&gt;&lt;/a&gt;异常的封装&lt;/h2&gt;&lt;p&gt;这里展示的是自定义异常类，继承与&lt;code&gt;exception&lt;/code&gt;类。&lt;/p&gt;
&lt;figure class
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yourenit.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++新特性之完美转发</title>
    <link href="http://yourenit.top/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/"/>
    <id>http://yourenit.top/C-学习笔记/C-新特性之完美转发/</id>
    <published>2018-09-24T13:45:07.000Z</published>
    <updated>2018-09-24T13:47:14.104Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章中，我们了解了什么是右值引用。</p><p>这篇文章则是了解<code>C++11</code>如何解决右值引用的一个实际问题：转发问题。</p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>我们考虑一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void process_func(MySTring t)&#123;&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">void forward_func(T&amp;&amp; t)&#123;</span><br><span class="line">    process_func(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //以上篇右值引用实现的MyString类为测试对象</span><br><span class="line">    forward_func(MyString(&quot;Hello&quot;));</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从代码来看，我们的<code>forward_func</code>函数传入的参数是一个右值引用，那么<code>process_func</code>的参数是不是也是右值引用呢？让我们看一下结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Construct</span><br><span class="line">Copy Construct</span><br><span class="line">Destruct</span><br><span class="line">Destruct</span><br></pre></td></tr></table></figure></p><p>从结果中，我们可以看到，构造临时变量之后，便执行了拷贝构造函数，也就是说，传进<code>process_func</code>的不是右值，而是左值。这显然不是我们想要的结果，我们希望<code>process_func</code>传入的参数也是右值，该怎么做？我们将需要从一个函数中的一个或者多个实参连同其类型完整的转发给其他函数，称之为“完美转发”。</p><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>我们如果要做到完美转发，该怎么做呢？<br><code>C++11</code>给出了我们答案：引入一条新语言规则——引用折叠，并结合新的模板推导规则来完成完美转发。</p><p>引用折叠：</p><table><br><thead><br><tr><br>  <th>折叠前</th><br>  <th>折叠后</th><br>  <th>注释</th><br></tr><br></thead><br><tbody><tr><br>  <td>A&amp; &amp;</td><br>  <td>A&amp;</td><br>  <td>指向左值引用的左值引用折叠/崩塌为左值引用</td><br></tr><br><tr><br>  <td>A&amp; &amp;&amp;</td><br>  <td>A&amp;</td><br>  <td>指向左值引用的右值引用折叠/崩塌为左值引用</td><br></tr><br><tr><br>  <td>A&amp;&amp; &amp;</td><br>  <td>A&amp;</td><br>  <td>指向右值引用的左值引用折叠/崩塌为左值引用</td><br></tr><br><tr><br>  <td>A&amp;&amp; &amp;&amp;</td><br>  <td>A&amp;&amp;</td><br>  <td>指向右值引用的右值引用折叠/崩塌为右值引用</td><br></tr><br></tbody></table><p>从上表可以看出，当<code>forward_func</code>函数传入左值引用的时候，<code>process_func</code>的参数类型被折叠成左值引用，当<code>forward_func</code>函数传入右值引用的时候普，<code>process_func</code>的参数类型被折叠成右值引用。具体我们看下例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void process_func(MyString&amp;&amp; t)&#123;</span><br><span class="line">    cout&lt;&lt;&quot; rvalue ref&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">void process_func(MyString&amp; t)&#123;</span><br><span class="line">    cout&lt;&lt;&quot;lvalue ref&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">void forward_func(T&amp;&amp; t)&#123;</span><br><span class="line">    //cout&lt;&lt;typeid(t).name()&lt;&lt;endl;</span><br><span class="line">    //cout&lt;&lt;&quot;forward_value&quot;&lt;&lt;endl;</span><br><span class="line">    process_func(forward&lt;T&gt;(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    MyString str=&quot;World!&quot;;</span><br><span class="line">    forward_func(str);      //传入左值</span><br><span class="line"></span><br><span class="line">    forward_func(MyString(&quot;Hello&quot;));    //传入右值</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Construct</span><br><span class="line">Move Construct</span><br><span class="line">Destruct</span><br><span class="line">lvalue ref          //MyString str=&quot;World!&quot;;  forward_func(str);</span><br><span class="line">Construct</span><br><span class="line">rvalue ref          //forward_func(MyString(&quot;Hello&quot;)); </span><br><span class="line">Destruct</span><br><span class="line">Destruct</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在上一篇文章中，我们了解了什么是右值引用。&lt;/p&gt;
&lt;p&gt;这篇文章则是了解&lt;code&gt;C++11&lt;/code&gt;如何解决右值引用的一个实际问题：转发问题。&lt;/p&gt;
&lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
      <category term="C++学习笔记" scheme="http://yourenit.top/categories/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://yourenit.top/tags/C/"/>
    
      <category term="新特性" scheme="http://yourenit.top/tags/%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
      <category term="编程" scheme="http://yourenit.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>右值引用和移动构造函数</title>
    <link href="http://yourenit.top/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <id>http://yourenit.top/C-学习笔记/右值引用和移动构造函数/</id>
    <published>2018-09-22T11:42:20.000Z</published>
    <updated>2018-09-22T11:45:07.104Z</updated>
    
    <content type="html"><![CDATA[<p>在了解右值引用之前，我们先复习什么左值、右值？什么是引用？</p><h3 id="左值、右值"><a href="#左值、右值" class="headerlink" title="左值、右值"></a>左值、右值</h3><p>在<code>C</code>语言中，左值可以位于赋值语句的左侧，右值则不能。<br>具体可以参考<a href="https://zh.cppreference.com/w/c/language/value_category" target="_blank" rel="noopener">C值类别</a>。</p><p>在<code>C++</code>中，每个表达式属于三种基本值之一：纯右值、亡值、左值。<br>具体参考<a href="https://zh.cppreference.com/w/cpp/language/value_category" target="_blank" rel="noopener">C++值类别</a>。</p><p>在<code>C++ Prime</code>中，对左值和右值的区别做了一个简单的归纳：</p><ol><li><strong>当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。</strong></li><li><strong>左值有持久的状态，而右值要么是字面常量，要么是表达式求值过程中创建的临时对象。</strong></li></ol><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用是为一个已经存在的对象或者函数起一个别名。并不是将这个对象或者函数拷贝给引用。通常用<code>&amp;</code>定义引用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a=123;</span><br><span class="line">int &amp;b=a;           //它相当于给a起个别名为b</span><br><span class="line"></span><br><span class="line">b=456;              //对引用的操作实在与之绑定的对象上进行的</span><br></pre></td></tr></table></figure></p><h4 id="引用的注意事项"><a href="#引用的注意事项" class="headerlink" title="引用的注意事项"></a>引用的注意事项</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int &amp;c=1;           //错误，引用类型的初始值必须是一个对象</span><br><span class="line">const int &amp;d=2;     //正确，d为一个常量引用</span><br><span class="line"></span><br><span class="line">double &amp;e=a;        //错误引用类型必须是int类型对象</span><br></pre></td></tr></table></figure><p>当我们复习完上面所有知识之后，我们来了解什么是左值引用、右值引用？</p><h3 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h3><p>左值引用用于对已经存在的对象起一个别名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#icnldue &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string s=&quot;Hello&quot;;</span><br><span class="line">    string&amp; r1s;</span><br><span class="line">    const string&amp;r2=s;</span><br><span class="line">    </span><br><span class="line">    r1+=&quot; World!&quot;;      //可以修改s</span><br><span class="line">    r2+=&quot; World!&quot;;      //不可以修改，r2为常量引用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也可以用于函数调用实现引用传递：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void print(string&amp; str)&#123;</span><br><span class="line">    str+=&quot; World!&quot;;</span><br><span class="line">    cout&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string str=&quot;Hello&quot;;</span><br><span class="line">    print(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>函数的返回值是左值引用时，函数调用表达式成为左值表达式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">char&amp; print_char(string&amp; str,size_t n)&#123;</span><br><span class="line">    return str.at(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string str=&quot;Hello&quot;;</span><br><span class="line">    print(str,0)=&apos;C&apos;;   //函数调用是左值，可以被赋值</span><br><span class="line">    cout&lt;&lt;str&lt;&lt;endl;    //输出Cello</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在C++中，我们常见的左值返回还有赋值、下标、解引用、和前置递增/递减运算符，他们的返回值都是可以被修改的。</span><br></pre></td></tr></table></figure></p><p>但是，对于一些要求转换的表达式、字面常量或是返回右值的表达式，左值引用就无能为力了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string &amp; print(string &amp; str)&#123;</span><br><span class="line">    return str+&quot; world!&quot;;       //编译器报错，非常量引用的初始值必须为左值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们知道<code>str+&quot; world!&quot;</code>为右值，我们将返回类型改为常量类型，就不会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const string &amp; print(string &amp; str)&#123;</span><br><span class="line">    return str+&quot; world!&quot;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们调用一下，试试看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const string&amp; str2=print(str);</span><br><span class="line">cout&lt;&lt;str2&lt;&lt;endl;</span><br></pre></td></tr></table></figure></p><p>此时，我们发现，输出的结果是乱码，调试发现，<code>str2</code>中根本没有值。这是因为函数调用产生一个临时对象，引用则将绑定这个临时对象，当函数调用完毕将临时对象销毁，引用将失效，所以返回乱码。</p><p>那么问题该怎么解决呢？就函数来看，毕竟返回引用类型要比返回值类型要高效，不用将临时对象的值拷贝给新的对象，而是“偷了”临时对象的值。</p><p><code>C++11</code>为我们则引入了一种新的类型————右值引用。</p><h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>新标准中用<code>&amp;&amp;</code>来定义右值引用，右值引用指向的是临时对象，因此延长了临时对象的生存期。这种“偷”走临时变量的行为，被称为“移动语义”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string s1=&quot;Hello&quot;;</span><br><span class="line">    string &amp;&amp; r=s1+s1;      //s1+s1创建一个临时对象</span><br><span class="line">    r+=&quot; World!&quot;;</span><br><span class="line">    cout&lt;&lt;r&lt;&lt;endl;      //输出Hello Hello World!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在新标准中，我们还可以显式的将一个左值转换为对应的右值引用类型——<code>move</code>函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i=10;  </span><br><span class="line">int &amp;&amp; k=std::move(i);</span><br><span class="line">cout&lt;&lt;&amp;i&lt;&lt;&quot; &quot;&lt;&lt;&amp;k&lt;&lt;endl;        //i和k的地址相同</span><br></pre></td></tr></table></figure></p><p>既然我们可以延长临时对象的生存期，并减少对象的拷贝操作，我们在自己的类中如果也支持移动操作，那么也提高不少效率。</p><h3 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h3><p>我们需要定义移动构造函数和移动赋值运算符。这两个成员类似于对应的拷贝操作，但它们是从给定的对象“窃取”资源而不是拷贝资源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class MyString &#123;</span><br><span class="line">private:</span><br><span class="line">char* data;</span><br><span class="line">size_t len;</span><br><span class="line">public:</span><br><span class="line">MyString():data(nullptr),len(0)&#123;&#125;</span><br><span class="line">MyString(const char* p):data(new char[strlen(p)+1]),len(strlen(p))&#123;</span><br><span class="line">strcpy(data, p);</span><br><span class="line">cout &lt;&lt; &quot;Construct: &quot; &lt;&lt; ++cstr &lt;&lt; endl;</span><br><span class="line">&#125;//构造函数</span><br><span class="line">MyString(const MyString&amp; str) :data(new char[strlen(str.data) + 1]), len(strlen(str.data)) &#123;</span><br><span class="line">strcpy(this-&gt;data, str.data);</span><br><span class="line">cout &lt;&lt; &quot;Copy Construct: &quot; &lt;&lt; ++cptr &lt;&lt; endl;</span><br><span class="line">&#125;//拷贝构造函数</span><br><span class="line"></span><br><span class="line">~MyString() &#123; </span><br><span class="line">delete data; </span><br><span class="line">cout &lt;&lt; &quot;Destruct: &quot; &lt;&lt; ++dstr &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">static int cstr;        //构造函数调用次数</span><br><span class="line">static int dstr;        //析构函数调用次数</span><br><span class="line">static int cptr;        //拷贝构造函数调用次数</span><br><span class="line">//static int mvtr;        //移动构造函数调用次数</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int MyString::cstr = 0;</span><br><span class="line">int MyString::dstr = 0;</span><br><span class="line">int MyString::cptr = 0;</span><br><span class="line">//int MyString::mvtr = 0;</span><br><span class="line"></span><br><span class="line">MyString GetStr() &#123; return MyString(&quot;Hello&quot;); &#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    MyString str=MyStriung(&quot;Hello&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面中的静态变量用来输出各种函数调用的次数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">在g++上的运行结果为：</span><br><span class="line">Construct: 1</span><br><span class="line">Copy Construct: 1</span><br><span class="line">Destruct: 1</span><br><span class="line">Copy Construct: 2</span><br><span class="line">Destruct: 2</span><br><span class="line">Destruct: 3</span><br><span class="line"></span><br><span class="line">在vs上的结果为：</span><br><span class="line">Construct: 1</span><br><span class="line">Copy Construct: 1</span><br><span class="line">Destruct: 1</span><br><span class="line">    </span><br><span class="line">vs将其优化了，用g++的-fno-elide-constructors参数就不会被优化。</span><br></pre></td></tr></table></figure></p><p>可以看出，拷贝构造函数被调用了两次，一次是将构造的变量拷贝构造给临时值，用来做<code>GetStr</code>的返回值，另一次是由临时值构造出<code>main</code>函数中的变量<code>str</code>。</p><p>如果字符串的数据很大的话，那么花在拷贝上的时间比较大了，效率就会大大降低。如果我们将临时对象的值“偷”过来，那效率会有什么变化呢？<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们在上述类中添加移动构造函数</span></span><br><span class="line">MyString(MyString &amp;&amp;str)&#123;</span><br><span class="line">    len=str.len;</span><br><span class="line">    <span class="keyword">this</span>-&gt;data=str.data;</span><br><span class="line">    str.len=<span class="number">0</span>;</span><br><span class="line">    str.data=<span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">MyString <span class="title">GetStr</span><span class="params">()</span></span>&#123; MyString str=<span class="string">"Hello"</span>; <span class="keyword">return</span> str;&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">运行结果为：</span><br><span class="line">Construct: 1</span><br><span class="line">Move Construct: 1</span><br><span class="line">Destruct: 1</span><br><span class="line">Move Construct: 2</span><br><span class="line">Destruct: 2</span><br><span class="line">Destruct: 3</span><br></pre></td></tr></table></figure><p>从结果可以看到，没有执行拷贝构造函数，而是执行的是移动构造函数。虽然在此没有将临时值和mian函数中str的成员变量地址输出出来，但是他们的地址是相同的。这就省去了再申请内存和拷贝的时间，效率也提高了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在了解右值引用之前，我们先复习什么左值、右值？什么是引用？&lt;/p&gt;
&lt;h3 id=&quot;左值、右值&quot;&gt;&lt;a href=&quot;#左值、右值&quot; class=&quot;headerlink&quot; title=&quot;左值、右值&quot;&gt;&lt;/a&gt;左值、右值&lt;/h3&gt;&lt;p&gt;在&lt;code&gt;C&lt;/code&gt;语言中，左值
      
    
    </summary>
    
      <category term="C++学习笔记" scheme="http://yourenit.top/categories/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://yourenit.top/tags/C/"/>
    
      <category term="新特性" scheme="http://yourenit.top/tags/%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
      <category term="编程" scheme="http://yourenit.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Haskell初步</title>
    <link href="http://yourenit.top/Haskell%E5%AD%A6%E4%B9%A0/Haskell%E5%88%9D%E6%AD%A5/"/>
    <id>http://yourenit.top/Haskell学习/Haskell初步/</id>
    <published>2018-09-21T08:15:30.000Z</published>
    <updated>2018-09-21T08:17:14.164Z</updated>
    
    <content type="html"><![CDATA[<h3 id="函数的定义和调用"><a href="#函数的定义和调用" class="headerlink" title="函数的定义和调用"></a>函数的定义和调用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//函数名 参数1 参数2 ... = 函数体</span><br><span class="line"></span><br><span class="line">doubleMe x=x+x</span><br><span class="line"></span><br><span class="line">doubleUs x y= x*2 + y*2</span><br><span class="line"></span><br><span class="line">//可在其他函数中调用你编写的函数</span><br><span class="line">doubleUs x y = doubleMe x + doubleMe y</span><br><span class="line">//很符合我们数学中公式的组合f(x)=g(x)+h(x)+...</span><br></pre></td></tr></table></figure><p><code>Haskell</code>中函数没有顺序，无论先声明<code>doubleMe</code>还是<code>doubleUs</code>都是一样的。</p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">//定义，所有元素必须相同类型</span><br><span class="line">let lostNumber=[1,2,3,4]</span><br><span class="line"></span><br><span class="line">//两个list合并</span><br><span class="line">let lostNumber2=[5,6,7,8]</span><br><span class="line">lostNumber ++ lostNumber2</span><br><span class="line"></span><br><span class="line">//索引 !!</span><br><span class="line">lostNumber !!2  //2为下标</span><br><span class="line"></span><br><span class="line">//比较大小</span><br><span class="line">lostNumber &gt; lostNumber2    //返回False</span><br><span class="line">[2.1,3.1,4.1] &gt; [2,3,4]     //返回True</span><br><span class="line">lostNumber == lostNumber2   //返回False</span><br><span class="line"></span><br><span class="line">//常用搭配函数：</span><br><span class="line">head lostNumber         //返回list的第一个元素</span><br><span class="line">last lostNumber         //返回list的最后一个元素</span><br><span class="line">tail lostNumber         //返回除去第一个元素之后的部分</span><br><span class="line">init lostNumber         //返回除去最后一个元素之前的部分</span><br><span class="line">length lostNumber       //返回list的长度</span><br><span class="line">null lostNumber         //检查list是否为空，空则返回True</span><br><span class="line">reverse lostNumber      //将list反转</span><br><span class="line">take 3 lostNumber       //返回list的前几个元素，3指定返回前3个元素</span><br><span class="line">drop 3 lostNumber       //删除list前几个元素</span><br><span class="line">maximum lostNumber      //返回list中最大的元素</span><br><span class="line">minimum lostNumber      //返回list中最小的元素</span><br><span class="line">sum lostNumber          //返回list所有元素之和</span><br><span class="line">profuct lostNumber      //返回list中所有元素之积</span><br><span class="line"></span><br><span class="line">4 `elem` lostNumber      //判断一个元素是否在一个list中</span><br><span class="line"></span><br><span class="line">[1..20]                 //定义一个从1到20的list</span><br><span class="line">[20,19..1]              //[20..1]是不可以的</span><br><span class="line">//也可以是字符</span><br><span class="line">[&apos;a&apos;..&apos;z&apos;]              //返回&quot;abcdefghijklmnopqrstuvwxyz&quot;</span><br><span class="line">[&apos;A&apos;..&apos;z&apos;]              //返回&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz&quot;</span><br><span class="line">//设置步长</span><br><span class="line">[2,4..20]              //返回[2,4,6,8,10,12,14,16,18,20]</span><br><span class="line"></span><br><span class="line">//不标明上限</span><br><span class="line">take 24 [13,26..]           //用多少取多少</span><br><span class="line">[13.26..]                   //不停输出</span><br><span class="line"></span><br><span class="line">repeat接受一个值作为参数，返回一个仅包含该值的无限List</span><br><span class="line">cycle则是接受一个list，并无限输出</span><br><span class="line"></span><br><span class="line">replicate 3 10              //得到包含3个元素相同的list</span><br></pre></td></tr></table></figure><p>我们也可以表达数学中的集合：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S=&#123;2*x | x\in N,x\leq10&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[x*2 | x&lt;-[1..10]]          //返回[2,4,6,8,10,12,14,16,18,20]</span><br><span class="line">[x*2 | x&lt;-[1..10], x*2 &gt;= 12]   //返回[12,14,16,18,20]</span><br></pre></td></tr></table></figure><h3 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fst (8,11)              //返回一个序对的首项</span><br><span class="line">snd (8,11)              //返回一个序对的尾项</span><br><span class="line">//不能用于三元组或四元组以上</span><br><span class="line"></span><br><span class="line">zip [1,2,3,4] [7,8,9]   //zip用来生成一组序对的list</span><br><span class="line">//返回[(1,7),(2,8),(3,9)]</span><br></pre></td></tr></table></figure><p>解决一个问题：如何取得所有三边长度皆为整数且小于等于10，周长为24的直角三角形？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let rightTriangles = [ (a,b,c) | c&lt;-[1..10], b&lt;-[1..c], a&lt;-[1..b], a^2 + b^2 == c^2,a+b+c==24]</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;函数的定义和调用&quot;&gt;&lt;a href=&quot;#函数的定义和调用&quot; class=&quot;headerlink&quot; title=&quot;函数的定义和调用&quot;&gt;&lt;/a&gt;函数的定义和调用&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl
      
    
    </summary>
    
      <category term="Haskell学习" scheme="http://yourenit.top/categories/Haskell%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="编程" scheme="http://yourenit.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Haskell" scheme="http://yourenit.top/tags/Haskell/"/>
    
  </entry>
  
  <entry>
    <title>C++新特性之Variadic Template</title>
    <link href="http://yourenit.top/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BVariadic-Template%EF%BC%88%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF%EF%BC%89/"/>
    <id>http://yourenit.top/C-学习笔记/C-新特性之Variadic-Template（可变参数模板）/</id>
    <published>2018-09-20T16:41:55.000Z</published>
    <updated>2018-09-20T16:43:19.695Z</updated>
    
    <content type="html"><![CDATA[<h3 id="可变参数模板的定义"><a href="#可变参数模板的定义" class="headerlink" title="可变参数模板的定义"></a>可变参数模板的定义</h3><p>可变参数模板是至少有一个参数宝的模板，参数包则是可以接受零个或者更多模板实参的模板形参，其格式如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> ...<span class="title">T</span>&gt; <span class="title">class</span> <span class="title">classname</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> ...<span class="title">T</span>&gt; <span class="title">void</span> <span class="title">func</span>(<span class="title">T</span> ...<span class="title">args</span>);</span></span><br></pre></td></tr></table></figure></p><p>其中<code>T</code>为模板参数包，<code>args</code>为函数参数包。</p><p>可变参数模板可以用任意数量的模板参数实例化：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Myclass</span>&#123;</span>&#125;;</span><br><span class="line">Myclass&lt;&gt; t0;           <span class="comment">//T 不包含实参</span></span><br><span class="line">Myclass&lt;<span class="keyword">int</span>&gt; t1;        <span class="comment">//T 包含一个实参，类型为int</span></span><br><span class="line">Myclass&lt;<span class="keyword">int</span>,<span class="keyword">float</span>&gt; t2;  <span class="comment">//T 包含两个实参，类型为int和float</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//模板参数包必须是模板参数列表中的最后一个形参。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... T,<span class="keyword">typename</span> U&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Invalid</span>;</span>    <span class="comment">//错误</span></span><br></pre></td></tr></table></figure></p><p>可变参数函数模板可以用任意数量的函数实参调用：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">func</span>(<span class="title">T</span>... <span class="title">args</span>);</span></span><br><span class="line">func();        <span class="comment">//args不包含实参</span></span><br><span class="line">func(<span class="number">1</span>);        <span class="comment">//包含一个实参，类型为int</span></span><br><span class="line">func(<span class="number">1</span>,<span class="number">2.1</span>);    <span class="comment">//包含两个实参，类型为int和double</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//与类模板不同，函数模板参数包不必是模板参数列表中的最后一个，它可以在列表早于所有能从函数实参推导的参数出现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">T</span>,<span class="title">class</span> <span class="title">U</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">valid</span>(<span class="title">U</span>,<span class="title">T</span>...);</span>     <span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line">valid(<span class="number">1.0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);       <span class="comment">//推导U为double，T为&#123;int，int，int&#125;</span></span><br></pre></td></tr></table></figure></p><h3 id="包展开"><a href="#包展开" class="headerlink" title="包展开"></a>包展开</h3><p>包展开的场所不同，产生的逗号分隔列表种类不同：</p><ol><li><p>函数实参列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func(&amp;args...);         //展开成func(&amp;E1,&amp;E2,&amp;E3)</span><br><span class="line">func(++args...,n);      //展开成func(++E1,++E2,++E3,n)</span><br><span class="line">func(n,++args);         //展开成func(n,++E1,++E2,++E3)</span><br><span class="line">func(const_cast&lt;const Args*&gt;(&amp;args)...);    // func(const_cast&lt;const E1*&gt;(&amp;X1), const_cast&lt;const E2*&gt;(&amp;X2), const_cast&lt;const E3*&gt;(&amp;X3))</span><br><span class="line">func(h(args...) + args...); // 展开成 func(h(E1,E2,E3) + E1, h(E1,E2,E3) + E2, h(E1,E2,E3) + E3)</span><br></pre></td></tr></table></figure></li><li><p>有括号初始化器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class c1(&amp;args...);             // 调用 Class::Class(&amp;E1, &amp;E2, &amp;E3)</span><br><span class="line">Class c2 = Class(n, ++args...); // 调用 Class::Class(n, ++E1, ++E2, ++E3);</span><br></pre></td></tr></table></figure></li><li><p>花括号环绕的初始化器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class... T&gt; void func(T... args)</span><br><span class="line">&#123;</span><br><span class="line">    const int size=sizeof...(args);</span><br><span class="line">    int res[size]=&#123;args...&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>模板实参列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//包展开可以用于模板形参列表的任何位置，前提是模板拥有匹配展开的形参。</span><br><span class="line">template &lt;class A,class B,class... C&gt; void func(A arg1,B arg2,C... arg3)</span><br><span class="line">&#123;</span><br><span class="line">    container&lt;A,B,C...&gt; t1;     // 展开成 container&lt;A,B,E1,E2,E3&gt; </span><br><span class="line">    container&lt;C...,A,B&gt; t2;     // 展开成 container&lt;E1,E2,E3,A,B&gt; </span><br><span class="line">    container&lt;A,C...,B&gt; t3;      // 展开成 container&lt;A,E1,E2,E3,B&gt; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数形参列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename ...Ts&gt; void f(Ts...) &#123;&#125;</span><br><span class="line">f(&apos;a&apos;, 1);  // Ts... 展开成 void f(char, int)</span><br><span class="line">f(0.1);     // Ts... 展开成 void f(double)</span><br></pre></td></tr></table></figure></li><li><p>模板形参列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class ...T&gt; class Myclass</span><br><span class="line">&#123;</span><br><span class="line">    template&lt;T... Values&gt; // 展开成无类型模板参数列表，例如 &lt;int, char, int(&amp;)[5]&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>Lambda捕获</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class ...T&gt;</span><br><span class="line">void func(T... args)&#123;</span><br><span class="line">    auto g=[&amp;,args...]&#123;return h(args...);&#125;</span><br><span class="line">    g();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>sizeof…运算符</p></li><li>基类指定符和成员初始化列表<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class... Mixins&gt;</span><br><span class="line">class X : public Mixins... &#123;</span><br><span class="line"> public:</span><br><span class="line">    X(const Mixins&amp;... mixins) : Mixins(mixins)... &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void print()&#123;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T&gt; void print(const T&amp; t)&#123;</span><br><span class="line">    cout&lt;&lt; t &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class First,class... Rest&gt;void print(const First&amp; first,const Rest&amp;... rest)&#123;</span><br><span class="line">    cout&lt;&lt;first&lt;&lt;&quot;,&quot;;</span><br><span class="line">    print(rest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    print();</span><br><span class="line">    print(1);</span><br><span class="line">    </span><br><span class="line">    print(10,20);</span><br><span class="line">    print(100,200,300);</span><br><span class="line">    print(&quot;first&quot;,2,&quot;third&quot;,3.14159);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现<code>C</code>语言中的<code>printf</code>函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"> </span><br><span class="line">void tprintf(const char* format) // 基函数</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; format;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">template&lt;typename T, typename... Targs&gt;</span><br><span class="line">void tprintf(const char* format, T value, Targs... Fargs) // 递归变参数函数</span><br><span class="line">&#123;</span><br><span class="line">    for ( ; *format != &apos;\0&apos;; format++ ) &#123;</span><br><span class="line">        if ( *format == &apos;%&apos; ) &#123;</span><br><span class="line">           std::cout &lt;&lt; value;</span><br><span class="line">           tprintf(format+1, Fargs...); // 递归调用</span><br><span class="line">           return;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; *format;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    tprintf(&quot;% world% %\n&quot;,&quot;Hello&quot;,&apos;!&apos;,123);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;可变参数模板的定义&quot;&gt;&lt;a href=&quot;#可变参数模板的定义&quot; class=&quot;headerlink&quot; title=&quot;可变参数模板的定义&quot;&gt;&lt;/a&gt;可变参数模板的定义&lt;/h3&gt;&lt;p&gt;可变参数模板是至少有一个参数宝的模板，参数包则是可以接受零个或者更多模板实参的模板形
      
    
    </summary>
    
      <category term="C++学习笔记" scheme="http://yourenit.top/categories/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://yourenit.top/tags/C/"/>
    
      <category term="新特性" scheme="http://yourenit.top/tags/%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
      <category term="编程" scheme="http://yourenit.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++新特性之Type Alias、Template Alias、noexcept、override、final</title>
    <link href="http://yourenit.top/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BType-Alias%E3%80%81Template-Alias%E3%80%81noexcept%E3%80%81override%E3%80%81final/"/>
    <id>http://yourenit.top/C-学习笔记/C-新特性之Type-Alias、Template-Alias、noexcept、override、final/</id>
    <published>2018-09-19T12:49:13.000Z</published>
    <updated>2018-09-19T12:51:37.728Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Type-Alias（类型别名）and-Template-Alias（模板别名）"><a href="#1-Type-Alias（类型别名）and-Template-Alias（模板别名）" class="headerlink" title="1. Type Alias（类型别名）and Template Alias（模板别名）"></a>1. Type Alias（类型别名）and Template Alias（模板别名）</h3><p>在<code>C++11</code>中，我们不仅可以为类型定义别名，还可以对模板进行定义别名。</p><h4 id="别名声明的语法"><a href="#别名声明的语法" class="headerlink" title="别名声明的语法"></a>别名声明的语法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">using</span> identifier = type-id       <span class="comment">//identifier为引入的类型名，type-id为抽象声明器或者任何合法的type-id</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> <span class="keyword">template</span> &lt;<span class="keyword">template</span>-parameter-<span class="built_in">list</span>&gt;</span><br><span class="line">   <span class="keyword">using</span> identifier =type type-id</span><br></pre></td></tr></table></figure><p>类型别名声明和<code>typedef</code>的声明没有差别。</p><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">using</span> A = Base;</span><br><span class="line"><span class="comment">//等同于 typedef Base A;</span></span><br><span class="line">A *a = <span class="keyword">new</span> A(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> func=<span class="keyword">void</span> (*)(<span class="keyword">int</span>,<span class="keyword">int</span>);</span><br><span class="line"><span class="comment">//等同于typedef void (*func)(int,int);</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">example</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>&#123;&#125;</span><br><span class="line">func b=example;</span><br><span class="line"></span><br><span class="line"><span class="comment">//别名模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">using</span> <span class="title">point</span> = <span class="title">T</span>*;</span></span><br><span class="line">point&lt;<span class="keyword">const</span> <span class="keyword">char</span>&gt; str=<span class="string">"I Love C++"</span>;</span><br><span class="line"><span class="comment">//point&lt;const char&gt;为指向const char的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用于隐藏模板形参的别名模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">CharT</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">using</span> <span class="title">mystring</span> = <span class="title">std</span>:</span>:basic_string&lt;CharT, <span class="built_in">std</span>::char_traits&lt;CharT&gt;&gt;;</span><br><span class="line">mystring&lt;<span class="keyword">char</span>&gt; str;</span><br><span class="line"></span><br><span class="line">能引入成员<span class="keyword">typedef</span>名的别名模板</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">D</span>&#123;</span></span><br><span class="line">    <span class="keyword">using</span> value_type=T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">D</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">g</span>(<span class="title">const</span> <span class="title">D</span>&amp; <span class="title">c</span>)&#123;</span> <span class="keyword">typename</span> D::value_type n; &#125;</span><br><span class="line"><span class="keyword">const</span> D&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">g(d); </span><br><span class="line"><span class="comment">//通过typeid(n).name()可以获取n的类型为int</span></span><br></pre></td></tr></table></figure><h3 id="2-noexcept"><a href="#2-noexcept" class="headerlink" title="2. noexcept"></a>2. noexcept</h3><p>在<code>C++11</code>中，我们可以通过<code>noexcept</code>来指定某个函数不会抛出异常。</p><p>在<code>C++11</code>之前，通常使用如下方式实现不抛出异常：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void func() throw();</span><br><span class="line">//throw()的()中通常用来放置函数可以抛出异常的类型，如果为空，则不抛出任何异常。</span><br></pre></td></tr></table></figure></p><p><code>C++11</code>将<code>throw()</code>用<code>noexcept</code>替换，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void func() noexcept;</span><br></pre></td></tr></table></figure></p><p>事实上，<code>noexcept</code>指定符的用法不仅仅是替代<code>throw()</code>。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">noexcept(expression)</span><br><span class="line">//如果没有expression,expression默认为true,即不抛出任何异常。</span><br></pre></td></tr></table></figure><h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">指向不抛出函数的指针可赋值给指向潜在抛出函数的指针，反之不可。</span><br><span class="line">void f();   //潜在抛出</span><br><span class="line">void (*fn)() noexcept =ft;  //错误</span><br><span class="line"></span><br><span class="line">//若虚函数为不抛出，则所有声明，包括整个覆写的定义都必须是不抛出，除非覆写定义被删除。</span><br><span class="line">struct B&#123;</span><br><span class="line">    virtual void f() noexcept;</span><br><span class="line">    virtual void g();</span><br><span class="line">    virtual void h noexcept = delete;</span><br><span class="line">&#125;;</span><br><span class="line">struct D:B&#123;</span><br><span class="line">    void f();   //错误，D::f为潜在抛出，B::f为不抛出</span><br><span class="line">    void g() noexcept;  //正确</span><br><span class="line">    void h() = delete;  //正确</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//不抛出函数允许调用潜在抛出函数</span><br><span class="line">void func1();   //潜在抛出</span><br><span class="line">void func2() noexcept&#123;</span><br><span class="line">    f();    //合法</span><br><span class="line">    throw 10;   //合法，最终调用std::abort()终止程序</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-override"><a href="#3-override" class="headerlink" title="3. override"></a>3. override</h3><p>我们在学习C++虚函数的时候，要求派生类的虚函数要覆盖掉基类中对应的虚函数（函数参数、返回类型必须相同）,。比如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Base()&#123;&#125;</span><br><span class="line">        ~Base()&#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span>:<span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        A()&#123;&#125;</span><br><span class="line">        ~A()&#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>但是上面的代码有一个缺点：如果派生类中想要重新定义的函数却不小心写错了，基类的函数没有被覆盖，但是编译器没有报错，使得调试的时候很难发现。</p><p>在<code>C++11</code>中提供的<code>override</code>关键字可以解决这一问题，它标记派生类中的虚函数，如果基类中的虚函数没有被覆盖，编译器则报错。</p><h3 id="4-final"><a href="#4-final" class="headerlink" title="4. final"></a>4. final</h3><p>假若一个函数被指定为<code>final</code>，则说明该函数不可被覆盖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class A::public Base&#123;</span><br><span class="line">    public:</span><br><span class="line">        A()&#123;&#125;</span><br><span class="line">        ~A()&#123;&#125;</span><br><span class="line">        </span><br><span class="line">        void print(const char* str) final;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B:public A&#123;</span><br><span class="line">  public:</span><br><span class="line">    A()&#123;&#125;</span><br><span class="line">    ~A()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    void print(const char* str);</span><br><span class="line">    //编译器报错，print无法被重写</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Type-Alias（类型别名）and-Template-Alias（模板别名）&quot;&gt;&lt;a href=&quot;#1-Type-Alias（类型别名）and-Template-Alias（模板别名）&quot; class=&quot;headerlink&quot; title=&quot;1. Type 
      
    
    </summary>
    
      <category term="C++学习笔记" scheme="http://yourenit.top/categories/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://yourenit.top/tags/C/"/>
    
      <category term="新特性" scheme="http://yourenit.top/tags/%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
      <category term="编程" scheme="http://yourenit.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++新特性之Lambda表达式</title>
    <link href="http://yourenit.top/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yourenit.top/C-学习笔记/C-新特性之Lambda表达式/</id>
    <published>2018-09-14T04:28:37.000Z</published>
    <updated>2018-09-15T16:23:54.800Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是lambda表达式？"><a href="#什么是lambda表达式？" class="headerlink" title="什么是lambda表达式？"></a>什么是lambda表达式？</h3><p>一个<code>lambda</code>表达式表示以一个可以调用的代码单元。或者理解为一个匿名的内联函数。与任何函数类似，一个<code>lambda</code>具有返回类型、一个参数列表和一个函数体。与函数不同，<code>lambda</code>可能定义在函数内部。</p><h3 id="为什么要有lambda表达式？"><a href="#为什么要有lambda表达式？" class="headerlink" title="为什么要有lambda表达式？"></a>为什么要有lambda表达式？</h3><p>我们知道，在<code>STL</code>所提供的算法中，往往有两个版本。其中一个版本表现最直观的的某种运算，第二个版本则表现出最泛化的演算流程，允许用户“以<code>template</code>参数来指定所要采取的策略”。以<code>sort()</code>为例，第一版本是默认<strong>从小到大排序（operator&lt;）</strong>，第二个版本则是允许你指定某种“操作”，使得排序后的两个相邻元素都能令该操作结果为<code>true</code>。事实上，第二版本允许我们想算法传递任何类别的<strong>可调用对象</strong>。这个“可调用对象”为第二个版本的第三个参数，被称为“<strong>谓词</strong>”。</p><h4 id="可调用对象"><a href="#可调用对象" class="headerlink" title="可调用对象"></a>可调用对象</h4><p>C++的可调用对象有5类：</p><ol><li>函数</li><li>函数指针</li><li>重载了函数调用运算符的类</li><li>bind创建的对象</li><li><strong>lambda表达式</strong></li></ol><p>而在标准算法中将“谓词”分为两类：<strong>一元谓词（只接受一个参数）</strong>、<strong>二元谓词（接受两个参数）</strong>。</p><p>但是我们在使用一个算法中，要使用更多的参数，超出了谓词的限制，或者调用的函数有时候只用一次，重用性太差，那我们就要解决这些问题。</p><p><code>C++11</code>就引入了<code>lambda表达式</code>来解决这些问题。</p><h3 id="lambda表达式怎么用？"><a href="#lambda表达式怎么用？" class="headerlink" title="lambda表达式怎么用？"></a>lambda表达式怎么用？</h3><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. [captures](params) -&gt; return type &#123; function body &#125;</span><br><span class="line">2. [captures](params) &#123; function body &#125;</span><br><span class="line">3. [captures] &#123; function body &#125;</span><br></pre></td></tr></table></figure><p><code>captures</code>为捕获列表，为lambda中定义的局部变量的列表。</p><p><code>params</code>表示参数列表。</p><p><code>return type</code>表示返回类型，为尾随返回类型。</p><p><code>function body</code>为函数体。</p><p>上面三种用法中，我们可以看出来，<strong>参数列表</strong>和<strong>返回类型</strong>可以忽略，但是必须包含<strong>捕获列表</strong>和<strong>函数体</strong>。</p><h4 id="lambda-捕获"><a href="#lambda-捕获" class="headerlink" title="lambda 捕获"></a>lambda 捕获</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[]：lambda不能使用所在函数的变量。</span><br><span class="line">[=]：值捕获，lambda表达式可以以拷贝的方式访问函数中的变量的值。</span><br><span class="line">[&amp;]：引用捕获，lambda表达式中以引用的方式访问函数中的变量的值。</span><br><span class="line">[=,&amp;]：值捕获和引用捕获混合使用。</span><br><span class="line">[var]：指定捕获或拷贝。</span><br><span class="line">[this]：捕获this指针。</span><br></pre></td></tr></table></figure><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;int&gt; a=&#123;1,2,3,4,5&#125;;</span><br><span class="line">    std::for_each(a.begin(),a.end(),[](int i)&#123; std::cout&lt;&lt;i&lt;&lt;&quot; &quot;&#125;);</span><br><span class="line">    </span><br><span class="line">    //C++14 lambda可以拥有自身的默认参数</span><br><span class="line">    auto func=[](inr i=6)&#123;return i+4;&#125;;</span><br><span class="line">    std::cout&lt;&lt;func()&lt;&lt;std::endl;</span><br><span class="line">    </span><br><span class="line">    //值捕获和引用捕获</span><br><span class="line">    int b=1024,c=2048;</span><br><span class="line">    auto func2=[b,&amp;c]&#123;</span><br><span class="line">        std::cout&lt;&lt;i&lt;&lt;std::endl;</span><br><span class="line">        std::cout&lt;&lt;&amp;j&lt;&lt;std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    func2();</span><br><span class="line">    </span><br><span class="line">    //与stl算法结合，找出a中大于3的一个元素</span><br><span class="line">    int x=3;</span><br><span class="line">    auto d=find_if(a.begin(),a.end(),</span><br><span class="line">        [x](int num)</span><br><span class="line">            &#123;return num&gt;x;&#125;);</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是lambda表达式？&quot;&gt;&lt;a href=&quot;#什么是lambda表达式？&quot; class=&quot;headerlink&quot; title=&quot;什么是lambda表达式？&quot;&gt;&lt;/a&gt;什么是lambda表达式？&lt;/h3&gt;&lt;p&gt;一个&lt;code&gt;lambda&lt;/code&gt;表达式表示
      
    
    </summary>
    
      <category term="C++学习笔记" scheme="http://yourenit.top/categories/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://yourenit.top/tags/C/"/>
    
      <category term="新特性" scheme="http://yourenit.top/tags/%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
      <category term="编程" scheme="http://yourenit.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
